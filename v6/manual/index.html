<!DOCTYPE html><html><head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../">
  <title data-ice="title">Manual | Sequelize</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<link rel="stylesheet" href="./inject/css/0-style.css"><link rel="stylesheet" href="./inject/css/0-theme.css"><meta name="description" content="An easy-to-use multi SQL dialect ORM for Node.js"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="Sequelize"><meta property="twitter:description" content="An easy-to-use multi SQL dialect ORM for Node.js"><meta name="viewport" content="width=device-width, initial-scale=1.0"></head>
<body class="layout-container manual-root manual-index" data-ice="rootContainer">

<header>
  <a href="./" style="display: flex; align-items: center;"><img src="./image/brand_logo.png" style="width:34px;"></a>
  
  <a href="identifiers.html" class="api-reference-link">API Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="" href="https://github.com/sequelize/sequelize"><img width="30px" src="./image/github.png" style="width: 30px;"></a>
      <a href="http://sequelize-slack.herokuapp.com/">
        <img src="manual/asset/slack.svg" style="width: 60px; margin-left: -15px;">
      </a>
    <div id="version-picker">Docs v6<ul><li><a href="/v7">Switch to v7</a></li><li><a href="/v6">Switch to v6</a></li><li><a href="/v5">Switch to v5</a></li><li><a href="/v4">Switch to v4</a></li><li><a href="/v3">Switch to v3</a></li></ul></div><style>#version-picker {cursor: pointer;}#version-picker:hover ul {display: block;}#version-picker ul {display: none;z-index: 100;background: white;padding: 0;list-style-type: none;border: 1px solid #ddd;}#version-picker ul li {list-style-type: none;padding: 0 10px;}#version-picker ul li:hover {background: #eee;}</style></header>

<nav class="navigation" data-ice="nav"><button id="navigationHamburger" class="hamburger" type="button"><span class="line"></span><span class="line"></span><span class="line"></span></button><div class="manual-toc-root">
  

    <div class="manual-group">
      <a href="index.html" style="color: black">Home</a>
    </div>
  <div class="manual-group no-mouse">Core Concepts</div><div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/getting-started.html"><a href="manual/getting-started.html" data-ice="link">Getting Started</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/getting-started.html"><a href="manual/getting-started.html#installing" data-ice="link">Installing</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/getting-started.html"><a href="manual/getting-started.html#connecting-to-a-database" data-ice="link">Connecting to a database</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/getting-started.html"><a href="manual/getting-started.html#testing-the-connection" data-ice="link">Testing the connection</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/getting-started.html"><a href="manual/getting-started.html#closing-the-connection" data-ice="link">Closing the connection</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/getting-started.html"><a href="manual/getting-started.html#terminology-convention" data-ice="link">Terminology convention</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/getting-started.html"><a href="manual/getting-started.html#tip-for-reading-the-docs" data-ice="link">Tip for reading the docs</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/getting-started.html"><a href="manual/getting-started.html#new-databases-versus-existing-databases" data-ice="link">New databases versus existing databases</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/getting-started.html"><a href="manual/getting-started.html#logging" data-ice="link">Logging</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/getting-started.html"><a href="manual/getting-started.html#promises-and-async-await" data-ice="link">Promises and async/await</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/model-basics.html"><a href="manual/model-basics.html" data-ice="link">Model Basics</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/model-basics.html"><a href="manual/model-basics.html#concept" data-ice="link">Concept</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/model-basics.html"><a href="manual/model-basics.html#model-definition" data-ice="link">Model Definition</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/model-basics.html"><a href="manual/model-basics.html#using--a-href-----class-src-sequelize-js-sequelize-html-instance-method-define---code-sequelize-define--code---a--" data-ice="link">Using sequelize.define:</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/model-basics.html"><a href="manual/model-basics.html#extending--a-href-----class-src-model-js-model-html--model--a-" data-ice="link">Extending Model</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/model-basics.html"><a href="manual/model-basics.html#caveat-with-public-class-fields" data-ice="link">Caveat with Public Class Fields</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/model-basics.html"><a href="manual/model-basics.html#table-name-inference" data-ice="link">Table name inference</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/model-basics.html"><a href="manual/model-basics.html#enforcing-the-table-name-to-be-equal-to-the-model-name" data-ice="link">Enforcing the table name to be equal to the model name</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/model-basics.html"><a href="manual/model-basics.html#providing-the-table-name-directly" data-ice="link">Providing the table name directly</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/model-basics.html"><a href="manual/model-basics.html#model-synchronization" data-ice="link">Model synchronization</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/model-basics.html"><a href="manual/model-basics.html#synchronizing-all-models-at-once" data-ice="link">Synchronizing all models at once</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/model-basics.html"><a href="manual/model-basics.html#dropping-tables" data-ice="link">Dropping tables</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/model-basics.html"><a href="manual/model-basics.html#database-safety-check" data-ice="link">Database safety check</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/model-basics.html"><a href="manual/model-basics.html#synchronization-in-production" data-ice="link">Synchronization in production</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/model-basics.html"><a href="manual/model-basics.html#timestamps" data-ice="link">Timestamps</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/model-basics.html"><a href="manual/model-basics.html#column-declaration-shorthand-syntax" data-ice="link">Column declaration shorthand syntax</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/model-basics.html"><a href="manual/model-basics.html#default-values" data-ice="link">Default Values</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/model-basics.html"><a href="manual/model-basics.html#data-types" data-ice="link">Data Types</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/model-basics.html"><a href="manual/model-basics.html#strings" data-ice="link">Strings</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/model-basics.html"><a href="manual/model-basics.html#boolean" data-ice="link">Boolean</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/model-basics.html"><a href="manual/model-basics.html#numbers" data-ice="link">Numbers</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/model-basics.html"><a href="manual/model-basics.html#unsigned--amp--zerofill-integers---mysql-mariadb-only" data-ice="link">Unsigned &amp; Zerofill integers - MySQL/MariaDB only</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/model-basics.html"><a href="manual/model-basics.html#dates" data-ice="link">Dates</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/model-basics.html"><a href="manual/model-basics.html#uuids" data-ice="link">UUIDs</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/model-basics.html"><a href="manual/model-basics.html#others" data-ice="link">Others</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/model-basics.html"><a href="manual/model-basics.html#column-options" data-ice="link">Column Options</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/model-basics.html"><a href="manual/model-basics.html#taking-advantage-of-models-being-classes" data-ice="link">Taking advantage of Models being classes</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/model-instances.html"><a href="manual/model-instances.html" data-ice="link">Model Instances</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/model-instances.html"><a href="manual/model-instances.html#creating-an-instance" data-ice="link">Creating an instance</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/model-instances.html"><a href="manual/model-instances.html#a-very-useful-shortcut--the--code-create--code--method" data-ice="link">A very useful shortcut: the create method</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/model-instances.html"><a href="manual/model-instances.html#note--logging-instances" data-ice="link">Note: logging instances</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/model-instances.html"><a href="manual/model-instances.html#default-values" data-ice="link">Default values</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/model-instances.html"><a href="manual/model-instances.html#updating-an-instance" data-ice="link">Updating an instance</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/model-instances.html"><a href="manual/model-instances.html#deleting-an-instance" data-ice="link">Deleting an instance</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/model-instances.html"><a href="manual/model-instances.html#reloading-an-instance" data-ice="link">Reloading an instance</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/model-instances.html"><a href="manual/model-instances.html#saving-only-some-fields" data-ice="link">Saving only some fields</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/model-instances.html"><a href="manual/model-instances.html#change-awareness-of-save" data-ice="link">Change-awareness of save</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/model-instances.html"><a href="manual/model-instances.html#incrementing-and-decrementing-integer-values" data-ice="link">Incrementing and decrementing integer values</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/model-querying-basics.html"><a href="manual/model-querying-basics.html" data-ice="link">Model Querying - Basics</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/model-querying-basics.html"><a href="manual/model-querying-basics.html#simple-insert-queries" data-ice="link">Simple INSERT queries</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/model-querying-basics.html"><a href="manual/model-querying-basics.html#simple-select-queries" data-ice="link">Simple SELECT queries</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/model-querying-basics.html"><a href="manual/model-querying-basics.html#specifying-attributes-for-select-queries" data-ice="link">Specifying attributes for SELECT queries</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/model-querying-basics.html"><a href="manual/model-querying-basics.html#applying-where-clauses" data-ice="link">Applying WHERE clauses</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/model-querying-basics.html"><a href="manual/model-querying-basics.html#the-basics" data-ice="link">The basics</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/model-querying-basics.html"><a href="manual/model-querying-basics.html#operators" data-ice="link">Operators</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/model-querying-basics.html"><a href="manual/model-querying-basics.html#shorthand-syntax-for--code-op-in--code-" data-ice="link">Shorthand syntax for Op.in</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/model-querying-basics.html"><a href="manual/model-querying-basics.html#logical-combinations-with-operators" data-ice="link">Logical combinations with operators</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/model-querying-basics.html"><a href="manual/model-querying-basics.html#examples-with--code-op-and--code--and--code-op-or--code-" data-ice="link">Examples with Op.and and Op.or</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/model-querying-basics.html"><a href="manual/model-querying-basics.html#examples-with--code-op-not--code-" data-ice="link">Examples with Op.not</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/model-querying-basics.html"><a href="manual/model-querying-basics.html#advanced-queries-with-functions--not-just-columns-" data-ice="link">Advanced queries with functions (not just columns)</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/model-querying-basics.html"><a href="manual/model-querying-basics.html#postgres-only-range-operators" data-ice="link">Postgres-only Range Operators</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/model-querying-basics.html"><a href="manual/model-querying-basics.html#deprecated--operator-aliases" data-ice="link">Deprecated: Operator Aliases</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/model-querying-basics.html"><a href="manual/model-querying-basics.html#simple-update-queries" data-ice="link">Simple UPDATE queries</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/model-querying-basics.html"><a href="manual/model-querying-basics.html#simple-delete-queries" data-ice="link">Simple DELETE queries</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/model-querying-basics.html"><a href="manual/model-querying-basics.html#creating-in-bulk" data-ice="link">Creating in bulk</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/model-querying-basics.html"><a href="manual/model-querying-basics.html#ordering-and-grouping" data-ice="link">Ordering and Grouping</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/model-querying-basics.html"><a href="manual/model-querying-basics.html#ordering" data-ice="link">Ordering</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/model-querying-basics.html"><a href="manual/model-querying-basics.html#grouping" data-ice="link">Grouping</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/model-querying-basics.html"><a href="manual/model-querying-basics.html#limits-and-pagination" data-ice="link">Limits and Pagination</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/model-querying-basics.html"><a href="manual/model-querying-basics.html#utility-methods" data-ice="link">Utility methods</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/model-querying-basics.html"><a href="manual/model-querying-basics.html#-code-count--code-" data-ice="link">count</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/model-querying-basics.html"><a href="manual/model-querying-basics.html#-code-max--code----code-min--code--and--code-sum--code-" data-ice="link">max, min and sum</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/model-querying-basics.html"><a href="manual/model-querying-basics.html#-code-increment--code----code-decrement--code-" data-ice="link">increment, decrement</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/model-querying-finders.html"><a href="manual/model-querying-finders.html" data-ice="link">Model Querying - Finders</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/model-querying-finders.html"><a href="manual/model-querying-finders.html#-code-findall--code-" data-ice="link">findAll</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/model-querying-finders.html"><a href="manual/model-querying-finders.html#-code-findbypk--code-" data-ice="link">findByPk</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/model-querying-finders.html"><a href="manual/model-querying-finders.html#-code-findone--code-" data-ice="link">findOne</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/model-querying-finders.html"><a href="manual/model-querying-finders.html#-code-findorcreate--code-" data-ice="link">findOrCreate</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/model-querying-finders.html"><a href="manual/model-querying-finders.html#-code-findandcountall--code-" data-ice="link">findAndCountAll</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/getters-setters-virtuals.html"><a href="manual/getters-setters-virtuals.html" data-ice="link">Getters, Setters &amp; Virtuals</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/getters-setters-virtuals.html"><a href="manual/getters-setters-virtuals.html#getters" data-ice="link">Getters</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/getters-setters-virtuals.html"><a href="manual/getters-setters-virtuals.html#setters" data-ice="link">Setters</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/getters-setters-virtuals.html"><a href="manual/getters-setters-virtuals.html#combining-getters-and-setters" data-ice="link">Combining getters and setters</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/getters-setters-virtuals.html"><a href="manual/getters-setters-virtuals.html#virtual-fields" data-ice="link">Virtual fields</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/getters-setters-virtuals.html"><a href="manual/getters-setters-virtuals.html#deprecated-in-sequelize-v7---code-gettermethods--code--and--code-settermethods--code-" data-ice="link">Deprecated in Sequelize v7: getterMethods and setterMethods</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/validations-and-constraints.html"><a href="manual/validations-and-constraints.html" data-ice="link">Validations &amp; Constraints</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/validations-and-constraints.html"><a href="manual/validations-and-constraints.html#difference-between-validations-and-constraints" data-ice="link">Difference between Validations and Constraints</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/validations-and-constraints.html"><a href="manual/validations-and-constraints.html#unique-constraint" data-ice="link">Unique Constraint</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/validations-and-constraints.html"><a href="manual/validations-and-constraints.html#allowing-disallowing-null-values" data-ice="link">Allowing/disallowing null values</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/validations-and-constraints.html"><a href="manual/validations-and-constraints.html#note-about--code-allownull--code--implementation" data-ice="link">Note about allowNull implementation</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/validations-and-constraints.html"><a href="manual/validations-and-constraints.html#validators" data-ice="link">Validators</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/validations-and-constraints.html"><a href="manual/validations-and-constraints.html#per-attribute-validations" data-ice="link">Per-attribute validations</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/validations-and-constraints.html"><a href="manual/validations-and-constraints.html#-code-allownull--code--interaction-with-other-validators" data-ice="link">allowNull interaction with other validators</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/validations-and-constraints.html"><a href="manual/validations-and-constraints.html#model-wide-validations" data-ice="link">Model-wide validations</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/raw-queries.html"><a href="manual/raw-queries.html" data-ice="link">Raw Queries</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/raw-queries.html"><a href="manual/raw-queries.html#-quot-dotted-quot--attributes-and-the--code-nest--code--option" data-ice="link">"Dotted" attributes and the nest option</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/raw-queries.html"><a href="manual/raw-queries.html#replacements" data-ice="link">Replacements</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/raw-queries.html"><a href="manual/raw-queries.html#bind-parameter" data-ice="link">Bind Parameter</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/assocs.html"><a href="manual/assocs.html" data-ice="link">Associations</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/assocs.html"><a href="manual/assocs.html#defining-the-sequelize-associations" data-ice="link">Defining the Sequelize associations</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/assocs.html"><a href="manual/assocs.html#creating-the-standard-relationships" data-ice="link">Creating the standard relationships</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/assocs.html"><a href="manual/assocs.html#one-to-one-relationships" data-ice="link">One-To-One relationships</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/assocs.html"><a href="manual/assocs.html#philosophy" data-ice="link">Philosophy</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/assocs.html"><a href="manual/assocs.html#goal" data-ice="link">Goal</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/assocs.html"><a href="manual/assocs.html#implementation" data-ice="link">Implementation</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/assocs.html"><a href="manual/assocs.html#options" data-ice="link">Options</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/assocs.html"><a href="manual/assocs.html#-code-ondelete--code--and--code-onupdate--code-" data-ice="link">onDelete and onUpdate</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/assocs.html"><a href="manual/assocs.html#customizing-the-foreign-key" data-ice="link">Customizing the foreign key</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/assocs.html"><a href="manual/assocs.html#mandatory-versus-optional-associations" data-ice="link">Mandatory versus optional associations</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/assocs.html"><a href="manual/assocs.html#one-to-many-relationships" data-ice="link">One-To-Many relationships</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/assocs.html"><a href="manual/assocs.html#philosophy" data-ice="link">Philosophy</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/assocs.html"><a href="manual/assocs.html#goal" data-ice="link">Goal</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/assocs.html"><a href="manual/assocs.html#implementation" data-ice="link">Implementation</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/assocs.html"><a href="manual/assocs.html#options" data-ice="link">Options</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/assocs.html"><a href="manual/assocs.html#many-to-many-relationships" data-ice="link">Many-To-Many relationships</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/assocs.html"><a href="manual/assocs.html#philosophy" data-ice="link">Philosophy</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/assocs.html"><a href="manual/assocs.html#goal" data-ice="link">Goal</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/assocs.html"><a href="manual/assocs.html#implementation" data-ice="link">Implementation</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/assocs.html"><a href="manual/assocs.html#options" data-ice="link">Options</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/assocs.html"><a href="manual/assocs.html#basics-of-queries-involving-associations" data-ice="link">Basics of queries involving associations</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/assocs.html"><a href="manual/assocs.html#fetching-associations---eager-loading-vs-lazy-loading" data-ice="link">Fetching associations - Eager Loading vs Lazy Loading</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/assocs.html"><a href="manual/assocs.html#lazy-loading-example" data-ice="link">Lazy Loading example</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/assocs.html"><a href="manual/assocs.html#eager-loading-example" data-ice="link">Eager Loading Example</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/assocs.html"><a href="manual/assocs.html#creating--updating-and-deleting" data-ice="link">Creating, updating and deleting</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/assocs.html"><a href="manual/assocs.html#association-aliases--amp--custom-foreign-keys" data-ice="link">Association Aliases &amp; Custom Foreign Keys</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/assocs.html"><a href="manual/assocs.html#recap--the-default-setup" data-ice="link">Recap: the default setup</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/assocs.html"><a href="manual/assocs.html#providing-the-foreign-key-name-directly" data-ice="link">Providing the foreign key name directly</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/assocs.html"><a href="manual/assocs.html#defining-an-alias" data-ice="link">Defining an Alias</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/assocs.html"><a href="manual/assocs.html#doing-both-things" data-ice="link">Doing both things</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/assocs.html"><a href="manual/assocs.html#special-methods-mixins-added-to-instances" data-ice="link">Special methods/mixins added to instances</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/assocs.html"><a href="manual/assocs.html#-code-foo-hasone-bar---code-" data-ice="link">Foo.hasOne(Bar)</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/assocs.html"><a href="manual/assocs.html#-code-foo-belongsto-bar---code-" data-ice="link">Foo.belongsTo(Bar)</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/assocs.html"><a href="manual/assocs.html#-code-foo-hasmany-bar---code-" data-ice="link">Foo.hasMany(Bar)</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/assocs.html"><a href="manual/assocs.html#-code-foo-belongstomany-bar----through--baz-----code-" data-ice="link">Foo.belongsToMany(Bar, { through: Baz })</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/assocs.html"><a href="manual/assocs.html#note--method-names" data-ice="link">Note: Method names</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/assocs.html"><a href="manual/assocs.html#why-associations-are-defined-in-pairs-" data-ice="link">Why associations are defined in pairs?</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/assocs.html"><a href="manual/assocs.html#multiple-associations-involving-the-same-models" data-ice="link">Multiple associations involving the same models</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/assocs.html"><a href="manual/assocs.html#creating-associations-referencing-a-field-which-is-not-the-primary-key" data-ice="link">Creating associations referencing a field which is not the primary key</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/assocs.html"><a href="manual/assocs.html#for--code-belongsto--code--relationships" data-ice="link">For belongsTo relationships</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/assocs.html"><a href="manual/assocs.html#for--code-hasone--code--and--code-hasmany--code--relationships" data-ice="link">For hasOne and hasMany relationships</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/assocs.html"><a href="manual/assocs.html#for--code-belongstomany--code--relationships" data-ice="link">For belongsToMany relationships</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/assocs.html"><a href="manual/assocs.html#notes" data-ice="link">Notes</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/paranoid.html"><a href="manual/paranoid.html" data-ice="link">Paranoid</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/paranoid.html"><a href="manual/paranoid.html#defining-a-model-as-paranoid" data-ice="link">Defining a model as paranoid</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/paranoid.html"><a href="manual/paranoid.html#deleting" data-ice="link">Deleting</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/paranoid.html"><a href="manual/paranoid.html#restoring" data-ice="link">Restoring</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/paranoid.html"><a href="manual/paranoid.html#behavior-with-other-queries" data-ice="link">Behavior with other queries</a></li>
</ul>
  </div>
<div class="manual-group no-mouse">Advanced Association Concepts</div><div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/eager-loading.html"><a href="manual/eager-loading.html" data-ice="link">Eager Loading</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/eager-loading.html"><a href="manual/eager-loading.html#basic-example" data-ice="link">Basic example</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/eager-loading.html"><a href="manual/eager-loading.html#fetching-a-single-associated-element" data-ice="link">Fetching a single associated element</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/eager-loading.html"><a href="manual/eager-loading.html#fetching-all-associated-elements" data-ice="link">Fetching all associated elements</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/eager-loading.html"><a href="manual/eager-loading.html#fetching-an-aliased-association" data-ice="link">Fetching an Aliased association</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/eager-loading.html"><a href="manual/eager-loading.html#required-eager-loading" data-ice="link">Required eager loading</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/eager-loading.html"><a href="manual/eager-loading.html#eager-loading-filtered-at-the-associated-model-level" data-ice="link">Eager loading filtered at the associated model level</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/eager-loading.html"><a href="manual/eager-loading.html#referring-to-other-columns" data-ice="link">Referring to other columns</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/eager-loading.html"><a href="manual/eager-loading.html#complex-where-clauses-at-the-top-level" data-ice="link">Complex where clauses at the top-level</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/eager-loading.html"><a href="manual/eager-loading.html#fetching-with--code-right-outer-join--code---mysql--mariadb--postgresql-and-mssql-only-" data-ice="link">Fetching with RIGHT OUTER JOIN (MySQL, MariaDB, PostgreSQL and MSSQL only)</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/eager-loading.html"><a href="manual/eager-loading.html#multiple-eager-loading" data-ice="link">Multiple eager loading</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/eager-loading.html"><a href="manual/eager-loading.html#eager-loading-with-many-to-many-relationships" data-ice="link">Eager loading with Many-to-Many relationships</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/eager-loading.html"><a href="manual/eager-loading.html#including-everything" data-ice="link">Including everything</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/eager-loading.html"><a href="manual/eager-loading.html#including-soft-deleted-records" data-ice="link">Including soft deleted records</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/eager-loading.html"><a href="manual/eager-loading.html#ordering-eager-loaded-associations" data-ice="link">Ordering eager loaded associations</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/eager-loading.html"><a href="manual/eager-loading.html#complex-ordering-involving-sub-queries" data-ice="link">Complex ordering involving sub-queries</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/eager-loading.html"><a href="manual/eager-loading.html#nested-eager-loading" data-ice="link">Nested eager loading</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/eager-loading.html"><a href="manual/eager-loading.html#using--code-findandcountall--code--with-includes" data-ice="link">Using findAndCountAll with includes</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/creating-with-associations.html"><a href="manual/creating-with-associations.html" data-ice="link">Creating with Associations</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/creating-with-associations.html"><a href="manual/creating-with-associations.html#belongsto---hasmany---hasone-association" data-ice="link">BelongsTo / HasMany / HasOne association</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/creating-with-associations.html"><a href="manual/creating-with-associations.html#belongsto-association-with-an-alias" data-ice="link">BelongsTo association with an alias</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/creating-with-associations.html"><a href="manual/creating-with-associations.html#hasmany---belongstomany-association" data-ice="link">HasMany / BelongsToMany association</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/advanced-many-to-many.html"><a href="manual/advanced-many-to-many.html" data-ice="link">Advanced M:N Associations</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/advanced-many-to-many.html"><a href="manual/advanced-many-to-many.html#through-tables-versus-normal-tables-and-the--quot-super-many-to-many-association-quot-" data-ice="link">Through tables versus normal tables and the "Super Many-to-Many association"</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/advanced-many-to-many.html"><a href="manual/advanced-many-to-many.html#models-recap--with-minor-rename-" data-ice="link">Models recap (with minor rename)</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/advanced-many-to-many.html"><a href="manual/advanced-many-to-many.html#using-one-to-many-relationships-instead" data-ice="link">Using One-to-Many relationships instead</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/advanced-many-to-many.html"><a href="manual/advanced-many-to-many.html#the-best-of-both-worlds--the-super-many-to-many-relationship" data-ice="link">The best of both worlds: the Super Many-to-Many relationship</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/advanced-many-to-many.html"><a href="manual/advanced-many-to-many.html#aliases-and-custom-key-names" data-ice="link">Aliases and custom key names</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/advanced-many-to-many.html"><a href="manual/advanced-many-to-many.html#self-references" data-ice="link">Self-references</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/advanced-many-to-many.html"><a href="manual/advanced-many-to-many.html#specifying-attributes-from-the-through-table" data-ice="link">Specifying attributes from the through table</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/advanced-many-to-many.html"><a href="manual/advanced-many-to-many.html#many-to-many-to-many-relationships-and-beyond" data-ice="link">Many-to-many-to-many relationships and beyond</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/association-scopes.html"><a href="manual/association-scopes.html" data-ice="link">Association Scopes</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/association-scopes.html"><a href="manual/association-scopes.html#concept" data-ice="link">Concept</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/association-scopes.html"><a href="manual/association-scopes.html#example" data-ice="link">Example</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/association-scopes.html"><a href="manual/association-scopes.html#achieving-the-same-behavior-with-standard-scopes" data-ice="link">Achieving the same behavior with standard scopes</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/polymorphic-associations.html"><a href="manual/polymorphic-associations.html" data-ice="link">Polymorphic Associations</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/polymorphic-associations.html"><a href="manual/polymorphic-associations.html#concept" data-ice="link">Concept</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/polymorphic-associations.html"><a href="manual/polymorphic-associations.html#configuring-a-one-to-many-polymorphic-association" data-ice="link">Configuring a One-to-Many polymorphic association</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/polymorphic-associations.html"><a href="manual/polymorphic-associations.html#polymorphic-lazy-loading" data-ice="link">Polymorphic lazy loading</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/polymorphic-associations.html"><a href="manual/polymorphic-associations.html#polymorphic-eager-loading" data-ice="link">Polymorphic eager loading</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/polymorphic-associations.html"><a href="manual/polymorphic-associations.html#caution---possibly-invalid-eager-lazy-loading-" data-ice="link">Caution - possibly invalid eager/lazy loading!</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/polymorphic-associations.html"><a href="manual/polymorphic-associations.html#configuring-a-many-to-many-polymorphic-association" data-ice="link">Configuring a Many-to-Many polymorphic association</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/polymorphic-associations.html"><a href="manual/polymorphic-associations.html#applying-scopes-on-the-target-model" data-ice="link">Applying scopes on the target model</a></li>
</ul>
  </div>
<div class="manual-group no-mouse">Other Topics</div><div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/dialect-specific-things.html"><a href="manual/dialect-specific-things.html" data-ice="link">Dialect-Specific Things</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/dialect-specific-things.html"><a href="manual/dialect-specific-things.html#underlying-connector-libraries" data-ice="link">Underlying Connector Libraries</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/dialect-specific-things.html"><a href="manual/dialect-specific-things.html#mysql" data-ice="link">MySQL</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/dialect-specific-things.html"><a href="manual/dialect-specific-things.html#mariadb" data-ice="link">MariaDB</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/dialect-specific-things.html"><a href="manual/dialect-specific-things.html#sqlite" data-ice="link">SQLite</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/dialect-specific-things.html"><a href="manual/dialect-specific-things.html#postgresql" data-ice="link">PostgreSQL</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/dialect-specific-things.html"><a href="manual/dialect-specific-things.html#redshift" data-ice="link">Redshift</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/dialect-specific-things.html"><a href="manual/dialect-specific-things.html#mssql" data-ice="link">MSSQL</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/dialect-specific-things.html"><a href="manual/dialect-specific-things.html#mssql-domain-account" data-ice="link">MSSQL Domain Account</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/dialect-specific-things.html"><a href="manual/dialect-specific-things.html#snowflake--experiment-" data-ice="link">Snowflake (Experiment)</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/dialect-specific-things.html"><a href="manual/dialect-specific-things.html#data-type--timestamp-without-time-zone---postgresql-only" data-ice="link">Data type: TIMESTAMP WITHOUT TIME ZONE - PostgreSQL only</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/dialect-specific-things.html"><a href="manual/dialect-specific-things.html#data-type--array-enum----postgresql-only" data-ice="link">Data type: ARRAY(ENUM) - PostgreSQL only</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/dialect-specific-things.html"><a href="manual/dialect-specific-things.html#table-hints---mssql-only" data-ice="link">Table Hints - MSSQL only</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/dialect-specific-things.html"><a href="manual/dialect-specific-things.html#index-hints---mysql-mariadb-only" data-ice="link">Index Hints - MySQL/MariaDB only</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/dialect-specific-things.html"><a href="manual/dialect-specific-things.html#engines---mysql-mariadb-only" data-ice="link">Engines - MySQL/MariaDB only</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/dialect-specific-things.html"><a href="manual/dialect-specific-things.html#table-comments---mysql-mariadb-postgresql-only" data-ice="link">Table comments - MySQL/MariaDB/PostgreSQL only</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/transactions.html"><a href="manual/transactions.html" data-ice="link">Transactions</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/transactions.html"><a href="manual/transactions.html#unmanaged-transactions" data-ice="link">Unmanaged transactions</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/transactions.html"><a href="manual/transactions.html#managed-transactions" data-ice="link">Managed transactions</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/transactions.html"><a href="manual/transactions.html#throw-errors-to-rollback" data-ice="link">Throw errors to rollback</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/transactions.html"><a href="manual/transactions.html#automatically-pass-transactions-to-all-queries" data-ice="link">Automatically pass transactions to all queries</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/transactions.html"><a href="manual/transactions.html#concurrent-partial-transactions" data-ice="link">Concurrent/Partial transactions</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/transactions.html"><a href="manual/transactions.html#with-cls-enabled" data-ice="link">With CLS enabled</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/transactions.html"><a href="manual/transactions.html#passing-options" data-ice="link">Passing options</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/transactions.html"><a href="manual/transactions.html#isolation-levels" data-ice="link">Isolation levels</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/transactions.html"><a href="manual/transactions.html#usage-with-other-sequelize-methods" data-ice="link">Usage with other sequelize methods</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/transactions.html"><a href="manual/transactions.html#the--code-aftercommit--code--hook" data-ice="link">The afterCommit hook</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/transactions.html"><a href="manual/transactions.html#locks" data-ice="link">Locks</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/hooks.html"><a href="manual/hooks.html" data-ice="link">Hooks</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/hooks.html"><a href="manual/hooks.html#available-hooks" data-ice="link">Available hooks</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/hooks.html"><a href="manual/hooks.html#hooks-firing-order" data-ice="link">Hooks firing order</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/hooks.html"><a href="manual/hooks.html#declaring-hooks" data-ice="link">Declaring Hooks</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/hooks.html"><a href="manual/hooks.html#removing-hooks" data-ice="link">Removing hooks</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/hooks.html"><a href="manual/hooks.html#global---universal-hooks" data-ice="link">Global / universal hooks</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/hooks.html"><a href="manual/hooks.html#default-hooks--on-sequelize-constructor-options-" data-ice="link">Default Hooks (on Sequelize constructor options)</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/hooks.html"><a href="manual/hooks.html#permanent-hooks--with--code-sequelize-addhook--code--" data-ice="link">Permanent Hooks (with sequelize.addHook)</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/hooks.html"><a href="manual/hooks.html#connection-hooks" data-ice="link">Connection Hooks</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/hooks.html"><a href="manual/hooks.html#instance-hooks" data-ice="link">Instance hooks</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/hooks.html"><a href="manual/hooks.html#model-hooks" data-ice="link">Model hooks</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/hooks.html"><a href="manual/hooks.html#associations" data-ice="link">Associations</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/hooks.html"><a href="manual/hooks.html#one-to-one-and-one-to-many-associations" data-ice="link">One-to-One and One-to-Many associations</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/hooks.html"><a href="manual/hooks.html#many-to-many-associations" data-ice="link">Many-to-Many associations</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/hooks.html"><a href="manual/hooks.html#hooks-and-transactions" data-ice="link">Hooks and Transactions</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/hooks.html"><a href="manual/hooks.html#internal-transactions" data-ice="link">Internal Transactions</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/query-interface.html"><a href="manual/query-interface.html" data-ice="link">Query Interface</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/query-interface.html"><a href="manual/query-interface.html#obtaining-the-query-interface" data-ice="link">Obtaining the query interface</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/query-interface.html"><a href="manual/query-interface.html#creating-a-table" data-ice="link">Creating a table</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/query-interface.html"><a href="manual/query-interface.html#adding-a-column-to-a-table" data-ice="link">Adding a column to a table</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/query-interface.html"><a href="manual/query-interface.html#changing-the-datatype-of-a-column" data-ice="link">Changing the datatype of a column</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/query-interface.html"><a href="manual/query-interface.html#removing-a-column" data-ice="link">Removing a column</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/query-interface.html"><a href="manual/query-interface.html#changing-and-removing-columns-in-sqlite" data-ice="link">Changing and removing columns in SQLite</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/query-interface.html"><a href="manual/query-interface.html#other" data-ice="link">Other</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/naming-strategies.html"><a href="manual/naming-strategies.html" data-ice="link">Naming Strategies</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/naming-strategies.html"><a href="manual/naming-strategies.html#the--code-underscored--code--option" data-ice="link">The underscored option</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/naming-strategies.html"><a href="manual/naming-strategies.html#singular-vs--plural" data-ice="link">Singular vs. Plural</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/naming-strategies.html"><a href="manual/naming-strategies.html#when-defining-models" data-ice="link">When defining models</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/naming-strategies.html"><a href="manual/naming-strategies.html#when-defining-a-reference-key-in-a-model" data-ice="link">When defining a reference key in a model</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/naming-strategies.html"><a href="manual/naming-strategies.html#when-retrieving-data-from-eager-loading" data-ice="link">When retrieving data from eager loading</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/naming-strategies.html"><a href="manual/naming-strategies.html#overriding-singulars-and-plurals-when-defining-aliases" data-ice="link">Overriding singulars and plurals when defining aliases</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/scopes.html"><a href="manual/scopes.html" data-ice="link">Scopes</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/scopes.html"><a href="manual/scopes.html#definition" data-ice="link">Definition</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/scopes.html"><a href="manual/scopes.html#usage" data-ice="link">Usage</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/scopes.html"><a href="manual/scopes.html#merging" data-ice="link">Merging</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/scopes.html"><a href="manual/scopes.html#merging-includes" data-ice="link">Merging includes</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/sub-queries.html"><a href="manual/sub-queries.html" data-ice="link">Sub Queries</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/sub-queries.html"><a href="manual/sub-queries.html#using-sub-queries-for-complex-ordering" data-ice="link">Using sub-queries for complex ordering</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/other-data-types.html"><a href="manual/other-data-types.html" data-ice="link">Other Data Types</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/other-data-types.html"><a href="manual/other-data-types.html#ranges--postgresql-only-" data-ice="link">Ranges (PostgreSQL only)</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/other-data-types.html"><a href="manual/other-data-types.html#special-cases" data-ice="link">Special Cases</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/other-data-types.html"><a href="manual/other-data-types.html#blobs" data-ice="link">BLOBs</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/other-data-types.html"><a href="manual/other-data-types.html#enums" data-ice="link">ENUMs</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/other-data-types.html"><a href="manual/other-data-types.html#json--sqlite--mysql--mariadb-and-postgresql-only-" data-ice="link">JSON (SQLite, MySQL, MariaDB and PostgreSQL only)</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/other-data-types.html"><a href="manual/other-data-types.html#note-for-postgresql" data-ice="link">Note for PostgreSQL</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/other-data-types.html"><a href="manual/other-data-types.html#jsonb--postgresql-only-" data-ice="link">JSONB (PostgreSQL only)</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/other-data-types.html"><a href="manual/other-data-types.html#mssql" data-ice="link">MSSQL</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/other-data-types.html"><a href="manual/other-data-types.html#others" data-ice="link">Others</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/constraints-and-circularities.html"><a href="manual/constraints-and-circularities.html" data-ice="link">Constraints &amp; Circularities</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/constraints-and-circularities.html"><a href="manual/constraints-and-circularities.html#enforcing-a-foreign-key-reference-without-constraints" data-ice="link">Enforcing a foreign key reference without constraints</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/extending-data-types.html"><a href="manual/extending-data-types.html" data-ice="link">Extending Data Types</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/extending-data-types.html"><a href="manual/extending-data-types.html#example" data-ice="link">Example</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/extending-data-types.html"><a href="manual/extending-data-types.html#postgresql" data-ice="link">PostgreSQL</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/extending-data-types.html"><a href="manual/extending-data-types.html#ranges" data-ice="link">Ranges</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/indexes.html"><a href="manual/indexes.html" data-ice="link">Indexes</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/optimistic-locking.html"><a href="manual/optimistic-locking.html" data-ice="link">Optimistic Locking</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/read-replication.html"><a href="manual/read-replication.html" data-ice="link">Read Replication</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/connection-pool.html"><a href="manual/connection-pool.html" data-ice="link">Connection Pool</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/legacy.html"><a href="manual/legacy.html" data-ice="link">Working with Legacy Tables</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/legacy.html"><a href="manual/legacy.html#tables" data-ice="link">Tables</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/legacy.html"><a href="manual/legacy.html#fields" data-ice="link">Fields</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/legacy.html"><a href="manual/legacy.html#primary-keys" data-ice="link">Primary keys</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/legacy.html"><a href="manual/legacy.html#foreign-keys" data-ice="link">Foreign keys</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/migrations.html"><a href="manual/migrations.html" data-ice="link">Migrations</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/migrations.html"><a href="manual/migrations.html#installing-the-cli" data-ice="link">Installing the CLI</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/migrations.html"><a href="manual/migrations.html#project-bootstrapping" data-ice="link">Project bootstrapping</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/migrations.html"><a href="manual/migrations.html#configuration" data-ice="link">Configuration</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/migrations.html"><a href="manual/migrations.html#creating-the-first-model--and-migration-" data-ice="link">Creating the first Model (and Migration)</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/migrations.html"><a href="manual/migrations.html#running-migrations" data-ice="link">Running Migrations</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/migrations.html"><a href="manual/migrations.html#undoing-migrations" data-ice="link">Undoing Migrations</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/migrations.html"><a href="manual/migrations.html#creating-the-first-seed" data-ice="link">Creating the first Seed</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/migrations.html"><a href="manual/migrations.html#running-seeds" data-ice="link">Running Seeds</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/migrations.html"><a href="manual/migrations.html#undoing-seeds" data-ice="link">Undoing Seeds</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/migrations.html"><a href="manual/migrations.html#migration-skeleton" data-ice="link">Migration Skeleton</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/migrations.html"><a href="manual/migrations.html#the--code--sequelizerc--code--file" data-ice="link">The .sequelizerc file</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/migrations.html"><a href="manual/migrations.html#dynamic-configuration" data-ice="link">Dynamic configuration</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/migrations.html"><a href="manual/migrations.html#using-babel" data-ice="link">Using Babel</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/migrations.html"><a href="manual/migrations.html#security-tip" data-ice="link">Security tip</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/migrations.html"><a href="manual/migrations.html#storage" data-ice="link">Storage</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/migrations.html"><a href="manual/migrations.html#migration-storage" data-ice="link">Migration Storage</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/migrations.html"><a href="manual/migrations.html#seed-storage" data-ice="link">Seed Storage</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/migrations.html"><a href="manual/migrations.html#configuration-connection-string" data-ice="link">Configuration Connection String</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/migrations.html"><a href="manual/migrations.html#programmatic-usage" data-ice="link">Programmatic usage</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/typescript.html"><a href="manual/typescript.html" data-ice="link">TypeScript</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/typescript.html"><a href="manual/typescript.html#installation" data-ice="link">Installation</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/typescript.html"><a href="manual/typescript.html#usage" data-ice="link">Usage</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/typescript.html"><a href="manual/typescript.html#usage-without-strict-types-for-attributes" data-ice="link">Usage without strict types for attributes</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/typescript.html"><a href="manual/typescript.html#usage-of--code-sequelize-define--code-" data-ice="link">Usage of sequelize.define</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/typescript.html"><a href="manual/typescript.html#utility-types" data-ice="link">Utility Types</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/typescript.html"><a href="manual/typescript.html#requesting-a-model-class" data-ice="link">Requesting a Model Class</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/typescript.html"><a href="manual/typescript.html#getting-a-model--39-s-attributes" data-ice="link">Getting a Model's attributes</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/resources.html"><a href="manual/resources.html" data-ice="link">Resources</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/resources.html"><a href="manual/resources.html#addons--amp--plugins" data-ice="link">Addons &amp; Plugins</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/resources.html"><a href="manual/resources.html#acl" data-ice="link">ACL</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/resources.html"><a href="manual/resources.html#auto-code-generation--amp--scaffolding" data-ice="link">Auto Code Generation &amp; Scaffolding</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/resources.html"><a href="manual/resources.html#autoloader" data-ice="link">Autoloader</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/resources.html"><a href="manual/resources.html#bcrypt" data-ice="link">Bcrypt</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/resources.html"><a href="manual/resources.html#caching" data-ice="link">Caching</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/resources.html"><a href="manual/resources.html#filters" data-ice="link">Filters</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/resources.html"><a href="manual/resources.html#fixtures---mock-data" data-ice="link">Fixtures / mock data</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/resources.html"><a href="manual/resources.html#hierarchies" data-ice="link">Hierarchies</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/resources.html"><a href="manual/resources.html#historical-records---time-travel" data-ice="link">Historical records / Time travel</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/resources.html"><a href="manual/resources.html#joi" data-ice="link">Joi</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/resources.html"><a href="manual/resources.html#migrations" data-ice="link">Migrations</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/resources.html"><a href="manual/resources.html#slugification" data-ice="link">Slugification</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/resources.html"><a href="manual/resources.html#tokens" data-ice="link">Tokens</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/resources.html"><a href="manual/resources.html#miscellaneous" data-ice="link">Miscellaneous</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/upgrade-to-v6.html"><a href="manual/upgrade-to-v6.html" data-ice="link">Upgrade to v6</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/upgrade-to-v6.html"><a href="manual/upgrade-to-v6.html#breaking-changes" data-ice="link">Breaking Changes</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/upgrade-to-v6.html"><a href="manual/upgrade-to-v6.html#support-for-node-10-and-up" data-ice="link">Support for Node 10 and up</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/upgrade-to-v6.html"><a href="manual/upgrade-to-v6.html#cls" data-ice="link">CLS</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/upgrade-to-v6.html"><a href="manual/upgrade-to-v6.html#database-engine-support" data-ice="link">Database Engine Support</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/upgrade-to-v6.html"><a href="manual/upgrade-to-v6.html#sequelize" data-ice="link">Sequelize</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/upgrade-to-v6.html"><a href="manual/upgrade-to-v6.html#model" data-ice="link">Model</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/upgrade-to-v6.html"><a href="manual/upgrade-to-v6.html#-code-options-returning--code-" data-ice="link">options.returning</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/upgrade-to-v6.html"><a href="manual/upgrade-to-v6.html#-code-model-changed----code-" data-ice="link">Model.changed()</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/upgrade-to-v6.html"><a href="manual/upgrade-to-v6.html#-code-model-bulkcreate----code-" data-ice="link">Model.bulkCreate()</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/upgrade-to-v6.html"><a href="manual/upgrade-to-v6.html#-code-model-upsert----code-" data-ice="link">Model.upsert()</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/upgrade-to-v6.html"><a href="manual/upgrade-to-v6.html#queryinterface" data-ice="link">QueryInterface</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/upgrade-to-v6.html"><a href="manual/upgrade-to-v6.html#-code-addconstraint--code-" data-ice="link">addConstraint</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/upgrade-to-v6.html"><a href="manual/upgrade-to-v6.html#changelog" data-ice="link">Changelog</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/upgrade-to-v6.html"><a href="manual/upgrade-to-v6.html#6-0-0-beta-7" data-ice="link">6.0.0-beta.7</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/upgrade-to-v6.html"><a href="manual/upgrade-to-v6.html#6-0-0-beta-6" data-ice="link">6.0.0-beta.6</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/upgrade-to-v6.html"><a href="manual/upgrade-to-v6.html#6-0-0-beta-5" data-ice="link">6.0.0-beta.5</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/upgrade-to-v6.html"><a href="manual/upgrade-to-v6.html#6-0-0-beta-4" data-ice="link">6.0.0-beta.4</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/upgrade-to-v6.html"><a href="manual/upgrade-to-v6.html#6-0-0-beta-3" data-ice="link">6.0.0-beta.3</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/upgrade-to-v6.html"><a href="manual/upgrade-to-v6.html#6-0-0-beta-2" data-ice="link">6.0.0-beta.2</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/whos-using.html"><a href="manual/whos-using.html" data-ice="link">Who's using sequelize?</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/aws-lambda.html"><a href="manual/aws-lambda.html" data-ice="link">Using sequelize in AWS Lambda</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/aws-lambda.html"><a href="manual/aws-lambda.html#tl-dr" data-ice="link">TL;DR</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/aws-lambda.html"><a href="manual/aws-lambda.html#using-aws-rds-proxy" data-ice="link">Using AWS RDS Proxy</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/aws-lambda.html"><a href="manual/aws-lambda.html#the-node-js-event-loop" data-ice="link">The Node.js event loop</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/aws-lambda.html"><a href="manual/aws-lambda.html#aws-lambda-function-handler-types-in-node-js" data-ice="link">AWS Lambda function handler types in Node.js</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/aws-lambda.html"><a href="manual/aws-lambda.html#aws-lambda-execution-environments--i-e--containers-" data-ice="link">AWS Lambda execution environments (i.e. containers)</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/aws-lambda.html"><a href="manual/aws-lambda.html#sequelize-connection-pooling-in-aws-lambda" data-ice="link">Sequelize connection pooling in AWS Lambda</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/aws-lambda.html"><a href="manual/aws-lambda.html#detailed-race-condition-example" data-ice="link">Detailed race condition example</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/legal.html"><a href="manual/legal.html" data-ice="link">Legal Notice</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/legal.html"><a href="manual/legal.html#license" data-ice="link">License</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/legal.html"><a href="manual/legal.html#author-s-" data-ice="link">AUTHOR(S)</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/legal.html"><a href="manual/legal.html#inhaltliche-verantwortung" data-ice="link">INHALTLICHE VERANTWORTUNG</a></li>
</ul>
  </div>





</div>
</nav>

<div class="content" data-ice="content"><div class="github-markdown">
  <div class="manual-user-index" data-ice="manualUserIndex"><p></p><div class="logo">
  <img src="./manual/asset/logo.png">
  <div class="sequelize"><h1>Sequelize</h1></div>
</div>

<p></p>
<p><a href="https://www.npmjs.com/package/sequelize"><img src="https://badgen.net/npm/v/sequelize" alt="npm version"></a>
<a href="https://github.com/sequelize/sequelize/actions?query=workflow%3ACI"><img src="https://github.com/sequelize/sequelize/workflows/CI/badge.svg" alt="Build Status"></a>
<a href="https://www.npmjs.com/package/sequelize"><img src="https://badgen.net/npm/dm/sequelize" alt="npm downloads"></a>
<a href="https://opencollective.com/sequelize"><img src="https://img.shields.io/opencollective/all/sequelize?label=sponsors" alt="sponsor"></a>
<a href="https://github.com/sequelize/sequelize"><img src="https://badgen.net/github/last-commit/sequelize/sequelize" alt="Last commit"></a>
<a href="https://github.com/sequelize/sequelize"><img src="https://badgen.net/github/merged-prs/sequelize/sequelize" alt="Merged PRs"></a>
<a href="https://github.com/sequelize/sequelize"><img src="https://badgen.net/github/stars/sequelize/sequelize" alt="GitHub stars"></a>
<a href="http://sequelize-slack.herokuapp.com/"><img src="http://sequelize-slack.herokuapp.com/badge.svg" alt="Slack Status"></a>
<a href="https://www.npmjs.com/package/sequelize"><img src="https://badgen.net/npm/node/sequelize" alt="node"></a>
<a href="https://github.com/sequelize/sequelize/blob/main/LICENSE"><img src="https://badgen.net/github/license/sequelize/sequelize" alt="License"></a>
<a href="https://github.com/semantic-release/semantic-release"><img src="https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg" alt="semantic-release"></a></p>
<p>Sequelize is a promise-based <a href="https://nodejs.org/en/about/">Node.js</a> <a href="https://en.wikipedia.org/wiki/Object-relational_mapping">ORM tool</a> for <a href="https://en.wikipedia.org/wiki/PostgreSQL">Postgres</a>, <a href="https://en.wikipedia.org/wiki/MySQL">MySQL</a>, <a href="https://en.wikipedia.org/wiki/MariaDB">MariaDB</a>, <a href="https://en.wikipedia.org/wiki/SQLite">SQLite</a>, <a href="https://en.wikipedia.org/wiki/Microsoft_SQL_Server">Microsoft SQL Server</a>, <a href="https://docs.aws.amazon.com/redshift/index.html">Amazon Redshift</a> and <a href="https://docs.snowflake.com/en/user-guide/intro-key-concepts.html">Snowflake’s Data Cloud</a>. It features solid transaction support, relations, eager and lazy loading, read replication and more.</p>
<p>Sequelize follows <a href="http://semver.org">Semantic Versioning</a> and supports Node v10 and above.</p>
<p>You are currently looking at the <strong>Tutorials and Guides</strong> for Sequelize. You might also be interested in the <a href="identifiers.html">API Reference</a>.</p>
<h2 id="quick-example">Quick example</h2><pre><code class="lang-js"><code class="source-code prettyprint">const { Sequelize, Model, DataTypes } = require('sequelize');
const sequelize = new Sequelize('sqlite::memory:');

class User extends Model {}
User.init({
  username: DataTypes.STRING,
  birthday: DataTypes.DATE
}, { sequelize, modelName: 'user' });

(async () =&gt; {
  await sequelize.sync();
  const jane = await User.create({
    username: 'janedoe',
    birthday: new Date(1980, 6, 20)
  });
  console.log(jane.toJSON());
})();</code>
</code></pre>
<p>To learn more about how to use Sequelize, read the tutorials available in the left menu. Begin with <a href="manual/getting-started.html">Getting Started</a>.</p>
<h2 id="supporting-the-project">Supporting the project</h2><p>Do you like Sequelize and would like to give back to the engineering team behind it?</p>
<p>We have recently created an <a href="https://opencollective.com/sequelize">OpenCollective based money pool</a> which is shared amongst all core maintainers based on their contributions. Every support is wholeheartedly welcome. ❤️</p>
</div>

  

  <div class="manual-cards">
    
  <div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Getting Started</h1><p>In this tutorial you will learn to make a simple setup of Sequelize.</p><h2>Installing</h2><p>Sequelize is available via <a href="https://www.npmjs.com/package/sequelize">npm</a> (or <a href="https://yarnpkg.com/package/sequelize">yarn</a>).</p><pre><code class="lang-sh"><code class="source-code prettyprint">npm install --save sequelize</code>
</code></pre><p>You'll also have to manually install the driver for your database of choice:</p><pre><code class="lang-sh"><code class="source-code prettyprint"># One of the following:
$ npm install --save pg pg-hstore # Postgres
$ npm install --save mysql2
$ npm install --save mariadb
$ npm install --save sqlite3
$ npm install --save tedious # Microsoft SQL Server</code>
</code></pre><h2>Connecting to a database</h2><p>To connect to the database, you must create a Sequelize instance. This can be done by either passing the connection parameters separately to the Sequelize constructor or by passing a single connection URI:</p><pre><code class="lang-js"><code class="source-code prettyprint">const { Sequelize } = require('sequelize');

// Option 1: Passing a connection URI
const sequelize = new Sequelize('sqlite::memory:') // Example for sqlite
const sequelize = new Sequelize('postgres://user:pass@example.com:5432/dbname') // Example for postgres

// Option 2: Passing parameters separately (sqlite)
const sequelize = new Sequelize({
  dialect: 'sqlite',
  storage: 'path/to/database.sqlite'
});

// Option 3: Passing parameters separately (other dialects)
const sequelize = new Sequelize('database', 'username', 'password', {
  host: 'localhost',
  dialect: /* one of 'mysql' | 'mariadb' | 'postgres' | 'mssql' */
});</code>
</code></pre><p>The Sequelize constructor accepts a lot of options. They are documented in the <a href="./manual/../class/src/sequelize.js~Sequelize.html#instance-constructor-constructor">API Reference</a>.</p><h3>Testing the connection</h3><p>You can use the <code>.authenticate()</code> function to test if the connection is OK:</p><pre><code class="lang-js"><code class="source-code prettyprint">try {
  await sequelize.authenticate();
  console.log('Connection has been established successfully.');
} catch (error) {
  console.error('Unable to connect to the database:', error);
}</code>
</code></pre><h3>Closing the connection</h3><p>Sequelize will keep the connection open by default, and use the same connection for all queries. If you need to close the connection, call <code>sequelize.close()</code> (which is asynchronous and returns a Promise).</p><h2>Terminology convention</h2><p>Observe that, in the examples above, <code>Sequelize</code> refers to the library itself while <code>sequelize</code> refers to an instance of Sequelize, which represents a connection to one database. This is the recommended convention and it will be followed throughout the documentation.</p><h2>Tip for reading the docs</h2><p>You are encouraged to run code examples locally while reading the Sequelize docs. This will help you learn faster. The easiest way to do this is using the SQLite dialect:</p><pre><code class="lang-js"><code class="source-code prettyprint">const { Sequelize, Op, Model, DataTypes } = require("sequelize");
const sequelize = new Sequelize("sqlite::memory:");

// Code here! It works!</code>
</code></pre><p>To experiment with the other dialects, which are harder to setup locally, you can use the <a href="https://github.com/papb/sequelize-sscce">Sequelize SSCCE</a> GitHub repository, which allows you to run code on all supported dialects directly from GitHub, for free, without any setup!</p><h2>New databases versus existing databases</h2><p>If you are starting a project from scratch, and your database is still empty, Sequelize can be used since the beginning in order to automate the creation of every table in your database.</p><p>Also, if you want to use Sequelize to connect to a database that is already filled with tables and data, that works as well! Sequelize has got you covered in both cases.</p><h2>Logging</h2><p>By default, Sequelize will log to console every SQL query it performs. The <code>options.logging</code> option can be used to customize this behavior, by defining the function that gets executed every time Sequelize would log something. The default value is <code>console.log</code> and when using that only the first log parameter of log function call is displayed. For example, for query logging the first parameter is the raw query and the second (hidden by default) is the Sequelize object.</p><p>Common useful values for <code>options.logging</code>:</p><pre><code class="lang-js"><code class="source-code prettyprint">const sequelize = new Sequelize('sqlite::memory:', {
  // Choose one of the logging options
  logging: console.log,                  // Default, displays the first parameter of the log function call
  logging: (...msg) =&gt; console.log(msg), // Displays all log function call parameters
  logging: false,                        // Disables logging
  logging: msg =&gt; logger.debug(msg),     // Use custom logger (e.g. Winston or Bunyan), displays the first parameter
  logging: logger.debug.bind(logger)     // Alternative way to use custom logger, displays all messages
});</code>
</code></pre><h2>Promises and async/await</h2><p>Most of the methods provided by Sequelize are asynchronous and therefore return Promises. They are all <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promises</a> , so you can use the Promise API (for example, using <code>then</code>, <code>catch</code>, <code>finally</code>) out of the box.</p><p>Of course, using <code>async</code> and <code>await</code> works normally as well.</p></div>
        <a data-ice="link" href="manual/getting-started.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Model Basics</h1><p>In this tutorial you will learn what models are in Sequelize and how to use them.</p><h2>Concept</h2><p>Models are the essence of Sequelize. A model is an abstraction that represents a table in your database. In Sequelize, it is a class that extends <a href="./manual/../class/src/model.js~Model.html">Model</a>.</p><p>The model tells Sequelize several things about the entity it represents, such as the name of the table in the database and which columns it has (and their data types).</p><p>A model in Sequelize has a name. This name does not have to be the same name of the table it represents in the database. Usually, models have singular names (such as <code>User</code>) while tables have pluralized names (such as <code>Users</code>), although this is fully configurable.</p><h2>Model Definition</h2><p>Models can be defined in two equivalent ways in Sequelize:</p><ul>
<li>Calling <a href="./manual/../class/src/sequelize.js~Sequelize.html#instance-method-define"><code>sequelize.define(modelName, attributes, options)</code></a></li>
<li>Extending <a href="./manual/../class/src/model.js~Model.html">Model</a> and calling <a href="./manual/../class/src/model.js~Model.html#static-method-init"><code>init(attributes, options)</code></a></li>
</ul><p>After a model is defined, it is available within <code>sequelize.models</code> by its model name.</p><p>To learn with an example, we will consider that we want to create a model to represent users, which have a <code>firstName</code> and a <code>lastName</code>. We want our model to be called <code>User</code>, and the table it represents is called <code>Users</code> in the database.</p><p>Both ways to define this model are shown below. After being defined, we can access our model with <code>sequelize.models.User</code>.</p><h3>Using <a href="./manual/../class/src/sequelize.js~Sequelize.html#instance-method-define"><code>sequelize.define</code></a>:</h3><pre><code class="lang-js"><code class="source-code prettyprint">const { Sequelize, DataTypes } = require('sequelize');
const sequelize = new Sequelize('sqlite::memory:');

const User = sequelize.define('User', {
  // Model attributes are defined here
  firstName: {
    type: DataTypes.STRING,
    allowNull: false
  },
  lastName: {
    type: DataTypes.STRING
    // allowNull defaults to true
  }
}, {
  // Other model options go here
});

// `sequelize.define` also returns the model
console.log(User === sequelize.models.User); // true</code>
</code></pre><h3>Extending <a href="./manual/../class/src/model.js~Model.html">Model</a></h3><pre><code class="lang-js"><code class="source-code prettyprint">const { Sequelize, DataTypes, Model } = require('sequelize');
const sequelize = new Sequelize('sqlite::memory:');

class User extends Model {}

User.init({
  // Model attributes are defined here
  firstName: {
    type: DataTypes.STRING,
    allowNull: false
  },
  lastName: {
    type: DataTypes.STRING
    // allowNull defaults to true
  }
}, {
  // Other model options go here
  sequelize, // We need to pass the connection instance
  modelName: 'User' // We need to choose the model name
});

// the defined model is the class itself
console.log(User === sequelize.models.User); // true</code>
</code></pre><p>Internally, <code>sequelize.define</code> calls <code>Model.init</code>, so both approaches are essentially equivalent.</p><h4>Caveat with Public Class Fields</h4><p>Adding a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Public_class_fields">Public Class Field</a> with the same name as one of the model's attribute is going to cause issues.
Sequelize adds a getter &amp; a setter for each attribute defined through <code>Model.init</code>.
Adding a Public Class Field will shadow those getter and setters, blocking access to the model's actual data.</p><pre><code class="lang-typescript"><code class="source-code prettyprint">// Invalid
class User extends Model {
  id; // this field will shadow sequelize's getter &amp; setter. It should be removed.
  otherPublicField; // this field does not shadow anything. It is fine.
}

User.init({
  id: {
    type: DataTypes.INTEGER,
    autoIncrement: true,
    primaryKey: true
  }
}, { sequelize });

const user = new User({ id: 1 });
user.id; // undefined</code>
</code></pre><pre><code class="lang-typescript"><code class="source-code prettyprint">// Valid
class User extends Model {
  otherPublicField;
}

User.init({
  id: {
    type: DataTypes.INTEGER,
    autoIncrement: true,
    primaryKey: true
  }
}, { sequelize });

const user = new User({ id: 1 });
user.id; // 1</code>
</code></pre><p>In TypeScript, you can add typing information without adding an actual public class field by using the <code>declare</code> keyword:</p><pre><code class="lang-typescript"><code class="source-code prettyprint">// Valid
class User extends Model {
  declare id: number; // this is ok! The 'declare' keyword ensures this field will not be emitted by TypeScript.
}

User.init({
  id: {
    type: DataTypes.INTEGER,
    autoIncrement: true,
    primaryKey: true
  }
}, { sequelize });

const user = new User({ id: 1 });
user.id; // 1</code>
</code></pre><h2>Table name inference</h2><p>Observe that, in both methods above, the table name (<code>Users</code>) was never explicitly defined. However, the model name was given (<code>User</code>).</p><p>By default, when the table name is not given, Sequelize automatically pluralizes the model name and uses that as the table name. This pluralization is done under the hood by a library called <a href="https://www.npmjs.com/package/inflection">inflection</a>, so that irregular plurals (such as <code>person -&gt; people</code>) are computed correctly.</p><p>Of course, this behavior is easily configurable.</p><h3>Enforcing the table name to be equal to the model name</h3><p>You can stop the auto-pluralization performed by Sequelize using the <code>freezeTableName: true</code> option. This way, Sequelize will infer the table name to be equal to the model name, without any modifications:</p><pre><code class="lang-js"><code class="source-code prettyprint">sequelize.define('User', {
  // ... (attributes)
}, {
  freezeTableName: true
});</code>
</code></pre><p>The example above will create a model named <code>User</code> pointing to a table also named <code>User</code>.</p><p>This behavior can also be defined globally for the sequelize instance, when it is created:</p><pre><code class="lang-js"><code class="source-code prettyprint">const sequelize = new Sequelize('sqlite::memory:', {
  define: {
    freezeTableName: true
  }
});</code>
</code></pre><p>This way, all tables will use the same name as the model name.</p><h3>Providing the table name directly</h3><p>You can simply tell Sequelize the name of the table directly as well:</p><pre><code class="lang-js"><code class="source-code prettyprint">sequelize.define('User', {
  // ... (attributes)
}, {
  tableName: 'Employees'
});</code>
</code></pre><h2>Model synchronization</h2><p>When you define a model, you're telling Sequelize a few things about its table in the database. However, what if the table actually doesn't even exist in the database? What if it exists, but it has different columns, less columns, or any other difference?</p><p>This is where model synchronization comes in. A model can be synchronized with the database by calling <a href="https://sequelize.org/master/class/src/model.js~Model.html#static-method-sync"><code>model.sync(options)</code></a>, an asynchronous function (that returns a Promise). With this call, Sequelize will automatically perform an SQL query to the database. Note that this changes only the table in the database, not the model in the JavaScript side.</p><ul>
<li><code>User.sync()</code> - This creates the table if it doesn't exist (and does nothing if it already exists)</li>
<li><code>User.sync({ force: true })</code> - This creates the table, dropping it first if it already existed</li>
<li><code>User.sync({ alter: true })</code> - This checks what is the current state of the table in the database (which columns it has, what are their data types, etc), and then performs the necessary changes in the table to make it match the model.</li>
</ul><p>Example:</p><pre><code class="lang-js"><code class="source-code prettyprint">await User.sync({ force: true });
console.log("The table for the User model was just (re)created!");</code>
</code></pre><h3>Synchronizing all models at once</h3><p>You can use <a href="./manual/../class/src/sequelize.js~Sequelize.html#instance-method-sync"><code>sequelize.sync()</code></a> to automatically synchronize all models. Example:</p><pre><code class="lang-js"><code class="source-code prettyprint">await sequelize.sync({ force: true });
console.log("All models were synchronized successfully.");</code>
</code></pre><h3>Dropping tables</h3><p>To drop the table related to a model:</p><pre><code class="lang-js"><code class="source-code prettyprint">await User.drop();
console.log("User table dropped!");</code>
</code></pre><p>To drop all tables:</p><pre><code class="lang-js"><code class="source-code prettyprint">await sequelize.drop();
console.log("All tables dropped!");</code>
</code></pre><h3>Database safety check</h3><p>As shown above, the <code>sync</code> and <code>drop</code> operations are destructive. Sequelize accepts a <code>match</code> option as an additional safety check, which receives a RegExp:</p><pre><code class="lang-js"><code class="source-code prettyprint">// This will run .sync() only if database name ends with '_test'
sequelize.sync({ force: true, match: /_test$/ });</code>
</code></pre><h3>Synchronization in production</h3><p>As shown above, <code>sync({ force: true })</code> and <code>sync({ alter: true })</code> can be destructive operations. Therefore, they are not recommended for production-level software. Instead, synchronization should be done with the advanced concept of <a href="./manual/migrations.html">Migrations</a>, with the help of the <a href="https://github.com/sequelize/cli">Sequelize CLI</a>.</p><h2>Timestamps</h2><p>By default, Sequelize automatically adds the fields <code>createdAt</code> and <code>updatedAt</code> to every model, using the data type <code>DataTypes.DATE</code>. Those fields are automatically managed as well - whenever you use Sequelize to create or update something, those fields will be set correctly. The <code>createdAt</code> field will contain the timestamp representing the moment of creation, and the <code>updatedAt</code> will contain the timestamp of the latest update.</p><p><strong>Note:</strong> This is done in the Sequelize level (i.e. not done with <em>SQL triggers</em>). This means that direct SQL queries (for example queries performed without Sequelize by any other means) will not cause these fields to be updated automatically.</p><p>This behavior can be disabled for a model with the <code>timestamps: false</code> option:</p><pre><code class="lang-js"><code class="source-code prettyprint">sequelize.define('User', {
  // ... (attributes)
}, {
  timestamps: false
});</code>
</code></pre><p>It is also possible to enable only one of <code>createdAt</code>/<code>updatedAt</code>, and to provide a custom name for these columns:</p><pre><code class="lang-js"><code class="source-code prettyprint">class Foo extends Model {}
Foo.init({ /* attributes */ }, {
  sequelize,

  // don't forget to enable timestamps!
  timestamps: true,

  // I don't want createdAt
  createdAt: false,

  // I want updatedAt to actually be called updateTimestamp
  updatedAt: 'updateTimestamp'
});</code>
</code></pre><h2>Column declaration shorthand syntax</h2><p>If the only thing being specified about a column is its data type, the syntax can be shortened:</p><pre><code class="lang-js"><code class="source-code prettyprint">// This:
sequelize.define('User', {
  name: {
    type: DataTypes.STRING
  }
});

// Can be simplified to:
sequelize.define('User', { name: DataTypes.STRING });</code>
</code></pre><h2>Default Values</h2><p>By default, Sequelize assumes that the default value of a column is <code>NULL</code>. This behavior can be changed by passing a specific <code>defaultValue</code> to the column definition:</p><pre><code class="lang-js"><code class="source-code prettyprint">sequelize.define('User', {
  name: {
    type: DataTypes.STRING,
    defaultValue: "John Doe"
  }
});</code>
</code></pre><p>Some special values, such as <code>DataTypes.NOW</code>, are also accepted:</p><pre><code class="lang-js"><code class="source-code prettyprint">sequelize.define('Foo', {
  bar: {
    type: DataTypes.DATETIME,
    defaultValue: DataTypes.NOW
    // This way, the current date/time will be used to populate this column (at the moment of insertion)
  }
});</code>
</code></pre><h2>Data Types</h2><p>Every column you define in your model must have a data type. Sequelize provides <a href="https://github.com/sequelize/sequelize/blob/main/src/data-types.js">a lot of built-in data types</a>. To access a built-in data type, you must import <code>DataTypes</code>:</p><pre><code class="lang-js"><code class="source-code prettyprint">const { DataTypes } = require("sequelize"); // Import the built-in data types</code>
</code></pre><h3>Strings</h3><pre><code class="lang-js"><code class="source-code prettyprint">DataTypes.STRING             // VARCHAR(255)
DataTypes.STRING(1234)       // VARCHAR(1234)
DataTypes.STRING.BINARY      // VARCHAR BINARY
DataTypes.TEXT               // TEXT
DataTypes.TEXT('tiny')       // TINYTEXT
DataTypes.CITEXT             // CITEXT          PostgreSQL and SQLite only.
DataTypes.TSVECTOR           // TSVECTOR        PostgreSQL only.</code>
</code></pre><h3>Boolean</h3><pre><code class="lang-js"><code class="source-code prettyprint">DataTypes.BOOLEAN            // TINYINT(1)</code>
</code></pre><h3>Numbers</h3><pre><code class="lang-js"><code class="source-code prettyprint">DataTypes.INTEGER            // INTEGER
DataTypes.BIGINT             // BIGINT
DataTypes.BIGINT(11)         // BIGINT(11)

DataTypes.FLOAT              // FLOAT
DataTypes.FLOAT(11)          // FLOAT(11)
DataTypes.FLOAT(11, 10)      // FLOAT(11,10)

DataTypes.REAL               // REAL            PostgreSQL only.
DataTypes.REAL(11)           // REAL(11)        PostgreSQL only.
DataTypes.REAL(11, 12)       // REAL(11,12)     PostgreSQL only.

DataTypes.DOUBLE             // DOUBLE
DataTypes.DOUBLE(11)         // DOUBLE(11)
DataTypes.DOUBLE(11, 10)     // DOUBLE(11,10)

DataTypes.DECIMAL            // DECIMAL
DataTypes.DECIMAL(10, 2)     // DECIMAL(10,2)</code>
</code></pre><h4>Unsigned &amp; Zerofill integers - MySQL/MariaDB only</h4><p>In MySQL and MariaDB, the data types <code>INTEGER</code>, <code>BIGINT</code>, <code>FLOAT</code> and <code>DOUBLE</code> can be set as unsigned or zerofill (or both), as follows:</p><pre><code class="lang-js"><code class="source-code prettyprint">DataTypes.INTEGER.UNSIGNED
DataTypes.INTEGER.ZEROFILL
DataTypes.INTEGER.UNSIGNED.ZEROFILL
// You can also specify the size i.e. INTEGER(10) instead of simply INTEGER
// Same for BIGINT, FLOAT and DOUBLE</code>
</code></pre><h3>Dates</h3><pre><code class="lang-js"><code class="source-code prettyprint">DataTypes.DATE       // DATETIME for mysql / sqlite, TIMESTAMP WITH TIME ZONE for postgres
DataTypes.DATE(6)    // DATETIME(6) for mysql 5.6.4+. Fractional seconds support with up to 6 digits of precision
DataTypes.DATEONLY   // DATE without time</code>
</code></pre><h3>UUIDs</h3><p>For UUIDs, use <code>DataTypes.UUID</code>. It becomes the <code>UUID</code> data type for PostgreSQL and SQLite, and <code>CHAR(36)</code> for MySQL. Sequelize can generate UUIDs automatically for these fields, simply use <code>DataTypes.UUIDV1</code> or <code>DataTypes.UUIDV4</code> as the default value:</p><pre><code class="lang-js"><code class="source-code prettyprint">{
  type: DataTypes.UUID,
  defaultValue: DataTypes.UUIDV4 // Or DataTypes.UUIDV1
}</code>
</code></pre><h3>Others</h3><p>There are other data types, covered in a <a href="./manual/other-data-types.html">separate guide</a>.</p><h2>Column Options</h2><p>When defining a column, apart from specifying the <code>type</code> of the column, and the <code>allowNull</code> and <code>defaultValue</code> options mentioned above, there are a lot more options that can be used. Some examples are below.</p><pre><code class="lang-js"><code class="source-code prettyprint">const { Model, DataTypes, Deferrable } = require("sequelize");

class Foo extends Model {}
Foo.init({
  // instantiating will automatically set the flag to true if not set
  flag: { type: DataTypes.BOOLEAN, allowNull: false, defaultValue: true },

  // default values for dates =&gt; current time
  myDate: { type: DataTypes.DATE, defaultValue: DataTypes.NOW },

  // setting allowNull to false will add NOT NULL to the column, which means an error will be
  // thrown from the DB when the query is executed if the column is null. If you want to check that a value
  // is not null before querying the DB, look at the validations section below.
  title: { type: DataTypes.STRING, allowNull: false },

  // Creating two objects with the same value will throw an error. The unique property can be either a
  // boolean, or a string. If you provide the same string for multiple columns, they will form a
  // composite unique key.
  uniqueOne: { type: DataTypes.STRING,  unique: 'compositeIndex' },
  uniqueTwo: { type: DataTypes.INTEGER, unique: 'compositeIndex' },

  // The unique property is simply a shorthand to create a unique constraint.
  someUnique: { type: DataTypes.STRING, unique: true },

  // Go on reading for further information about primary keys
  identifier: { type: DataTypes.STRING, primaryKey: true },

  // autoIncrement can be used to create auto_incrementing integer columns
  incrementMe: { type: DataTypes.INTEGER, autoIncrement: true },

  // You can specify a custom column name via the 'field' attribute:
  fieldWithUnderscores: { type: DataTypes.STRING, field: 'field_with_underscores' },

  // It is possible to create foreign keys:
  bar_id: {
    type: DataTypes.INTEGER,

    references: {
      // This is a reference to another model
      model: Bar,

      // This is the column name of the referenced model
      key: 'id',

      // With PostgreSQL, it is optionally possible to declare when to check the foreign key constraint, passing the Deferrable type.
      deferrable: Deferrable.INITIALLY_IMMEDIATE
      // Options:
      // - `Deferrable.INITIALLY_IMMEDIATE` - Immediately check the foreign key constraints
      // - `Deferrable.INITIALLY_DEFERRED` - Defer all foreign key constraint check to the end of a transaction
      // - `Deferrable.NOT` - Don't defer the checks at all (default) - This won't allow you to dynamically change the rule in a transaction
    }
  },

  // Comments can only be added to columns in MySQL, MariaDB, PostgreSQL and MSSQL
  commentMe: {
    type: DataTypes.INTEGER,
    comment: 'This is a column name that has a comment'
  }
}, {
  sequelize,
  modelName: 'foo',

  // Using `unique: true` in an attribute above is exactly the same as creating the index in the model's options:
  indexes: [{ unique: true, fields: ['someUnique'] }]
});</code>
</code></pre><h2>Taking advantage of Models being classes</h2><p>The Sequelize models are <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes">ES6 classes</a>. You can very easily add custom instance or class level methods.</p><pre><code class="lang-js"><code class="source-code prettyprint">class User extends Model {
  static classLevelMethod() {
    return 'foo';
  }
  instanceLevelMethod() {
    return 'bar';
  }
  getFullname() {
    return [this.firstname, this.lastname].join(' ');
  }
}
User.init({
  firstname: Sequelize.TEXT,
  lastname: Sequelize.TEXT
}, { sequelize });

console.log(User.classLevelMethod()); // 'foo'
const user = User.build({ firstname: 'Jane', lastname: 'Doe' });
console.log(user.instanceLevelMethod()); // 'bar'
console.log(user.getFullname()); // 'Jane Doe'</code>
</code></pre></div>
        <a data-ice="link" href="manual/model-basics.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Model Instances</h1><p>As you already know, a model is an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes">ES6 class</a>. An instance of the class represents one object from that model (which maps to one row of the table in the database). This way, model instances are <a href="https://en.wikipedia.org/wiki/Data_access_object">DAOs</a>.</p><p>For this guide, the following setup will be assumed:</p><pre><code class="lang-js"><code class="source-code prettyprint">const { Sequelize, Model, DataTypes } = require("sequelize");
const sequelize = new Sequelize("sqlite::memory:");

const User = sequelize.define("user", {
  name: DataTypes.TEXT,
  favoriteColor: {
    type: DataTypes.TEXT,
    defaultValue: 'green'
  },
  age: DataTypes.INTEGER,
  cash: DataTypes.INTEGER
});

(async () =&gt; {
  await sequelize.sync({ force: true });
  // Code here
})();</code>
</code></pre><h2>Creating an instance</h2><p>Although a model is a class, you should not create instances by using the <code>new</code> operator directly. Instead, the <a href="./manual/../class/src/model.js~Model.html#static-method-build"><code>build</code></a> method should be used:</p><pre><code class="lang-js"><code class="source-code prettyprint">const jane = User.build({ name: "Jane" });
console.log(jane instanceof User); // true
console.log(jane.name); // "Jane"</code>
</code></pre><p>However, the code above does not communicate with the database at all (note that it is not even asynchronous)! This is because the <a href="./manual/../class/src/model.js~Model.html#static-method-build"><code>build</code></a> method only creates an object that <em>represents</em> data that <em>can</em> be mapped to a database. In order to really save (i.e. persist) this instance in the database, the <a href="./manual/../class/src/model.js~Model.html#instance-method-save"><code>save</code></a> method should be used:</p><pre><code class="lang-js"><code class="source-code prettyprint">await jane.save();
console.log('Jane was saved to the database!');</code>
</code></pre><p>Note, from the usage of <code>await</code> in the snippet above, that <code>save</code> is an asynchronous method. In fact, almost every Sequelize method is asynchronous; <code>build</code> is one of the very few exceptions.</p><h3>A very useful shortcut: the <code>create</code> method</h3><p>Sequelize provides the <a href="./manual/../class/src/model.js~Model.html#static-method-create"><code>create</code></a> method, which combines the <code>build</code> and <code>save</code> methods shown above into a single method:</p><pre><code class="lang-js"><code class="source-code prettyprint">const jane = await User.create({ name: "Jane" });
// Jane exists in the database now!
console.log(jane instanceof User); // true
console.log(jane.name); // "Jane"</code>
</code></pre><h2>Note: logging instances</h2><p>Trying to log a model instance directly to <code>console.log</code> will produce a lot of clutter, since Sequelize instances have a lot of things attached to them. Instead, you can use the <code>.toJSON()</code> method (which, by the way, automatically guarantees the instances to be <code>JSON.stringify</code>-ed well).</p><pre><code class="lang-js"><code class="source-code prettyprint">const jane = await User.create({ name: "Jane" });
// console.log(jane); // Don't do this
console.log(jane.toJSON()); // This is good!
console.log(JSON.stringify(jane, null, 4)); // This is also good!</code>
</code></pre><h2>Default values</h2><p>Built instances will automatically get default values:</p><pre><code class="lang-js"><code class="source-code prettyprint">const jane = User.build({ name: "Jane" });
console.log(jane.favoriteColor); // "green"</code>
</code></pre><h2>Updating an instance</h2><p>If you change the value of some field of an instance, calling <code>save</code> again will update it accordingly:</p><pre><code class="lang-js"><code class="source-code prettyprint">const jane = await User.create({ name: "Jane" });
console.log(jane.name); // "Jane"
jane.name = "Ada";
// the name is still "Jane" in the database
await jane.save();
// Now the name was updated to "Ada" in the database!</code>
</code></pre><p>You can update several fields at once with the <a href="./manual/../class/src/model.js~Model.html#instance-method-set"><code>set</code></a> method:</p><pre><code class="lang-js"><code class="source-code prettyprint">const jane = await User.create({ name: "Jane" });

jane.set({
  name: "Ada",
  favoriteColor: "blue"
});
// As above, the database still has "Jane" and "green"
await jane.save();
// The database now has "Ada" and "blue" for name and favorite color</code>
</code></pre><p>Note that the <code>save()</code> here will also persist any other changes that have been made on this instance, not just those in the previous <code>set</code> call. If you want to update a specific set of fields, you can use <a href="./manual/../class/src/model.js~Model.html#instance-method-update"><code>update</code></a>:</p><pre><code class="lang-js"><code class="source-code prettyprint">const jane = await User.create({ name: "Jane" });
jane.favoriteColor = "blue"
await jane.update({ name: "Ada" })
// The database now has "Ada" for name, but still has the default "green" for favorite color
await jane.save()
// Now the database has "Ada" for name and "blue" for favorite color</code>
</code></pre><h2>Deleting an instance</h2><p>You can delete an instance by calling <a href="./manual/../class/src/model.js~Model.html#instance-method-destroy"><code>destroy</code></a>:</p><pre><code class="lang-js"><code class="source-code prettyprint">const jane = await User.create({ name: "Jane" });
console.log(jane.name); // "Jane"
await jane.destroy();
// Now this entry was removed from the database</code>
</code></pre><h2>Reloading an instance</h2><p>You can reload an instance from the database by calling <a href="./manual/../class/src/model.js~Model.html#instance-method-reload"><code>reload</code></a>:</p><pre><code class="lang-js"><code class="source-code prettyprint">const jane = await User.create({ name: "Jane" });
console.log(jane.name); // "Jane"
jane.name = "Ada";
// the name is still "Jane" in the database
await jane.reload();
console.log(jane.name); // "Jane"</code>
</code></pre><p>The reload call generates a <code>SELECT</code> query to get the up-to-date data from the database.</p><h2>Saving only some fields</h2><p>It is possible to define which attributes should be saved when calling <code>save</code>, by passing an array of column names.</p><p>This is useful when you set attributes based on a previously defined object, for example, when you get the values of an object via a form of a web app. Furthermore, this is used internally in the <code>update</code> implementation. This is how it looks like:</p><pre><code class="lang-js"><code class="source-code prettyprint">const jane = await User.create({ name: "Jane" });
console.log(jane.name); // "Jane"
console.log(jane.favoriteColor); // "green"
jane.name = "Jane II";
jane.favoriteColor = "blue";
await jane.save({ fields: ['name'] });
console.log(jane.name); // "Jane II"
console.log(jane.favoriteColor); // "blue"
// The above printed blue because the local object has it set to blue, but
// in the database it is still "green":
await jane.reload();
console.log(jane.name); // "Jane II"
console.log(jane.favoriteColor); // "green"</code>
</code></pre><h2>Change-awareness of save</h2><p>The <code>save</code> method is optimized internally to only update fields that really changed. This means that if you don't change anything and call <code>save</code>, Sequelize will know that the save is superfluous and do nothing, i.e., no query will be generated (it will still return a Promise, but it will resolve immediately).</p><p>Also, if only a few attributes have changed when you call <code>save</code>, only those fields will be sent in the <code>UPDATE</code> query, to improve performance.</p><h2>Incrementing and decrementing integer values</h2><p>In order to increment/decrement values of an instance without running into concurrency issues, Sequelize provides the <a href="./manual/../class/src/model.js~Model.html#instance-method-increment"><code>increment</code></a> and <a href="./manual/../class/src/model.js~Model.html#instance-method-decrement"><code>decrement</code></a> instance methods.</p><pre><code class="lang-js"><code class="source-code prettyprint">const jane = await User.create({ name: "Jane", age: 100 });
const incrementResult = await jane.increment('age', { by: 2 });
// Note: to increment by 1 you can omit the `by` option and just do `user.increment('age')`

// In PostgreSQL, `incrementResult` will be the updated user, unless the option
// `{ returning: false }` was set (and then it will be undefined).

// In other dialects, `incrementResult` will be undefined. If you need the updated instance, you will have to call `user.reload()`.</code>
</code></pre><p>You can also increment multiple fields at once:</p><pre><code class="lang-js"><code class="source-code prettyprint">const jane = await User.create({ name: "Jane", age: 100, cash: 5000 });
await jane.increment({
  'age': 2,
  'cash': 100
});

// If the values are incremented by the same amount, you can use this other syntax as well:
await jane.increment(['age', 'cash'], { by: 2 });</code>
</code></pre><p>Decrementing works in the exact same way.</p></div>
        <a data-ice="link" href="manual/model-instances.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Model Querying - Basics</h1><p>Sequelize provides various methods to assist querying your database for data.</p><p><em>Important notice: to perform production-ready queries with Sequelize, make sure you have read the <a href="./manual/transactions.html">Transactions guide</a> as well. Transactions are important to ensure data integrity and to provide other benefits.</em></p><p>This guide will show how to make the standard <a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete">CRUD</a> queries.</p><h2>Simple INSERT queries</h2><p>First, a simple example:</p><pre><code class="lang-js"><code class="source-code prettyprint">// Create a new user
const jane = await User.create({ firstName: "Jane", lastName: "Doe" });
console.log("Jane's auto-generated ID:", jane.id);</code>
</code></pre><p>The <a href="./manual/../class/src/model.js~Model.html#static-method-create"><code>Model.create()</code></a> method is a shorthand for building an unsaved instance with <a href="./manual/../class/src/model.js~Model.html#static-method-build"><code>Model.build()</code></a> and saving the instance with <a href="./manual/../class/src/model.js~Model.html#instance-method-save"><code>instance.save()</code></a>.</p><p>It is also possible to define which attributes can be set in the <code>create</code> method. This can be especially useful if you create database entries based on a form which can be filled by a user. Using that would, for example, allow you to restrict the <code>User</code> model to set only an username but not an admin flag (i.e., <code>isAdmin</code>):</p><pre><code class="lang-js"><code class="source-code prettyprint">const user = await User.create({
  username: 'alice123',
  isAdmin: true
}, { fields: ['username'] });
// let's assume the default of isAdmin is false
console.log(user.username); // 'alice123'
console.log(user.isAdmin); // false</code>
</code></pre><h2>Simple SELECT queries</h2><p>You can read the whole table from the database with the <a href="./manual/../class/src/model.js~Model.html#static-method-findAll"><code>findAll</code></a> method:</p><pre><code class="lang-js"><code class="source-code prettyprint">// Find all users
const users = await User.findAll();
console.log(users.every(user =&gt; user instanceof User)); // true
console.log("All users:", JSON.stringify(users, null, 2));</code>
</code></pre><pre><code class="lang-sql"><code class="source-code prettyprint">SELECT * FROM ...</code>
</code></pre><h2>Specifying attributes for SELECT queries</h2><p>To select only some attributes, you can use the <code>attributes</code> option:</p><pre><code class="lang-js"><code class="source-code prettyprint">Model.findAll({
  attributes: ['foo', 'bar']
});</code>
</code></pre><pre><code class="lang-sql"><code class="source-code prettyprint">SELECT foo, bar FROM ...</code>
</code></pre><p>Attributes can be renamed using a nested array:</p><pre><code class="lang-js"><code class="source-code prettyprint">Model.findAll({
  attributes: ['foo', ['bar', 'baz'], 'qux']
});</code>
</code></pre><pre><code class="lang-sql"><code class="source-code prettyprint">SELECT foo, bar AS baz, qux FROM ...</code>
</code></pre><p>You can use <a href="./manual/../class/src/sequelize.js~Sequelize.html#static-method-fn"><code>sequelize.fn</code></a> to do aggregations:</p><pre><code class="lang-js"><code class="source-code prettyprint">Model.findAll({
  attributes: [
    'foo',
    [sequelize.fn('COUNT', sequelize.col('hats')), 'n_hats'],
    'bar'
  ]
});</code>
</code></pre><pre><code class="lang-sql"><code class="source-code prettyprint">SELECT foo, COUNT(hats) AS n_hats, bar FROM ...</code>
</code></pre><p>When using aggregation function, you must give it an alias to be able to access it from the model. In the example above you can get the number of hats with <code>instance.n_hats</code>.</p><p>Sometimes it may be tiresome to list all the attributes of the model if you only want to add an aggregation:</p><pre><code class="lang-js"><code class="source-code prettyprint">// This is a tiresome way of getting the number of hats (along with every column)
Model.findAll({
  attributes: [
    'id', 'foo', 'bar', 'baz', 'qux', 'hats', // We had to list all attributes...
    [sequelize.fn('COUNT', sequelize.col('hats')), 'n_hats'] // To add the aggregation...
  ]
});

// This is shorter, and less error prone because it still works if you add / remove attributes from your model later
Model.findAll({
  attributes: {
    include: [
      [sequelize.fn('COUNT', sequelize.col('hats')), 'n_hats']
    ]
  }
});</code>
</code></pre><pre><code class="lang-sql"><code class="source-code prettyprint">SELECT id, foo, bar, baz, qux, hats, COUNT(hats) AS n_hats FROM ...</code>
</code></pre><p>Similarly, it's also possible to remove a selected few attributes:</p><pre><code class="lang-js"><code class="source-code prettyprint">Model.findAll({
  attributes: { exclude: ['baz'] }
});</code>
</code></pre><pre><code class="lang-sql"><code class="source-code prettyprint">-- Assuming all columns are 'id', 'foo', 'bar', 'baz' and 'qux'
SELECT id, foo, bar, qux FROM ...</code>
</code></pre><h2>Applying WHERE clauses</h2><p>The <code>where</code> option is used to filter the query. There are lots of operators to use for the <code>where</code> clause, available as Symbols from <a href="./manual/../variable/index.html#static-variable-Op"><code>Op</code></a>.</p><h3>The basics</h3><pre><code class="lang-js"><code class="source-code prettyprint">Post.findAll({
  where: {
    authorId: 2
  }
});
// SELECT * FROM post WHERE authorId = 2;</code>
</code></pre><p>Observe that no operator (from <code>Op</code>) was explicitly passed, so Sequelize assumed an equality comparison by default. The above code is equivalent to:</p><pre><code class="lang-js"><code class="source-code prettyprint">const { Op } = require("sequelize");
Post.findAll({
  where: {
    authorId: {
      [Op.eq]: 2
    }
  }
});
// SELECT * FROM post WHERE authorId = 2;</code>
</code></pre><p>Multiple checks can be passed:</p><pre><code class="lang-js"><code class="source-code prettyprint">Post.findAll({
  where: {
    authorId: 12,
    status: 'active'
  }
});
// SELECT * FROM post WHERE authorId = 12 AND status = 'active';</code>
</code></pre><p>Just like Sequelize inferred the <code>Op.eq</code> operator in the first example, here Sequelize inferred that the caller wanted an <code>AND</code> for the two checks. The code above is equivalent to:</p><pre><code class="lang-js"><code class="source-code prettyprint">const { Op } = require("sequelize");
Post.findAll({
  where: {
    [Op.and]: [
      { authorId: 12 },
      { status: 'active' }
    ]
  }
});
// SELECT * FROM post WHERE authorId = 12 AND status = 'active';</code>
</code></pre><p>An <code>OR</code> can be easily performed in a similar way:</p><pre><code class="lang-js"><code class="source-code prettyprint">const { Op } = require("sequelize");
Post.findAll({
  where: {
    [Op.or]: [
      { authorId: 12 },
      { authorId: 13 }
    ]
  }
});
// SELECT * FROM post WHERE authorId = 12 OR authorId = 13;</code>
</code></pre><p>Since the above was an <code>OR</code> involving the same field, Sequelize allows you to use a slightly different structure which is more readable and generates the same behavior:</p><pre><code class="lang-js"><code class="source-code prettyprint">const { Op } = require("sequelize");
Post.destroy({
  where: {
    authorId: {
      [Op.or]: [12, 13]
    }
  }
});
// DELETE FROM post WHERE authorId = 12 OR authorId = 13;</code>
</code></pre><h3>Operators</h3><p>Sequelize provides several operators.</p><pre><code class="lang-js"><code class="source-code prettyprint">const { Op } = require("sequelize");
Post.findAll({
  where: {
    [Op.and]: [{ a: 5 }, { b: 6 }],            // (a = 5) AND (b = 6)
    [Op.or]: [{ a: 5 }, { b: 6 }],             // (a = 5) OR (b = 6)
    someAttribute: {
      // Basics
      [Op.eq]: 3,                              // = 3
      [Op.ne]: 20,                             // != 20
      [Op.is]: null,                           // IS NULL
      [Op.not]: true,                          // IS NOT TRUE
      [Op.or]: [5, 6],                         // (someAttribute = 5) OR (someAttribute = 6)

      // Using dialect specific column identifiers (PG in the following example):
      [Op.col]: 'user.organization_id',        // = "user"."organization_id"

      // Number comparisons
      [Op.gt]: 6,                              // &gt; 6
      [Op.gte]: 6,                             // &gt;= 6
      [Op.lt]: 10,                             // &lt; 10
      [Op.lte]: 10,                            // &lt;= 10
      [Op.between]: [6, 10],                   // BETWEEN 6 AND 10
      [Op.notBetween]: [11, 15],               // NOT BETWEEN 11 AND 15

      // Other operators

      [Op.all]: sequelize.literal('SELECT 1'), // &gt; ALL (SELECT 1)

      [Op.in]: [1, 2],                         // IN [1, 2]
      [Op.notIn]: [1, 2],                      // NOT IN [1, 2]

      [Op.like]: '%hat',                       // LIKE '%hat'
      [Op.notLike]: '%hat',                    // NOT LIKE '%hat'
      [Op.startsWith]: 'hat',                  // LIKE 'hat%'
      [Op.endsWith]: 'hat',                    // LIKE '%hat'
      [Op.substring]: 'hat',                   // LIKE '%hat%'
      [Op.iLike]: '%hat',                      // ILIKE '%hat' (case insensitive) (PG only)
      [Op.notILike]: '%hat',                   // NOT ILIKE '%hat'  (PG only)
      [Op.regexp]: '^[h|a|t]',                 // REGEXP/~ '^[h|a|t]' (MySQL/PG only)
      [Op.notRegexp]: '^[h|a|t]',              // NOT REGEXP/!~ '^[h|a|t]' (MySQL/PG only)
      [Op.iRegexp]: '^[h|a|t]',                // ~* '^[h|a|t]' (PG only)
      [Op.notIRegexp]: '^[h|a|t]',             // !~* '^[h|a|t]' (PG only)

      [Op.any]: [2, 3],                        // ANY ARRAY[2, 3]::INTEGER (PG only)
      [Op.match]: Sequelize.fn('to_tsquery', 'fat &amp; rat') // match text search for strings 'fat' and 'rat' (PG only)

      // In Postgres, Op.like/Op.iLike/Op.notLike can be combined to Op.any:
      [Op.like]: { [Op.any]: ['cat', 'hat'] }  // LIKE ANY ARRAY['cat', 'hat']

      // There are more postgres-only range operators, see below
    }
  }
});</code>
</code></pre><h4>Shorthand syntax for <code>Op.in</code></h4><p>Passing an array directly to the <code>where</code> option will implicitly use the <code>IN</code> operator:</p><pre><code class="lang-js"><code class="source-code prettyprint">Post.findAll({
  where: {
    id: [1,2,3] // Same as using `id: { [Op.in]: [1,2,3] }`
  }
});
// SELECT ... FROM "posts" AS "post" WHERE "post"."id" IN (1, 2, 3);</code>
</code></pre><h3>Logical combinations with operators</h3><p>The operators <code>Op.and</code>, <code>Op.or</code> and <code>Op.not</code> can be used to create arbitrarily complex nested logical comparisons.</p><h4>Examples with <code>Op.and</code> and <code>Op.or</code></h4><pre><code class="lang-js"><code class="source-code prettyprint">const { Op } = require("sequelize");

Foo.findAll({
  where: {
    rank: {
      [Op.or]: {
        [Op.lt]: 1000,
        [Op.eq]: null
      }
    },
    // rank &lt; 1000 OR rank IS NULL

    {
      createdAt: {
        [Op.lt]: new Date(),
        [Op.gt]: new Date(new Date() - 24 * 60 * 60 * 1000)
      }
    },
    // createdAt &lt; [timestamp] AND createdAt &gt; [timestamp]

    {
      [Op.or]: [
        {
          title: {
            [Op.like]: 'Boat%'
          }
        },
        {
          description: {
            [Op.like]: '%boat%'
          }
        }
      ]
    }
    // title LIKE 'Boat%' OR description LIKE '%boat%'
  }
});</code>
</code></pre><h4>Examples with <code>Op.not</code></h4><pre><code class="lang-js"><code class="source-code prettyprint">Project.findAll({
  where: {
    name: 'Some Project',
    [Op.not]: [
      { id: [1,2,3] },
      {
        description: {
          [Op.like]: 'Hello%'
        }
      }
    ]
  }
});</code>
</code></pre><p>The above will generate:</p><pre><code class="lang-sql"><code class="source-code prettyprint">SELECT *
FROM `Projects`
WHERE (
  `Projects`.`name` = 'Some Project'
  AND NOT (
    `Projects`.`id` IN (1,2,3)
    AND
    `Projects`.`description` LIKE 'Hello%'
  )
)</code>
</code></pre><h3>Advanced queries with functions (not just columns)</h3><p>What if you wanted to obtain something like <code>WHERE char_length("content") = 7</code>?</p><pre><code class="lang-js"><code class="source-code prettyprint">Post.findAll({
  where: sequelize.where(sequelize.fn('char_length', sequelize.col('content')), 7)
});
// SELECT ... FROM "posts" AS "post" WHERE char_length("content") = 7</code>
</code></pre><p>Note the usage of the  <a href="./manual/../class/src/sequelize.js~Sequelize.html#static-method-fn"><code>sequelize.fn</code></a> and <a href="./manual/../class/src/sequelize.js~Sequelize.html#static-method-col"><code>sequelize.col</code></a> methods, which should be used to specify an SQL function call and a table column, respectively. These methods should be used instead of passing a plain string (such as <code>char_length(content)</code>) because Sequelize needs to treat this situation differently (for example, using other symbol escaping approaches).</p><p>What if you need something even more complex?</p><pre><code class="lang-js"><code class="source-code prettyprint">Post.findAll({
  where: {
    [Op.or]: [
      sequelize.where(sequelize.fn('char_length', sequelize.col('content')), 7),
      {
        content: {
          [Op.like]: 'Hello%'
        }
      },
      {
        [Op.and]: [
          { status: 'draft' },
          sequelize.where(sequelize.fn('char_length', sequelize.col('content')), {
            [Op.gt]: 10
          })
        ]
      }
    ]
  }
});</code>
</code></pre><p>The above generates the following SQL:</p><pre><code class="lang-sql"><code class="source-code prettyprint">SELECT
  ...
FROM "posts" AS "post"
WHERE (
  char_length("content") = 7
  OR
  "post"."content" LIKE 'Hello%'
  OR (
    "post"."status" = 'draft'
    AND
    char_length("content") &gt; 10
  )
)</code>
</code></pre><h3>Postgres-only Range Operators</h3><p>Range types can be queried with all supported operators.</p><p>Keep in mind, the provided range value can <a href="./manual/data-types.html#range-types">define the bound inclusion/exclusion</a> as well.</p><pre><code class="lang-js"><code class="source-code prettyprint">[Op.contains]: 2,            // @&gt; '2'::integer  (PG range contains element operator)
[Op.contains]: [1, 2],       // @&gt; [1, 2)        (PG range contains range operator)
[Op.contained]: [1, 2],      // &lt;@ [1, 2)        (PG range is contained by operator)
[Op.overlap]: [1, 2],        // &amp;&amp; [1, 2)        (PG range overlap (have points in common) operator)
[Op.adjacent]: [1, 2],       // -|- [1, 2)       (PG range is adjacent to operator)
[Op.strictLeft]: [1, 2],     // &lt;&lt; [1, 2)        (PG range strictly left of operator)
[Op.strictRight]: [1, 2],    // &gt;&gt; [1, 2)        (PG range strictly right of operator)
[Op.noExtendRight]: [1, 2],  // &amp;&lt; [1, 2)        (PG range does not extend to the right of operator)
[Op.noExtendLeft]: [1, 2],   // &amp;&gt; [1, 2)        (PG range does not extend to the left of operator)</code>
</code></pre><h3>Deprecated: Operator Aliases</h3><p>In Sequelize v4, it was possible to specify strings to refer to operators, instead of using Symbols. This is now deprecated and heavily discouraged, and will probably be removed in the next major version. If you really need it, you can pass the <code>operatorAliases</code> option in the Sequelize constructor.</p><p>For example:</p><pre><code class="lang-js"><code class="source-code prettyprint">const { Sequelize, Op } = require("sequelize");
const sequelize = new Sequelize('sqlite::memory:', {
  operatorsAliases: {
    $gt: Op.gt
  }
});

// Now we can use `$gt` instead of `[Op.gt]` in where clauses:
Foo.findAll({
  where: {
    $gt: 6 // Works like using [Op.gt]
  }
});</code>
</code></pre><h2>Simple UPDATE queries</h2><p>Update queries also accept the <code>where</code> option, just like the read queries shown above.</p><pre><code class="lang-js"><code class="source-code prettyprint">// Change everyone without a last name to "Doe"
await User.update({ lastName: "Doe" }, {
  where: {
    lastName: null
  }
});</code>
</code></pre><h2>Simple DELETE queries</h2><p>Delete queries also accept the <code>where</code> option, just like the read queries shown above.</p><pre><code class="lang-js"><code class="source-code prettyprint">// Delete everyone named "Jane"
await User.destroy({
  where: {
    firstName: "Jane"
  }
});</code>
</code></pre><p>To destroy everything the <code>TRUNCATE</code> SQL can be used:</p><pre><code class="lang-js"><code class="source-code prettyprint">// Truncate the table
await User.destroy({
  truncate: true
});</code>
</code></pre><h2>Creating in bulk</h2><p>Sequelize provides the <code>Model.bulkCreate</code> method to allow creating multiple records at once, with only one query.</p><p>The usage of <code>Model.bulkCreate</code> is very similar to <code>Model.create</code>, by receiving an array of objects instead of a single object.</p><pre><code class="lang-js"><code class="source-code prettyprint">const captains = await Captain.bulkCreate([
  { name: 'Jack Sparrow' },
  { name: 'Davy Jones' }
]);
console.log(captains.length); // 2
console.log(captains[0] instanceof Captain); // true
console.log(captains[0].name); // 'Jack Sparrow'
console.log(captains[0].id); // 1 // (or another auto-generated value)</code>
</code></pre><p>However, by default, <code>bulkCreate</code> does not run validations on each object that is going to be created (which <code>create</code> does). To make <code>bulkCreate</code> run these validations as well, you must pass the <code>validate: true</code> option. This will decrease performance. Usage example:</p><pre><code class="lang-js"><code class="source-code prettyprint">const Foo = sequelize.define('foo', {
  bar: {
    type: DataTypes.TEXT,
    validate: {
      len: [4, 6]
    }
  }
});

// This will not throw an error, both instances will be created
await Foo.bulkCreate([
  { name: 'abc123' },
  { name: 'name too long' }
]);

// This will throw an error, nothing will be created
await Foo.bulkCreate([
  { name: 'abc123' },
  { name: 'name too long' }
], { validate: true });</code>
</code></pre><p>If you are accepting values directly from the user, it might be beneficial to limit the columns that you want to actually insert. To support this, <code>bulkCreate()</code> accepts a <code>fields</code> option, an array defining which fields must be considered (the rest will be ignored).</p><pre><code class="lang-js"><code class="source-code prettyprint">await User.bulkCreate([
  { username: 'foo' },
  { username: 'bar', admin: true }
], { fields: ['username'] });
// Neither foo nor bar are admins.</code>
</code></pre><h2>Ordering and Grouping</h2><p>Sequelize provides the <code>order</code> and <code>group</code> options to work with <code>ORDER BY</code> and <code>GROUP BY</code>.</p><h3>Ordering</h3><p>The <code>order</code> option takes an array of items to order the query by or a sequelize method. These <em>items</em> are themselves arrays in the form <code>[column, direction]</code>. The column will be escaped correctly and the direction will be checked in a whitelist of valid directions (such as <code>ASC</code>, <code>DESC</code>, <code>NULLS FIRST</code>, etc).</p><pre><code class="lang-js"><code class="source-code prettyprint">Subtask.findAll({
  order: [
    // Will escape title and validate DESC against a list of valid direction parameters
    ['title', 'DESC'],

    // Will order by max(age)
    sequelize.fn('max', sequelize.col('age')),

    // Will order by max(age) DESC
    [sequelize.fn('max', sequelize.col('age')), 'DESC'],

    // Will order by  otherfunction(`col1`, 12, 'lalala') DESC
    [sequelize.fn('otherfunction', sequelize.col('col1'), 12, 'lalala'), 'DESC'],

    // Will order an associated model's createdAt using the model name as the association's name.
    [Task, 'createdAt', 'DESC'],

    // Will order through an associated model's createdAt using the model names as the associations' names.
    [Task, Project, 'createdAt', 'DESC'],

    // Will order by an associated model's createdAt using the name of the association.
    ['Task', 'createdAt', 'DESC'],

    // Will order by a nested associated model's createdAt using the names of the associations.
    ['Task', 'Project', 'createdAt', 'DESC'],

    // Will order by an associated model's createdAt using an association object. (preferred method)
    [Subtask.associations.Task, 'createdAt', 'DESC'],

    // Will order by a nested associated model's createdAt using association objects. (preferred method)
    [Subtask.associations.Task, Task.associations.Project, 'createdAt', 'DESC'],

    // Will order by an associated model's createdAt using a simple association object.
    [{model: Task, as: 'Task'}, 'createdAt', 'DESC'],

    // Will order by a nested associated model's createdAt simple association objects.
    [{model: Task, as: 'Task'}, {model: Project, as: 'Project'}, 'createdAt', 'DESC']
  ],

  // Will order by max age descending
  order: sequelize.literal('max(age) DESC'),

  // Will order by max age ascending assuming ascending is the default order when direction is omitted
  order: sequelize.fn('max', sequelize.col('age')),

  // Will order by age ascending assuming ascending is the default order when direction is omitted
  order: sequelize.col('age'),

  // Will order randomly based on the dialect (instead of fn('RAND') or fn('RANDOM'))
  order: sequelize.random()
});

Foo.findOne({
  order: [
    // will return `name`
    ['name'],
    // will return `username` DESC
    ['username', 'DESC'],
    // will return max(`age`)
    sequelize.fn('max', sequelize.col('age')),
    // will return max(`age`) DESC
    [sequelize.fn('max', sequelize.col('age')), 'DESC'],
    // will return otherfunction(`col1`, 12, 'lalala') DESC
    [sequelize.fn('otherfunction', sequelize.col('col1'), 12, 'lalala'), 'DESC'],
    // will return otherfunction(awesomefunction(`col`)) DESC, This nesting is potentially infinite!
    [sequelize.fn('otherfunction', sequelize.fn('awesomefunction', sequelize.col('col'))), 'DESC']
  ]
});</code>
</code></pre><p>To recap, the elements of the order array can be the following:</p><ul>
<li>A string (which will be automatically quoted)</li>
<li>An array, whose first element will be quoted, second will be appended verbatim</li>
<li>An object with a <code>raw</code> field:<ul>
<li>The content of <code>raw</code> will be added verbatim without quoting</li>
<li>Everything else is ignored, and if raw is not set, the query will fail</li>
</ul>
</li>
<li>A call to <code>Sequelize.fn</code> (which will generate a function call in SQL)</li>
<li>A call to <code>Sequelize.col</code> (which will quoute the column name)</li>
</ul><h3>Grouping</h3><p>The syntax for grouping and ordering are equal, except that grouping does not accept a direction as last argument of the array (there is no <code>ASC</code>, <code>DESC</code>, <code>NULLS FIRST</code>, etc).</p><p>You can also pass a string directly to <code>group</code>, which will be included directly (verbatim) into the generated SQL. Use with caution and don't use with user generated content.</p><pre><code class="lang-js"><code class="source-code prettyprint">Project.findAll({ group: 'name' });
// yields 'GROUP BY name'</code>
</code></pre><h2>Limits and Pagination</h2><p>The <code>limit</code> and <code>offset</code> options allow you to work with limiting / pagination:</p><pre><code class="lang-js"><code class="source-code prettyprint">// Fetch 10 instances/rows
Project.findAll({ limit: 10 });

// Skip 8 instances/rows
Project.findAll({ offset: 8 });

// Skip 5 instances and fetch the 5 after that
Project.findAll({ offset: 5, limit: 5 });</code>
</code></pre><p>Usually these are used alongside the <code>order</code> option.</p><h2>Utility methods</h2><p>Sequelize also provides a few utility methods.</p><h3><code>count</code></h3><p>The <code>count</code> method simply counts the occurrences of elements in the database.</p><pre><code class="lang-js"><code class="source-code prettyprint">console.log(`There are ${await Project.count()} projects`);

const amount = await Project.count({
  where: {
    id: {
      [Op.gt]: 25
    }
  }
});
console.log(`There are ${amount} projects with an id greater than 25`);</code>
</code></pre><h3><code>max</code>, <code>min</code> and <code>sum</code></h3><p>Sequelize also provides the <code>max</code>, <code>min</code> and <code>sum</code> convenience methods.</p><p>Let's assume we have three users, whose ages are 10, 5, and 40.</p><pre><code class="lang-js"><code class="source-code prettyprint">await User.max('age'); // 40
await User.max('age', { where: { age: { [Op.lt]: 20 } } }); // 10
await User.min('age'); // 5
await User.min('age', { where: { age: { [Op.gt]: 5 } } }); // 10
await User.sum('age'); // 55
await User.sum('age', { where: { age: { [Op.gt]: 5 } } }); // 50</code>
</code></pre><h3><code>increment</code>, <code>decrement</code></h3><p>Sequelize also provides the <code>increment</code> convenience method.</p><p>Let's assume we have a user, whose age is 10.</p><pre><code class="lang-js"><code class="source-code prettyprint">await User.increment({age: 5}, { where: { id: 1 } }) // Will increase age to 15
await User.increment({age: -5}, { where: { id: 1 } }) // Will decrease age to 5</code>
</code></pre></div>
        <a data-ice="link" href="manual/model-querying-basics.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Model Querying - Finders</h1><p>Finder methods are the ones that generate <code>SELECT</code> queries.</p><p>By default, the results of all finder methods are instances of the model class (as opposed to being just plain JavaScript objects). This means that after the database returns the results, Sequelize automatically wraps everything in proper instance objects. In a few cases, when there are too many results, this wrapping can be inefficient. To disable this wrapping and receive a plain response instead, pass <code>{ raw: true }</code> as an option to the finder method.</p><h2><code>findAll</code></h2><p>The <code>findAll</code> method is already known from the previous tutorial. It generates a standard <code>SELECT</code> query which will retrieve all entries from the table (unless restricted by something like a <code>where</code> clause, for example).</p><h2><code>findByPk</code></h2><p>The <code>findByPk</code> method obtains only a single entry from the table, using the provided primary key.</p><pre><code class="lang-js"><code class="source-code prettyprint">const project = await Project.findByPk(123);
if (project === null) {
  console.log('Not found!');
} else {
  console.log(project instanceof Project); // true
  // Its primary key is 123
}</code>
</code></pre><h2><code>findOne</code></h2><p>The <code>findOne</code> method obtains the first entry it finds (that fulfills the optional query options, if provided).</p><pre><code class="lang-js"><code class="source-code prettyprint">const project = await Project.findOne({ where: { title: 'My Title' } });
if (project === null) {
  console.log('Not found!');
} else {
  console.log(project instanceof Project); // true
  console.log(project.title); // 'My Title'
}</code>
</code></pre><h2><code>findOrCreate</code></h2><p>The method <code>findOrCreate</code> will create an entry in the table unless it can find one fulfilling the query options. In both cases, it will return an instance (either the found instance or the created instance) and a boolean indicating whether that instance was created or already existed.</p><p>The <code>where</code> option is considered for finding the entry, and the <code>defaults</code> option is used to define what must be created in case nothing was found. If the <code>defaults</code> do not contain values for every column, Sequelize will take the values given to <code>where</code> (if present).</p><p>Let's assume we have an empty database with a <code>User</code> model which has a <code>username</code> and a <code>job</code>.</p><pre><code class="lang-js"><code class="source-code prettyprint">const [user, created] = await User.findOrCreate({
  where: { username: 'sdepold' },
  defaults: {
    job: 'Technical Lead JavaScript'
  }
});
console.log(user.username); // 'sdepold'
console.log(user.job); // This may or may not be 'Technical Lead JavaScript'
console.log(created); // The boolean indicating whether this instance was just created
if (created) {
  console.log(user.job); // This will certainly be 'Technical Lead JavaScript'
}</code>
</code></pre><h2><code>findAndCountAll</code></h2><p>The <code>findAndCountAll</code> method is a convenience method that combines <code>findAll</code> and <code>count</code>. This is useful when dealing with queries related to pagination where you want to retrieve data with a <code>limit</code> and <code>offset</code> but also need to know the total number of records that match the query.</p><p>When <code>group</code> is not provided, the <code>findAndCountAll</code> method returns an object with two properties:</p><ul>
<li><code>count</code> - an integer - the total number records matching the query</li>
<li><code>rows</code> - an array of objects - the obtained records</li>
</ul><p>When <code>group</code> is provided, the <code>findAndCountAll</code> method returns an object with two properties:</p><ul>
<li><code>count</code> - an array of objects - contains the count in each group and the projected attributes</li>
<li><code>rows</code> - an array of objects - the obtained records</li>
</ul><pre><code class="lang-js"><code class="source-code prettyprint">const { count, rows } = await Project.findAndCountAll({
  where: {
    title: {
      [Op.like]: 'foo%'
    }
  },
  offset: 10,
  limit: 2
});
console.log(count);
console.log(rows);</code>
</code></pre></div>
        <a data-ice="link" href="manual/model-querying-finders.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Getters, Setters &amp; Virtuals</h1><p>Sequelize allows you to define custom getters and setters for the attributes of your models.</p><p>Sequelize also allows you to specify the so-called <em>virtual attributes</em>, which are attributes on the Sequelize Model that doesn't really exist in the underlying SQL table, but instead are populated automatically by Sequelize. They are very useful to create custom attributes which also could simplify your code, for example.</p><h2>Getters</h2><p>A getter is a <code>get()</code> function defined for one column in the model definition:</p><pre><code class="lang-js"><code class="source-code prettyprint">const User = sequelize.define('user', {
  // Let's say we wanted to see every username in uppercase, even
  // though they are not necessarily uppercase in the database itself
  username: {
    type: DataTypes.STRING,
    get() {
      const rawValue = this.getDataValue('username');
      return rawValue ? rawValue.toUpperCase() : null;
    }
  }
});</code>
</code></pre><p>This getter, just like a standard JavaScript getter, is called automatically when the field value is read:</p><pre><code class="lang-js"><code class="source-code prettyprint">const user = User.build({ username: 'SuperUser123' });
console.log(user.username); // 'SUPERUSER123'
console.log(user.getDataValue('username')); // 'SuperUser123'</code>
</code></pre><p>Note that, although <code>SUPERUSER123</code> was logged above, the value truly stored in the database is still <code>SuperUser123</code>. We used <code>this.getDataValue('username')</code> to obtain this value, and converted it to uppercase.</p><p>Had we tried to use <code>this.username</code> in the getter instead, we would have gotten an infinite loop! This is why Sequelize provides the <code>getDataValue</code> method.</p><h2>Setters</h2><p>A setter is a <code>set()</code> function defined for one column in the model definition. It receives the value being set:</p><pre><code class="lang-js"><code class="source-code prettyprint">const User = sequelize.define('user', {
  username: DataTypes.STRING,
  password: {
    type: DataTypes.STRING,
    set(value) {
      // Storing passwords in plaintext in the database is terrible.
      // Hashing the value with an appropriate cryptographic hash function is better.
      this.setDataValue('password', hash(value));
    }
  }
});</code>
</code></pre><pre><code class="lang-js"><code class="source-code prettyprint">const user = User.build({ username: 'someone', password: 'NotSo§tr0ngP4$SW0RD!' });
console.log(user.password); // '7cfc84b8ea898bb72462e78b4643cfccd77e9f05678ec2ce78754147ba947acc'
console.log(user.getDataValue('password')); // '7cfc84b8ea898bb72462e78b4643cfccd77e9f05678ec2ce78754147ba947acc'</code>
</code></pre><p>Observe that Sequelize called the setter automatically, before even sending data to the database. The only data the database ever saw was the already hashed value.</p><p>If we wanted to involve another field from our model instance in the computation, that is possible and very easy!</p><pre><code class="lang-js"><code class="source-code prettyprint">const User = sequelize.define('user', {
  username: DataTypes.STRING,
  password: {
    type: DataTypes.STRING,
    set(value) {
      // Storing passwords in plaintext in the database is terrible.
      // Hashing the value with an appropriate cryptographic hash function is better.
      // Using the username as a salt is better.
      this.setDataValue('password', hash(this.username + value));
    }
  }
});</code>
</code></pre><p><strong>Note:</strong> The above examples involving password handling, although much better than simply storing the password in plaintext, are far from perfect security. Handling passwords properly is hard, everything here is just for the sake of an example to show Sequelize functionality. We suggest involving a cybersecurity expert and/or reading <a href="https://www.owasp.org/">OWASP</a> documents and/or visiting the <a href="https://security.stackexchange.com/">InfoSec StackExchange</a>.</p><h2>Combining getters and setters</h2><p>Getters and setters can be both defined in the same field.</p><p>For the sake of an example, let's say we are modeling a <code>Post</code>, whose <code>content</code> is a text of unlimited length. To improve memory usage, let's say we want to store a gzipped version of the content.</p><p><em>Note: modern databases should do some compression automatically in these cases. Please note that this is just for the sake of an example.</em></p><pre><code class="lang-js"><code class="source-code prettyprint">const { gzipSync, gunzipSync } = require('zlib');

const Post = sequelize.define('post', {
  content: {
    type: DataTypes.TEXT,
    get() {
      const storedValue = this.getDataValue('content');
      const gzippedBuffer = Buffer.from(storedValue, 'base64');
      const unzippedBuffer = gunzipSync(gzippedBuffer);
      return unzippedBuffer.toString();
    },
    set(value) {
      const gzippedBuffer = gzipSync(value);
      this.setDataValue('content', gzippedBuffer.toString('base64'));
    }
  }
});</code>
</code></pre><p>With the above setup, whenever we try to interact with the <code>content</code> field of our <code>Post</code> model, Sequelize will automatically handle the custom getter and setter. For example:</p><pre><code class="lang-js"><code class="source-code prettyprint">const post = await Post.create({ content: 'Hello everyone!' });

console.log(post.content); // 'Hello everyone!'
// Everything is happening under the hood, so we can even forget that the
// content is actually being stored as a gzipped base64 string!

// However, if we are really curious, we can get the 'raw' data...
console.log(post.getDataValue('content'));
// Output: 'H4sIAAAAAAAACvNIzcnJV0gtSy2qzM9LVQQAUuk9jQ8AAAA='</code>
</code></pre><h2>Virtual fields</h2><p>Virtual fields are fields that Sequelize populates under the hood, but in reality they don't even exist in the database.</p><p>For example, let's say we have the <code>firstName</code> and <code>lastName</code> attributes for a User.</p><p><em>Again, this is <a href="https://www.kalzumeus.com/2010/06/17/falsehoods-programmers-believe-about-names/">only for the sake of an example</a>.</em></p><p>It would be nice to have a simple way to obtain the <em>full name</em> directly! We can combine the idea of <code>getters</code> with the special data type Sequelize provides for this kind of situation: <code>DataTypes.VIRTUAL</code>:</p><pre><code class="lang-js"><code class="source-code prettyprint">const { DataTypes } = require("sequelize");

const User = sequelize.define('user', {
  firstName: DataTypes.TEXT,
  lastName: DataTypes.TEXT,
  fullName: {
    type: DataTypes.VIRTUAL,
    get() {
      return `${this.firstName} ${this.lastName}`;
    },
    set(value) {
      throw new Error('Do not try to set the `fullName` value!');
    }
  }
});</code>
</code></pre><p>The <code>VIRTUAL</code> field does not cause a column in the table to exist. In other words, the model above will not have a <code>fullName</code> column. However, it will appear to have it!</p><pre><code class="lang-js"><code class="source-code prettyprint">const user = await User.create({ firstName: 'John', lastName: 'Doe' });
console.log(user.fullName); // 'John Doe'</code>
</code></pre><h2>Deprecated in Sequelize v7: <code>getterMethods</code> and <code>setterMethods</code></h2><p>Sequelize also provides the <code>getterMethods</code> and <code>setterMethods</code> options in the model definition to specify things that look like, but aren't exactly the same as, virtual attributes. This usage is discouraged and likely to be <strong>deprecated</strong> in the future (in favor of using virtual attributes directly).</p><p>Example:</p><pre><code class="lang-js"><code class="source-code prettyprint">const { Sequelize, DataTypes } = require('sequelize');
const sequelize = new Sequelize('sqlite::memory:');

const User = sequelize.define('user', {
  firstName: DataTypes.STRING,
  lastName: DataTypes.STRING
}, {
  getterMethods: {
    fullName() {
      return this.firstName + ' ' + this.lastName;
    }
  },
  setterMethods: {
    fullName(value) {
      // Note: this is just for demonstration.
      // See: https://www.kalzumeus.com/2010/06/17/falsehoods-programmers-believe-about-names/
      const names = value.split(' ');
      const firstName = names[0];
      const lastName = names.slice(1).join(' ');
      this.setDataValue('firstName', firstName);
      this.setDataValue('lastName', lastName);
    }
  }
});

(async () =&gt; {
  await sequelize.sync();
  let user = await User.create({ firstName: 'John',  lastName: 'Doe' });
  console.log(user.fullName); // 'John Doe'
  user.fullName = 'Someone Else';
  await user.save();
  user = await User.findOne();
  console.log(user.firstName); // 'Someone'
  console.log(user.lastName); // 'Else'
})();</code>
</code></pre></div>
        <a data-ice="link" href="manual/getters-setters-virtuals.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Validations &amp; Constraints</h1><p>In this tutorial you will learn how to setup validations and constraints for your models in Sequelize.</p><p>For this tutorial, the following setup will be assumed:</p><pre><code class="lang-js"><code class="source-code prettyprint">const { Sequelize, Op, Model, DataTypes } = require("sequelize");
const sequelize = new Sequelize("sqlite::memory:");

const User = sequelize.define("user", {
  username: {
    type: DataTypes.TEXT,
    allowNull: false,
    unique: true
  },
  hashedPassword: {
    type: DataTypes.STRING(64),
    validate: {
      is: /^[0-9a-f]{64}$/i
    }
  }
});

(async () =&gt; {
  await sequelize.sync({ force: true });
  // Code here
})();</code>
</code></pre><h2>Difference between Validations and Constraints</h2><p>Validations are checks performed in the Sequelize level, in pure JavaScript. They can be arbitrarily complex if you provide a custom validator function, or can be one of the built-in validators offered by Sequelize. If a validation fails, no SQL query will be sent to the database at all.</p><p>On the other hand, constraints are rules defined at SQL level. The most basic example of constraint is an Unique Constraint. If a constraint check fails, an error will be thrown by the database and Sequelize will forward this error to JavaScript (in this example, throwing a <code>SequelizeUniqueConstraintError</code>). Note that in this case, the SQL query was performed, unlike the case for validations.</p><h2>Unique Constraint</h2><p>Our code example above defines a unique constraint on the <code>username</code> field:</p><pre><code class="lang-js"><code class="source-code prettyprint">/* ... */ {
  username: {
    type: DataTypes.TEXT,
    allowNull: false,
    unique: true
  },
} /* ... */</code>
</code></pre><p>When this model is synchronized (by calling <code>sequelize.sync</code> for example), the <code>username</code> field will be created in the table as <code>`username` TEXT UNIQUE</code>, and an attempt to insert an username that already exists there will throw a <code>SequelizeUniqueConstraintError</code>.</p><h2>Allowing/disallowing null values</h2><p>By default, <code>null</code> is an allowed value for every column of a model. This can be disabled setting the <code>allowNull: false</code> option for a column, as it was done in the <code>username</code> field from our code example:</p><pre><code class="lang-js"><code class="source-code prettyprint">/* ... */ {
  username: {
    type: DataTypes.TEXT,
    allowNull: false,
    unique: true
  },
} /* ... */</code>
</code></pre><p>Without <code>allowNull: false</code>, the call <code>User.create({})</code> would work.</p><h3>Note about <code>allowNull</code> implementation</h3><p>The <code>allowNull</code> check is the only check in Sequelize that is a mix of a <em>validation</em> and a <em>constraint</em> in the senses described at the beginning of this tutorial. This is because:</p><ul>
<li>If an attempt is made to set <code>null</code> to a field that does not allow null, a <code>ValidationError</code> will be thrown <em>without any SQL query being performed</em>.</li>
<li>In addition, after <code>sequelize.sync</code>, the column that has <code>allowNull: false</code> will be defined with a <code>NOT NULL</code> SQL constraint. This way, direct SQL queries that attempt to set the value to <code>null</code> will also fail.</li>
</ul><h2>Validators</h2><p>Model validators allow you to specify format/content/inheritance validations for each attribute of the model. Validations are automatically run on <code>create</code>, <code>update</code> and <code>save</code>. You can also call <code>validate()</code> to manually validate an instance.</p><h3>Per-attribute validations</h3><p>You can define your custom validators or use several built-in validators, implemented by <a href="https://github.com/chriso/validator.js">validator.js (10.11.0)</a>, as shown below.</p><pre><code class="lang-js"><code class="source-code prettyprint">sequelize.define('foo', {
  bar: {
    type: DataTypes.STRING,
    validate: {
      is: /^[a-z]+$/i,          // matches this RegExp
      is: ["^[a-z]+$",'i'],     // same as above, but constructing the RegExp from a string
      not: /^[a-z]+$/i,         // does not match this RegExp
      not: ["^[a-z]+$",'i'],    // same as above, but constructing the RegExp from a string
      isEmail: true,            // checks for email format (foo@bar.com)
      isUrl: true,              // checks for url format (http://foo.com)
      isIP: true,               // checks for IPv4 (129.89.23.1) or IPv6 format
      isIPv4: true,             // checks for IPv4 (129.89.23.1)
      isIPv6: true,             // checks for IPv6 format
      isAlpha: true,            // will only allow letters
      isAlphanumeric: true,     // will only allow alphanumeric characters, so "_abc" will fail
      isNumeric: true,          // will only allow numbers
      isInt: true,              // checks for valid integers
      isFloat: true,            // checks for valid floating point numbers
      isDecimal: true,          // checks for any numbers
      isLowercase: true,        // checks for lowercase
      isUppercase: true,        // checks for uppercase
      notNull: true,            // won't allow null
      isNull: true,             // only allows null
      notEmpty: true,           // don't allow empty strings
      equals: 'specific value', // only allow a specific value
      contains: 'foo',          // force specific substrings
      notIn: [['foo', 'bar']],  // check the value is not one of these
      isIn: [['foo', 'bar']],   // check the value is one of these
      notContains: 'bar',       // don't allow specific substrings
      len: [2,10],              // only allow values with length between 2 and 10
      isUUID: 4,                // only allow uuids
      isDate: true,             // only allow date strings
      isAfter: "2011-11-05",    // only allow date strings after a specific date
      isBefore: "2011-11-05",   // only allow date strings before a specific date
      max: 23,                  // only allow values &lt;= 23
      min: 23,                  // only allow values &gt;= 23
      isCreditCard: true,       // check for valid credit card numbers

      // Examples of custom validators:
      isEven(value) {
        if (parseInt(value) % 2 !== 0) {
          throw new Error('Only even values are allowed!');
        }
      }
      isGreaterThanOtherField(value) {
        if (parseInt(value) &lt;= parseInt(this.otherField)) {
          throw new Error('Bar must be greater than otherField.');
        }
      }
    }
  }
});</code>
</code></pre><p>Note that where multiple arguments need to be passed to the built-in validation functions, the arguments to be passed must be in an array. But if a single array argument is to be passed, for instance an array of acceptable strings for <code>isIn</code>, this will be interpreted as multiple string arguments instead of one array argument. To work around this pass a single-length array of arguments, such as <code>[['foo', 'bar']]</code> as shown above.</p><p>To use a custom error message instead of that provided by <a href="https://github.com/chriso/validator.js">validator.js</a>, use an object instead of the plain value or array of arguments, for example a validator which needs no argument can be given a custom message with</p><pre><code class="lang-js"><code class="source-code prettyprint">isInt: {
  msg: "Must be an integer number of pennies"
}</code>
</code></pre><p>or if arguments need to also be passed add an <code>args</code> property:</p><pre><code class="lang-js"><code class="source-code prettyprint">isIn: {
  args: [['en', 'zh']],
  msg: "Must be English or Chinese"
}</code>
</code></pre><p>When using custom validator functions the error message will be whatever message the thrown <code>Error</code> object holds.</p><p>See <a href="https://github.com/chriso/validator.js">the validator.js project</a> for more details on the built in validation methods.</p><p><strong>Hint:</strong> You can also define a custom function for the logging part. Just pass a function. The first parameter will be the string that is logged.</p><h3><code>allowNull</code> interaction with other validators</h3><p>If a particular field of a model is set to not allow null (with <code>allowNull: false</code>) and that value has been set to <code>null</code>, all validators will be skipped and a <code>ValidationError</code> will be thrown.</p><p>On the other hand, if it is set to allow null (with <code>allowNull: true</code>) and that value has been set to <code>null</code>, only the built-in validators will be skipped, while the custom validators will still run.</p><p>This means you can, for instance, have a string field which validates its length to be between 5 and 10 characters, but which also allows <code>null</code> (since the length validator will be skipped automatically when the value is <code>null</code>):</p><pre><code class="lang-js"><code class="source-code prettyprint">class User extends Model {}
User.init({
  username: {
    type: DataTypes.STRING,
    allowNull: true,
    validate: {
      len: [5, 10]
    }
  }
}, { sequelize });</code>
</code></pre><p>You also can conditionally allow <code>null</code> values, with a custom validator, since it won't be skipped:</p><pre><code class="lang-js"><code class="source-code prettyprint">class User extends Model {}
User.init({
  age: Sequelize.INTEGER,
  name: {
    type: DataTypes.STRING,
    allowNull: true,
    validate: {
      customValidator(value) {
        if (value === null &amp;&amp; this.age !== 10) {
          throw new Error("name can't be null unless age is 10");
        }
      })
    }
  }
}, { sequelize });</code>
</code></pre><p>You can customize <code>allowNull</code> error message by setting the <code>notNull</code> validator:</p><pre><code class="lang-js"><code class="source-code prettyprint">class User extends Model {}
User.init({
  name: {
    type: DataTypes.STRING,
    allowNull: false,
    validate: {
      notNull: {
        msg: 'Please enter your name'
      }
    }
  }
}, { sequelize });</code>
</code></pre><h3>Model-wide validations</h3><p>Validations can also be defined to check the model after the field-specific validators. Using this you could, for example, ensure either neither of <code>latitude</code> and <code>longitude</code> are set or both, and fail if one but not the other is set.</p><p>Model validator methods are called with the model object's context and are deemed to fail if they throw an error, otherwise pass. This is just the same as with custom field-specific validators.</p><p>Any error messages collected are put in the validation result object alongside the field validation errors, with keys named after the failed validation method's key in the <code>validate</code> option object. Even though there can only be one error message for each model validation method at any one time, it is presented as a single string error in an array, to maximize consistency with the field errors.</p><p>An example:</p><pre><code class="lang-js"><code class="source-code prettyprint">class Place extends Model {}
Place.init({
  name: Sequelize.STRING,
  address: Sequelize.STRING,
  latitude: {
    type: DataTypes.INTEGER,
    validate: {
      min: -90,
      max: 90
    }
  },
  longitude: {
    type: DataTypes.INTEGER,
    validate: {
      min: -180,
      max: 180
    }
  },
}, {
  sequelize,
  validate: {
    bothCoordsOrNone() {
      if ((this.latitude === null) !== (this.longitude === null)) {
        throw new Error('Either both latitude and longitude, or neither!');
      }
    }
  }
})</code>
</code></pre><p>In this simple case an object fails validation if either latitude or longitude is given, but not both. If we try to build one with an out-of-range latitude and no longitude, <code>somePlace.validate()</code> might return:</p><pre><code class="lang-js"><code class="source-code prettyprint">{
  'latitude': ['Invalid number: latitude'],
  'bothCoordsOrNone': ['Either both latitude and longitude, or neither!']
}</code>
</code></pre><p>Such validation could have also been done with a custom validator defined on a single attribute (such as the <code>latitude</code> attribute, by checking <code>(value === null) !== (this.longitude === null)</code>), but the model-wide validation approach is cleaner.</p></div>
        <a data-ice="link" href="manual/validations-and-constraints.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Raw Queries</h1><p>As there are often use cases in which it is just easier to execute raw / already prepared SQL queries, you can use the <a href="./manual/../class/src/sequelize.js~Sequelize.html#instance-method-query"><code>sequelize.query</code></a> method.</p><p>By default the function will return two arguments - a results array, and an object containing metadata (such as amount of affected rows, etc). Note that since this is a raw query, the metadata are dialect specific. Some dialects return the metadata "within" the results object (as properties on an array). However, two arguments will always be returned, but for MSSQL and MySQL it will be two references to the same object.</p><pre><code class="lang-js"><code class="source-code prettyprint">const [results, metadata] = await sequelize.query("UPDATE users SET y = 42 WHERE x = 12");
// Results will be an empty array and metadata will contain the number of affected rows.</code>
</code></pre><p>In cases where you don't need to access the metadata you can pass in a query type to tell sequelize how to format the results. For example, for a simple select query you could do:</p><pre><code class="lang-js"><code class="source-code prettyprint">const { QueryTypes } = require('sequelize');
const users = await sequelize.query("SELECT * FROM `users`", { type: QueryTypes.SELECT });
// We didn't need to destructure the result here - the results were returned directly</code>
</code></pre><p>Several other query types are available. <a href="https://github.com/sequelize/sequelize/blob/main/src/query-types.ts">Peek into the source for details</a>.</p><p>A second option is the model. If you pass a model the returned data will be instances of that model.</p><pre><code class="lang-js"><code class="source-code prettyprint">// Callee is the model definition. This allows you to easily map a query to a predefined model
const projects = await sequelize.query('SELECT * FROM projects', {
  model: Projects,
  mapToModel: true // pass true here if you have any mapped fields
});
// Each element of `projects` is now an instance of Project</code>
</code></pre><p>See more options in the <a href="./manual/../class/src/sequelize.js~Sequelize.html#instance-method-query">query API reference</a>. Some examples:</p><pre><code class="lang-js"><code class="source-code prettyprint">const { QueryTypes } = require('sequelize');
await sequelize.query('SELECT 1', {
  // A function (or false) for logging your queries
  // Will get called for every SQL query that gets sent
  // to the server.
  logging: console.log,

  // If plain is true, then sequelize will only return the first
  // record of the result set. In case of false it will return all records.
  plain: false,

  // Set this to true if you don't have a model definition for your query.
  raw: false,

  // The type of query you are executing. The query type affects how results are formatted before they are passed back.
  type: QueryTypes.SELECT
});

// Note the second argument being null!
// Even if we declared a callee here, the raw: true would
// supersede and return a raw object.
console.log(await sequelize.query('SELECT * FROM projects', { raw: true }));</code>
</code></pre><h2>"Dotted" attributes and the <code>nest</code> option</h2><p>If an attribute name of the table contains dots, the resulting objects can become nested objects by setting the <code>nest: true</code> option. This is achieved with <a href="https://github.com/mickhansen/dottie.js/">dottie.js</a> under the hood. See below:</p><ul>
<li><p>Without <code>nest: true</code>:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">const { QueryTypes } = require('sequelize');
const records = await sequelize.query('select 1 as `foo.bar.baz`', {
  type: QueryTypes.SELECT
});
console.log(JSON.stringify(records[0], null, 2));</code>
</code></pre>
<pre><code class="lang-json"><code class="source-code prettyprint">{
  "foo.bar.baz": 1
}</code>
</code></pre>
</li>
<li><p>With <code>nest: true</code>:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">const { QueryTypes } = require('sequelize');
const records = await sequelize.query('select 1 as `foo.bar.baz`', {
  nest: true,
  type: QueryTypes.SELECT
});
console.log(JSON.stringify(records[0], null, 2));</code>
</code></pre>
<pre><code class="lang-json"><code class="source-code prettyprint">{
  "foo": {
    "bar": {
      "baz": 1
    }
  }
}</code>
</code></pre>
</li>
</ul><h2>Replacements</h2><p>Replacements in a query can be done in two different ways, either using named parameters (starting with <code>:</code>), or unnamed, represented by a <code>?</code>. Replacements are passed in the options object.</p><ul>
<li>If an array is passed, <code>?</code> will be replaced in the order that they appear in the array</li>
<li>If an object is passed, <code>:key</code> will be replaced with the keys from that object. If the object contains keys not found in the query or vice versa, an exception will be thrown.</li>
</ul><pre><code class="lang-js"><code class="source-code prettyprint">const { QueryTypes } = require('sequelize');

await sequelize.query(
  'SELECT * FROM projects WHERE status = ?',
  {
    replacements: ['active'],
    type: QueryTypes.SELECT
  }
);

await sequelize.query(
  'SELECT * FROM projects WHERE status = :status',
  {
    replacements: { status: 'active' },
    type: QueryTypes.SELECT
  }
);</code>
</code></pre><p>Array replacements will automatically be handled, the following query searches for projects where the status matches an array of values.</p><pre><code class="lang-js"><code class="source-code prettyprint">const { QueryTypes } = require('sequelize');

await sequelize.query(
  'SELECT * FROM projects WHERE status IN(:status)',
  {
    replacements: { status: ['active', 'inactive'] },
    type: QueryTypes.SELECT
  }
);</code>
</code></pre><p>To use the wildcard operator <code>%</code>, append it to your replacement. The following query matches users with names that start with 'ben'.</p><pre><code class="lang-js"><code class="source-code prettyprint">const { QueryTypes } = require('sequelize');

await sequelize.query(
  'SELECT * FROM users WHERE name LIKE :search_name',
  {
    replacements: { search_name: 'ben%' },
    type: QueryTypes.SELECT
  }
);</code>
</code></pre><h2>Bind Parameter</h2><p>Bind parameters are like replacements. Except replacements are escaped and inserted into the query by sequelize before the query is sent to the database, while bind parameters are sent to the database outside the SQL query text. A query can have either bind parameters or replacements. Bind parameters are referred to by either $1, $2, ... (numeric) or $key (alpha-numeric). This is independent of the dialect.</p><ul>
<li>If an array is passed, <code>$1</code> is bound to the 1st element in the array (<code>bind[0]</code>)</li>
<li>If an object is passed, <code>$key</code> is bound to <code>object['key']</code>. Each key must begin with a non-numeric char. <code>$1</code> is not a valid key, even if <code>object['1']</code> exists.</li>
<li>In either case <code>$$</code> can be used to escape a literal <code>$</code> sign.</li>
</ul><p>The array or object must contain all bound values or Sequelize will throw an exception. This applies even to cases in which the database may ignore the bound parameter.</p><p>The database may add further restrictions to this. Bind parameters cannot be SQL keywords, nor table or column names. They are also ignored in quoted text or data. In PostgreSQL it may also be needed to typecast them, if the type cannot be inferred from the context <code>$1::varchar</code>.</p><pre><code class="lang-js"><code class="source-code prettyprint">const { QueryTypes } = require('sequelize');

await sequelize.query(
  'SELECT *, "text with literal $$1 and literal $$status" as t FROM projects WHERE status = $1',
  {
    bind: ['active'],
    type: QueryTypes.SELECT
  }
);

await sequelize.query(
  'SELECT *, "text with literal $$1 and literal $$status" as t FROM projects WHERE status = $status',
  {
    bind: { status: 'active' },
    type: QueryTypes.SELECT
  }
);</code>
</code></pre></div>
        <a data-ice="link" href="manual/raw-queries.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Associations</h1><p>Sequelize supports the standard associations: <a href="https://en.wikipedia.org/wiki/One-to-one_%28data_model%29">One-To-One</a>, <a href="https://en.wikipedia.org/wiki/One-to-many_%28data_model%29">One-To-Many</a> and <a href="https://en.wikipedia.org/wiki/Many-to-many_%28data_model%29">Many-To-Many</a>.</p><p>To do this, Sequelize provides <strong>four</strong> types of associations that should be combined to create them:</p><ul>
<li>The <code>HasOne</code> association</li>
<li>The <code>BelongsTo</code> association</li>
<li>The <code>HasMany</code> association</li>
<li>The <code>BelongsToMany</code> association</li>
</ul><p>The guide will start explaining how to define these four types of associations, and then will follow up to explain how to combine those to define the three standard association types (<a href="https://en.wikipedia.org/wiki/One-to-one_%28data_model%29">One-To-One</a>, <a href="https://en.wikipedia.org/wiki/One-to-many_%28data_model%29">One-To-Many</a> and <a href="https://en.wikipedia.org/wiki/Many-to-many_%28data_model%29">Many-To-Many</a>).</p><h2>Defining the Sequelize associations</h2><p>The four association types are defined in a very similar way. Let's say we have two models, <code>A</code> and <code>B</code>. Telling Sequelize that you want an association between the two needs just a function call:</p><pre><code class="lang-js"><code class="source-code prettyprint">const A = sequelize.define('A', /* ... */);
const B = sequelize.define('B', /* ... */);

A.hasOne(B); // A HasOne B
A.belongsTo(B); // A BelongsTo B
A.hasMany(B); // A HasMany B
A.belongsToMany(B, { through: 'C' }); // A BelongsToMany B through the junction table C</code>
</code></pre><p>They all accept an options object as a second parameter (optional for the first three, mandatory for <code>belongsToMany</code> containing at least the <code>through</code> property):</p><pre><code class="lang-js"><code class="source-code prettyprint">A.hasOne(B, { /* options */ });
A.belongsTo(B, { /* options */ });
A.hasMany(B, { /* options */ });
A.belongsToMany(B, { through: 'C', /* options */ });</code>
</code></pre><p>The order in which the association is defined is relevant. In other words, the order matters, for the four cases. In all examples above, <code>A</code> is called the <strong>source</strong> model and <code>B</code> is called the <strong>target</strong> model. This terminology is important.</p><p>The <code>A.hasOne(B)</code> association means that a One-To-One relationship exists between <code>A</code> and <code>B</code>, with the foreign key being defined in the target model (<code>B</code>).</p><p>The <code>A.belongsTo(B)</code> association means that a One-To-One relationship exists between <code>A</code> and <code>B</code>, with the foreign key being defined in the source model (<code>A</code>).</p><p>The <code>A.hasMany(B)</code> association means that a One-To-Many relationship exists between <code>A</code> and <code>B</code>, with the foreign key being defined in the target model (<code>B</code>).</p><p>These three calls will cause Sequelize to automatically add foreign keys to the appropriate models (unless they are already present).</p><p>The <code>A.belongsToMany(B, { through: 'C' })</code> association means that a Many-To-Many relationship exists between <code>A</code> and <code>B</code>, using table <code>C</code> as <a href="https://en.wikipedia.org/wiki/Associative_entity">junction table</a>, which will have the foreign keys (<code>aId</code> and <code>bId</code>, for example). Sequelize will automatically create this model <code>C</code> (unless it already exists) and define the appropriate foreign keys on it.</p><p><em>Note: In the examples above for <code>belongsToMany</code>, a string (<code>'C'</code>) was passed to the through option. In this case, Sequelize automatically generates a model with this name. However, you can also pass a model directly, if you have already defined it.</em></p><p>These are the main ideas involved in each type of association. However, these relationships are often used in pairs, in order to enable better usage with Sequelize. This will be seen later on.</p><h2>Creating the standard relationships</h2><p>As mentioned, usually the Sequelize associations are defined in pairs. In summary:</p><ul>
<li>To create a <strong>One-To-One</strong> relationship, the <code>hasOne</code> and <code>belongsTo</code> associations are used together;</li>
<li>To create a <strong>One-To-Many</strong> relationship, the <code>hasMany</code> and <code>belongsTo</code> associations are used together;</li>
<li>To create a <strong>Many-To-Many</strong> relationship, two <code>belongsToMany</code> calls are used together.<ul>
<li>Note: there is also a <em>Super Many-To-Many</em> relationship, which uses six associations at once, and will be discussed in the <a href="./manual/advanced-many-to-many.html">Advanced Many-to-Many relationships guide</a>.</li>
</ul>
</li>
</ul><p>This will all be seen in detail next. The advantages of using these pairs instead of one single association will be discussed in the end of this chapter.</p><h2>One-To-One relationships</h2><h3>Philosophy</h3><p>Before digging into the aspects of using Sequelize, it is useful to take a step back to consider what happens with a One-To-One relationship.</p><p>Let's say we have two models, <code>Foo</code> and <code>Bar</code>. We want to establish a One-To-One relationship between Foo and Bar. We know that in a relational database, this will be done by establishing a foreign key in one of the tables. So in this case, a very relevant question is: in which table do we want this foreign key to be? In other words, do we want <code>Foo</code> to have a <code>barId</code> column, or should <code>Bar</code> have a <code>fooId</code> column instead?</p><p>In principle, both options are a valid way to establish a One-To-One relationship between Foo and Bar. However, when we say something like <em>"there is a One-To-One relationship between Foo and Bar"</em>, it is unclear whether or not the relationship is <em>mandatory</em> or optional. In other words, can a Foo exist without a Bar? Can a Bar exist without a Foo? The answers to these questions helps figuring out where we want the foreign key column to be.</p><h3>Goal</h3><p>For the rest of this example, let's assume that we have two models, <code>Foo</code> and <code>Bar</code>. We want to setup a One-To-One relationship between them such that <code>Bar</code> gets a <code>fooId</code> column.</p><h3>Implementation</h3><p>The main setup to achieve the goal is as follows:</p><pre><code class="lang-js"><code class="source-code prettyprint">Foo.hasOne(Bar);
Bar.belongsTo(Foo);</code>
</code></pre><p>Since no option was passed, Sequelize will infer what to do from the names of the models. In this case, Sequelize knows that a <code>fooId</code> column must be added to <code>Bar</code>.</p><p>This way, calling <code>Bar.sync()</code> after the above will yield the following SQL (on PostgreSQL, for example):</p><pre><code class="lang-sql"><code class="source-code prettyprint">CREATE TABLE IF NOT EXISTS "foos" (
  /* ... */
);
CREATE TABLE IF NOT EXISTS "bars" (
  /* ... */
  "fooId" INTEGER REFERENCES "foos" ("id") ON DELETE SET NULL ON UPDATE CASCADE
  /* ... */
);</code>
</code></pre><h3>Options</h3><p>Various options can be passed as a second parameter of the association call.</p><h4><code>onDelete</code> and <code>onUpdate</code></h4><p>For example, to configure the <code>ON DELETE</code> and <code>ON UPDATE</code> behaviors, you can do:</p><pre><code class="lang-js"><code class="source-code prettyprint">Foo.hasOne(Bar, {
  onDelete: 'RESTRICT',
  onUpdate: 'RESTRICT'
});
Bar.belongsTo(Foo);</code>
</code></pre><p>The possible choices are <code>RESTRICT</code>, <code>CASCADE</code>, <code>NO ACTION</code>, <code>SET DEFAULT</code> and <code>SET NULL</code>.</p><p>The defaults for the One-To-One associations is <code>SET NULL</code> for <code>ON DELETE</code> and <code>CASCADE</code> for <code>ON UPDATE</code>.</p><h4>Customizing the foreign key</h4><p>Both the <code>hasOne</code> and <code>belongsTo</code> calls shown above will infer that the foreign key to be created should be called <code>fooId</code>. To use a different name, such as <code>myFooId</code>:</p><pre><code class="lang-js"><code class="source-code prettyprint">// Option 1
Foo.hasOne(Bar, {
  foreignKey: 'myFooId'
});
Bar.belongsTo(Foo);

// Option 2
Foo.hasOne(Bar, {
  foreignKey: {
    name: 'myFooId'
  }
});
Bar.belongsTo(Foo);

// Option 3
Foo.hasOne(Bar);
Bar.belongsTo(Foo, {
  foreignKey: 'myFooId'
});

// Option 4
Foo.hasOne(Bar);
Bar.belongsTo(Foo, {
  foreignKey: {
    name: 'myFooId'
  }
});</code>
</code></pre><p>As shown above, the <code>foreignKey</code> option accepts a string or an object. When receiving an object, this object will be used as the definition for the column just like it would do in a standard <code>sequelize.define</code> call. Therefore, specifying options such as <code>type</code>, <code>allowNull</code>, <code>defaultValue</code>, etc, just  work.</p><p>For example, to use <code>UUID</code> as the foreign key data type instead of the default (<code>INTEGER</code>), you can simply do:</p><pre><code class="lang-js"><code class="source-code prettyprint">const { DataTypes } = require("Sequelize");

Foo.hasOne(Bar, {
  foreignKey: {
    // name: 'myFooId'
    type: DataTypes.UUID
  }
});
Bar.belongsTo(Foo);</code>
</code></pre><h4>Mandatory versus optional associations</h4><p>By default, the association is considered optional. In other words, in our example, the <code>fooId</code> is allowed to be null, meaning that one Bar can exist without a Foo. Changing this is just a matter of specifying <code>allowNull: false</code> in the foreign key options:</p><pre><code class="lang-js"><code class="source-code prettyprint">Foo.hasOne(Bar, {
  foreignKey: {
    allowNull: false
  }
});
// "fooId" INTEGER NOT NULL REFERENCES "foos" ("id") ON DELETE RESTRICT ON UPDATE RESTRICT</code>
</code></pre><h2>One-To-Many relationships</h2><h3>Philosophy</h3><p>One-To-Many associations are connecting one source with multiple targets, while all these targets are connected only with this single source.</p><p>This means that, unlike the One-To-One association, in which we had to choose where the foreign key would be placed, there is only one option in One-To-Many associations. For example, if one Foo has many Bars (and this way each Bar belongs to one Foo), then the only sensible implementation is to have a <code>fooId</code> column in the <code>Bar</code> table. The opposite is impossible, since one Foo has many Bars.</p><h3>Goal</h3><p>In this example, we have the models <code>Team</code> and <code>Player</code>. We want to tell Sequelize that there is a One-To-Many relationship between them, meaning that one Team has many Players, while each Player belongs to a single Team.</p><h3>Implementation</h3><p>The main way to do this is as follows:</p><pre><code class="lang-js"><code class="source-code prettyprint">Team.hasMany(Player);
Player.belongsTo(Team);</code>
</code></pre><p>Again, as mentioned, the main way to do it used a pair of Sequelize associations (<code>hasMany</code> and <code>belongsTo</code>).</p><p>For example, in PostgreSQL, the above setup will yield the following SQL upon <code>sync()</code>:</p><pre><code class="lang-sql"><code class="source-code prettyprint">CREATE TABLE IF NOT EXISTS "Teams" (
  /* ... */
);
CREATE TABLE IF NOT EXISTS "Players" (
  /* ... */
  "TeamId" INTEGER REFERENCES "Teams" ("id") ON DELETE SET NULL ON UPDATE CASCADE,
  /* ... */
);</code>
</code></pre><h3>Options</h3><p>The options to be applied in this case are the same from the One-To-One case. For example, to change the name of the foreign key and make sure that the relationship is mandatory, we can do:</p><pre><code class="lang-js"><code class="source-code prettyprint">Team.hasMany(Player, {
  foreignKey: 'clubId'
});
Player.belongsTo(Team);</code>
</code></pre><p>Like One-To-One relationships, <code>ON DELETE</code> defaults to <code>SET NULL</code> and <code>ON UPDATE</code> defaults to <code>CASCADE</code>.</p><h2>Many-To-Many relationships</h2><h3>Philosophy</h3><p>Many-To-Many associations connect one source with multiple targets, while all these targets can in turn be connected to other sources beyond the first.</p><p>This cannot be represented by adding one foreign key to one of the tables, like the other relationships did. Instead, the concept of a <a href="https://en.wikipedia.org/wiki/Associative_entity">Junction Model</a> is used. This will be an extra model (and extra table in the database) which will have two foreign key columns and will keep track of the associations. The junction table is also sometimes called <em>join table</em> or <em>through table</em>.</p><h3>Goal</h3><p>For this example, we will consider the models <code>Movie</code> and <code>Actor</code>. One actor may have participated in many movies, and one movie had many actors involved with its production. The junction table that will keep track of the associations will be called <code>ActorMovies</code>, which will contain the foreign keys <code>movieId</code> and <code>actorId</code>.</p><h3>Implementation</h3><p>The main way to do this in Sequelize is as follows:</p><pre><code class="lang-js"><code class="source-code prettyprint">const Movie = sequelize.define('Movie', { name: DataTypes.STRING });
const Actor = sequelize.define('Actor', { name: DataTypes.STRING });
Movie.belongsToMany(Actor, { through: 'ActorMovies' });
Actor.belongsToMany(Movie, { through: 'ActorMovies' });</code>
</code></pre><p>Since a string was given in the <code>through</code> option of the <code>belongsToMany</code> call, Sequelize will automatically create the <code>ActorMovies</code> model which will act as the junction model. For example, in PostgreSQL:</p><pre><code class="lang-sql"><code class="source-code prettyprint">CREATE TABLE IF NOT EXISTS "ActorMovies" (
  "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL,
  "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL,
  "MovieId" INTEGER REFERENCES "Movies" ("id") ON DELETE CASCADE ON UPDATE CASCADE,
  "ActorId" INTEGER REFERENCES "Actors" ("id") ON DELETE CASCADE ON UPDATE CASCADE,
  PRIMARY KEY ("MovieId","ActorId")
);</code>
</code></pre><p>Instead of a string, passing a model directly is also supported, and in that case the given model will be used as the junction model (and no model will be created automatically). For example:</p><pre><code class="lang-js"><code class="source-code prettyprint">const Movie = sequelize.define('Movie', { name: DataTypes.STRING });
const Actor = sequelize.define('Actor', { name: DataTypes.STRING });
const ActorMovies = sequelize.define('ActorMovies', {
  MovieId: {
    type: DataTypes.INTEGER,
    references: {
      model: Movie, // 'Movies' would also work
      key: 'id'
    }
  },
  ActorId: {
    type: DataTypes.INTEGER,
    references: {
      model: Actor, // 'Actors' would also work
      key: 'id'
    }
  }
});
Movie.belongsToMany(Actor, { through: ActorMovies });
Actor.belongsToMany(Movie, { through: ActorMovies });</code>
</code></pre><p>The above yields the following SQL in PostgreSQL, which is equivalent to the one shown above:</p><pre><code class="lang-sql"><code class="source-code prettyprint">CREATE TABLE IF NOT EXISTS "ActorMovies" (
  "MovieId" INTEGER NOT NULL REFERENCES "Movies" ("id") ON DELETE RESTRICT ON UPDATE CASCADE,
  "ActorId" INTEGER NOT NULL REFERENCES "Actors" ("id") ON DELETE RESTRICT ON UPDATE CASCADE,
  "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL,
  "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL,
  UNIQUE ("MovieId", "ActorId"),     -- Note: Sequelize generated this UNIQUE constraint but
  PRIMARY KEY ("MovieId","ActorId")  -- it is irrelevant since it's also a PRIMARY KEY
);</code>
</code></pre><h3>Options</h3><p>Unlike One-To-One and One-To-Many relationships, the defaults for both <code>ON UPDATE</code> and <code>ON DELETE</code> are <code>CASCADE</code> for Many-To-Many relationships.</p><p>Belongs-To-Many creates a unique key on through model. This unique key name can be overridden using <strong>uniqueKey</strong> option. To prevent creating this unique key, use the <strong><em>unique: false</em></strong> option.</p><pre><code class="lang-js"><code class="source-code prettyprint">Project.belongsToMany(User, { through: UserProjects, uniqueKey: 'my_custom_unique' })</code>
</code></pre><h2>Basics of queries involving associations</h2><p>With the basics of defining associations covered, we can look at queries involving associations. The most common queries on this matter are the <em>read</em> queries (i.e. SELECTs). Later on, other types of queries will be shown.</p><p>In order to study this, we will consider an example in which we have Ships and Captains, and a one-to-one relationship between them. We will allow null on foreign keys (the default), meaning that a Ship can exist without a Captain and vice-versa.</p><pre><code class="lang-js"><code class="source-code prettyprint">// This is the setup of our models for the examples below
const Ship = sequelize.define('ship', {
  name: DataTypes.TEXT,
  crewCapacity: DataTypes.INTEGER,
  amountOfSails: DataTypes.INTEGER
}, { timestamps: false });
const Captain = sequelize.define('captain', {
  name: DataTypes.TEXT,
  skillLevel: {
    type: DataTypes.INTEGER,
    validate: { min: 1, max: 10 }
  }
}, { timestamps: false });
Captain.hasOne(Ship);
Ship.belongsTo(Captain);</code>
</code></pre><h3>Fetching associations - Eager Loading vs Lazy Loading</h3><p>The concepts of Eager Loading and Lazy Loading are fundamental to understand how fetching associations work in Sequelize. Lazy Loading refers to the technique of fetching the associated data only when you really want it; Eager Loading, on the other hand, refers to the technique of fetching everything at once, since the beginning, with a larger query.</p><h4>Lazy Loading example</h4><pre><code class="lang-js"><code class="source-code prettyprint">const awesomeCaptain = await Captain.findOne({
  where: {
    name: "Jack Sparrow"
  }
});
// Do stuff with the fetched captain
console.log('Name:', awesomeCaptain.name);
console.log('Skill Level:', awesomeCaptain.skillLevel);
// Now we want information about his ship!
const hisShip = await awesomeCaptain.getShip();
// Do stuff with the ship
console.log('Ship Name:', hisShip.name);
console.log('Amount of Sails:', hisShip.amountOfSails);</code>
</code></pre><p>Observe that in the example above, we made two queries, only fetching the associated ship when we wanted to use it. This can be especially useful if we may or may not need the ship, perhaps we want to fetch it conditionally, only in a few cases; this way we can save time and memory by only fetching it when necessary.</p><p>Note: the <code>getShip()</code> instance method used above is one of the methods Sequelize automatically adds to <code>Captain</code> instances. There are others. You will learn more about them later in this guide.</p><h4>Eager Loading Example</h4><pre><code class="lang-js"><code class="source-code prettyprint">const awesomeCaptain = await Captain.findOne({
  where: {
    name: "Jack Sparrow"
  },
  include: Ship
});
// Now the ship comes with it
console.log('Name:', awesomeCaptain.name);
console.log('Skill Level:', awesomeCaptain.skillLevel);
console.log('Ship Name:', awesomeCaptain.ship.name);
console.log('Amount of Sails:', awesomeCaptain.ship.amountOfSails);</code>
</code></pre><p>As shown above, Eager Loading is performed in Sequelize by using the <code>include</code> option. Observe that here only one query was performed to the database (which brings the associated data along with the instance).</p><p>This was just a quick introduction to Eager Loading in Sequelize. There is a lot more to it, which you can learn at <a href="./manual/eager-loading.html">the dedicated guide on Eager Loading</a>.</p><h3>Creating, updating and deleting</h3><p>The above showed the basics on queries for fetching data involving associations. For creating, updating and deleting, you can either:</p><ul>
<li><p>Use the standard model queries directly:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">// Example: creating an associated model using the standard methods
Bar.create({
  name: 'My Bar',
  fooId: 5
});
// This creates a Bar belonging to the Foo of ID 5 (since fooId is
// a regular column, after all). Nothing very clever going on here.</code>
</code></pre>
</li>
<li><p>Or use the <em><a href="#special-methods-mixins-added-to-instances">special methods/mixins</a></em> available for associated models, which are explained later on this page.</p>
</li>
</ul><p><strong>Note:</strong> The <a href="./manual/../class/src/model.js~Model.html#instance-method-save"><code>save()</code> instance method</a> is not aware of associations. In other words, if you change a value from a <em>child</em> object that was eager loaded along a <em>parent</em> object, calling <code>save()</code> on the parent will completely ignore the change that happened on the child.</p><h2>Association Aliases &amp; Custom Foreign Keys</h2><p>In all the above examples, Sequelize automatically defined the foreign key names. For example, in the Ship and Captain example, Sequelize automatically defined a <code>captainId</code> field on the Ship model. However, it is easy to specify a custom foreign key.</p><p>Let's consider the models Ship and Captain in a simplified form, just to focus on the current topic, as shown below (less fields):</p><pre><code class="lang-js"><code class="source-code prettyprint">const Ship = sequelize.define('ship', { name: DataTypes.TEXT }, { timestamps: false });
const Captain = sequelize.define('captain', { name: DataTypes.TEXT }, { timestamps: false });</code>
</code></pre><p>There are three ways to specify a different name for the foreign key:</p><ul>
<li>By providing the foreign key name directly</li>
<li>By defining an Alias</li>
<li>By doing both things</li>
</ul><h3>Recap: the default setup</h3><p>By using simply <code>Ship.belongsTo(Captain)</code>, sequelize will generate the foreign key name automatically:</p><pre><code class="lang-js"><code class="source-code prettyprint">Ship.belongsTo(Captain); // This creates the `captainId` foreign key in Ship.

// Eager Loading is done by passing the model to `include`:
console.log((await Ship.findAll({ include: Captain })).toJSON());
// Or by providing the associated model name:
console.log((await Ship.findAll({ include: 'captain' })).toJSON());

// Also, instances obtain a `getCaptain()` method for Lazy Loading:
const ship = Ship.findOne();
console.log((await ship.getCaptain()).toJSON());</code>
</code></pre><h3>Providing the foreign key name directly</h3><p>The foreign key name can be provided directly with an option in the association definition, as follows:</p><pre><code class="lang-js"><code class="source-code prettyprint">Ship.belongsTo(Captain, { foreignKey: 'bossId' }); // This creates the `bossId` foreign key in Ship.

// Eager Loading is done by passing the model to `include`:
console.log((await Ship.findAll({ include: Captain })).toJSON());
// Or by providing the associated model name:
console.log((await Ship.findAll({ include: 'Captain' })).toJSON());

// Also, instances obtain a `getCaptain()` method for Lazy Loading:
const ship = Ship.findOne();
console.log((await ship.getCaptain()).toJSON());</code>
</code></pre><h3>Defining an Alias</h3><p>Defining an Alias is more powerful than simply specifying a custom name for the foreign key. This is better understood with an example:</p><p><!-- NOTE: any change in this part might also require a change on advanced-many-to-many.md -->
</p><pre><code class="lang-js"><code class="source-code prettyprint">Ship.belongsTo(Captain, { as: 'leader' }); // This creates the `leaderId` foreign key in Ship.

// Eager Loading no longer works by passing the model to `include`:
console.log((await Ship.findAll({ include: Captain })).toJSON()); // Throws an error
// Instead, you have to pass the alias:
console.log((await Ship.findAll({ include: 'leader' })).toJSON());
// Or you can pass an object specifying the model and alias:
console.log((await Ship.findAll({
  include: {
    model: Captain,
    as: 'leader'
  }
})).toJSON());

// Also, instances obtain a `getLeader()` method for Lazy Loading:
const ship = Ship.findOne();
console.log((await ship.getLeader()).toJSON());</code>
</code></pre><p>Aliases are especially useful when you need to define two different associations between the same models. For example, if we have the models <code>Mail</code> and <code>Person</code>, we may want to associate them twice, to represent the <code>sender</code> and <code>receiver</code> of the Mail. In this case we must use an alias for each association, since otherwise a call like <code>mail.getPerson()</code> would be ambiguous. With the <code>sender</code> and <code>receiver</code> aliases, we would have the two methods available and working: <code>mail.getSender()</code> and <code>mail.getReceiver()</code>, both of them returning a <code>Promise&lt;Person&gt;</code>.</p><p>When defining an alias for a <code>hasOne</code> or <code>belongsTo</code> association, you should use the singular form of a word (such as <code>leader</code>, in the example above). On the other hand, when defining an alias for <code>hasMany</code> and <code>belongsToMany</code>, you should use the plural form. Defining aliases for Many-to-Many relationships (with <code>belongsToMany</code>) is covered in the <a href="./manual/advanced-many-to-many.html">Advanced Many-to-Many Associations guide</a>.</p><h3>Doing both things</h3><p>We can define and alias and also directly define the foreign key:</p><pre><code class="lang-js"><code class="source-code prettyprint">Ship.belongsTo(Captain, { as: 'leader', foreignKey: 'bossId' }); // This creates the `bossId` foreign key in Ship.

// Since an alias was defined, eager Loading doesn't work by simply passing the model to `include`:
console.log((await Ship.findAll({ include: Captain })).toJSON()); // Throws an error
// Instead, you have to pass the alias:
console.log((await Ship.findAll({ include: 'leader' })).toJSON());
// Or you can pass an object specifying the model and alias:
console.log((await Ship.findAll({
  include: {
    model: Captain,
    as: 'leader'
  }
})).toJSON());

// Also, instances obtain a `getLeader()` method for Lazy Loading:
const ship = Ship.findOne();
console.log((await ship.getLeader()).toJSON());</code>
</code></pre><h2>Special methods/mixins added to instances</h2><p>When an association is defined between two models, the instances of those models gain special methods to interact with their associated counterparts.</p><p>For example, if we have two models, <code>Foo</code> and <code>Bar</code>, and they are associated, their instances will have the following methods/mixins available, depending on the association type:</p><h3><code>Foo.hasOne(Bar)</code></h3><ul>
<li><code>fooInstance.getBar()</code></li>
<li><code>fooInstance.setBar()</code></li>
<li><code>fooInstance.createBar()</code></li>
</ul><p>Example:</p><pre><code class="lang-js"><code class="source-code prettyprint">const foo = await Foo.create({ name: 'the-foo' });
const bar1 = await Bar.create({ name: 'some-bar' });
const bar2 = await Bar.create({ name: 'another-bar' });
console.log(await foo.getBar()); // null
await foo.setBar(bar1);
console.log((await foo.getBar()).name); // 'some-bar'
await foo.createBar({ name: 'yet-another-bar' });
const newlyAssociatedBar = await foo.getBar();
console.log(newlyAssociatedBar.name); // 'yet-another-bar'
await foo.setBar(null); // Un-associate
console.log(await foo.getBar()); // null</code>
</code></pre><h3><code>Foo.belongsTo(Bar)</code></h3><p>The same ones from <code>Foo.hasOne(Bar)</code>:</p><ul>
<li><code>fooInstance.getBar()</code></li>
<li><code>fooInstance.setBar()</code></li>
<li><code>fooInstance.createBar()</code></li>
</ul><h3><code>Foo.hasMany(Bar)</code></h3><ul>
<li><code>fooInstance.getBars()</code></li>
<li><code>fooInstance.countBars()</code></li>
<li><code>fooInstance.hasBar()</code></li>
<li><code>fooInstance.hasBars()</code></li>
<li><code>fooInstance.setBars()</code></li>
<li><code>fooInstance.addBar()</code></li>
<li><code>fooInstance.addBars()</code></li>
<li><code>fooInstance.removeBar()</code></li>
<li><code>fooInstance.removeBars()</code></li>
<li><code>fooInstance.createBar()</code></li>
</ul><p>Example:</p><pre><code class="lang-js"><code class="source-code prettyprint">const foo = await Foo.create({ name: 'the-foo' });
const bar1 = await Bar.create({ name: 'some-bar' });
const bar2 = await Bar.create({ name: 'another-bar' });
console.log(await foo.getBars()); // []
console.log(await foo.countBars()); // 0
console.log(await foo.hasBar(bar1)); // false
await foo.addBars([bar1, bar2]);
console.log(await foo.countBars()); // 2
await foo.addBar(bar1);
console.log(await foo.countBars()); // 2
console.log(await foo.hasBar(bar1)); // true
await foo.removeBar(bar2);
console.log(await foo.countBars()); // 1
await foo.createBar({ name: 'yet-another-bar' });
console.log(await foo.countBars()); // 2
await foo.setBars([]); // Un-associate all previously associated bars
console.log(await foo.countBars()); // 0</code>
</code></pre><p>The getter method accepts options just like the usual finder methods (such as <code>findAll</code>):</p><pre><code class="lang-js"><code class="source-code prettyprint">const easyTasks = await project.getTasks({
  where: {
    difficulty: {
      [Op.lte]: 5
    }
  }
});
const taskTitles = (await project.getTasks({
  attributes: ['title'],
  raw: true
})).map(task =&gt; task.title);</code>
</code></pre><h3><code>Foo.belongsToMany(Bar, { through: Baz })</code></h3><p>The same ones from <code>Foo.hasMany(Bar)</code>:</p><ul>
<li><code>fooInstance.getBars()</code></li>
<li><code>fooInstance.countBars()</code></li>
<li><code>fooInstance.hasBar()</code></li>
<li><code>fooInstance.hasBars()</code></li>
<li><code>fooInstance.setBars()</code></li>
<li><code>fooInstance.addBar()</code></li>
<li><code>fooInstance.addBars()</code></li>
<li><code>fooInstance.removeBar()</code></li>
<li><code>fooInstance.removeBars()</code></li>
<li><code>fooInstance.createBar()</code></li>
</ul><p>For belongsToMany relationships, by default <code>getBars()</code> will return all fields from the join table. Note that any <code>include</code> options will apply to the target <code>Bar</code> object, so trying to set options for the join table as you would when eager loading with <code>find</code> methods is not possible. To choose what attributes of the join table to include, <code>getBars()</code> supports a <code>joinTableAttributes</code> option that can be used similarly to setting <code>through.attributes</code> in an <code>include</code>. As an example, given Foo belongsToMany Bar, the following will both output results without join table fields:</p><pre><code class="lang-js"><code class="source-code prettyprint">const foo = Foo.findByPk(id, {
  include: [{
    model: Bar,
    through: { attributes: [] }
  }]
})
console.log(foo.bars)

const foo = Foo.findByPk(id)
console.log(foo.getBars({ joinTableAttributes: [] }))</code>
</code></pre><h3>Note: Method names</h3><p>As shown in the examples above, the names Sequelize gives to these special methods are formed by a prefix (e.g. <code>get</code>, <code>add</code>, <code>set</code>) concatenated with the model name (with the first letter in uppercase). When necessary, the plural is used, such as in <code>fooInstance.setBars()</code>. Again, irregular plurals are also handled automatically by Sequelize. For example, <code>Person</code> becomes <code>People</code> and <code>Hypothesis</code> becomes <code>Hypotheses</code>.</p><p>If an alias was defined, it will be used instead of the model name to form the method names. For example:</p><pre><code class="lang-js"><code class="source-code prettyprint">Task.hasOne(User, { as: 'Author' });</code>
</code></pre><ul>
<li><code>taskInstance.getAuthor()</code></li>
<li><code>taskInstance.setAuthor()</code></li>
<li><code>taskInstance.createAuthor()</code></li>
</ul><h2>Why associations are defined in pairs?</h2><p>As mentioned earlier and shown in most examples above, usually associations in Sequelize are defined in pairs:</p><ul>
<li>To create a <strong>One-To-One</strong> relationship, the <code>hasOne</code> and <code>belongsTo</code> associations are used together;</li>
<li>To create a <strong>One-To-Many</strong> relationship, the <code>hasMany</code> and <code>belongsTo</code> associations are used together;</li>
<li>To create a <strong>Many-To-Many</strong> relationship, two <code>belongsToMany</code> calls are used together.</li>
</ul><p>When a Sequelize association is defined between two models, only the <em>source</em> model <em>knows about it</em>. So, for example, when using <code>Foo.hasOne(Bar)</code> (so <code>Foo</code> is the source model and <code>Bar</code> is the target model), only <code>Foo</code> knows about the existence of this association. This is why in this case, as shown above, <code>Foo</code> instances gain the methods <code>getBar()</code>, <code>setBar()</code> and <code>createBar()</code>, while on the other hand <code>Bar</code> instances get nothing.</p><p>Similarly, for <code>Foo.hasOne(Bar)</code>, since <code>Foo</code> knows about the relationship, we can perform eager loading as in <code>Foo.findOne({ include: Bar })</code>, but we can't do <code>Bar.findOne({ include: Foo })</code>.</p><p>Therefore, to bring full power to Sequelize usage, we usually setup the relationship in pairs, so that both models get to <em>know about it</em>.</p><p>Practical demonstration:</p><ul>
<li><p>If we do not define the pair of associations, calling for example just <code>Foo.hasOne(Bar)</code>:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">// This works...
await Foo.findOne({ include: Bar });

// But this throws an error:
await Bar.findOne({ include: Foo });
// SequelizeEagerLoadingError: foo is not associated to bar!</code>
</code></pre>
</li>
<li><p>If we define the pair as recommended, i.e., both <code>Foo.hasOne(Bar)</code> and <code>Bar.belongsTo(Foo)</code>:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">// This works!
await Foo.findOne({ include: Bar });

// This also works!
await Bar.findOne({ include: Foo });</code>
</code></pre>
</li>
</ul><h2>Multiple associations involving the same models</h2><p>In Sequelize, it is possible to define multiple associations between the same models. You just have to define different aliases for them:</p><pre><code class="lang-js"><code class="source-code prettyprint">Team.hasOne(Game, { as: 'HomeTeam', foreignKey: 'homeTeamId' });
Team.hasOne(Game, { as: 'AwayTeam', foreignKey: 'awayTeamId' });
Game.belongsTo(Team);</code>
</code></pre><h2>Creating associations referencing a field which is not the primary key</h2><p>In all the examples above, the associations were defined by referencing the primary keys of the involved models (in our case, their IDs). However, Sequelize allows you to define an association that uses another field, instead of the primary key field, to establish the association.</p><p>This other field must have a unique constraint on it (otherwise, it wouldn't make sense).</p><h3>For <code>belongsTo</code> relationships</h3><p>First, recall that the <code>A.belongsTo(B)</code> association places the foreign key in the <em>source model</em> (i.e., in <code>A</code>).</p><p>Let's again use the example of Ships and Captains. Additionally, we will assume that Captain names are unique:</p><pre><code class="lang-js"><code class="source-code prettyprint">const Ship = sequelize.define('ship', { name: DataTypes.TEXT }, { timestamps: false });
const Captain = sequelize.define('captain', {
  name: { type: DataTypes.TEXT, unique: true }
}, { timestamps: false });</code>
</code></pre><p>This way, instead of keeping the <code>captainId</code> on our Ships, we could keep a <code>captainName</code> instead and use it as our association tracker. In other words, instead of referencing the <code>id</code> from the target model (Captain), our relationship will reference another column on the target model: the <code>name</code> column. To specify this, we have to define a <em>target key</em>. We will also have to specify a name for the foreign key itself:</p><pre><code class="lang-js"><code class="source-code prettyprint">Ship.belongsTo(Captain, { targetKey: 'name', foreignKey: 'captainName' });
// This creates a foreign key called `captainName` in the source model (Ship)
// which references the `name` field from the target model (Captain).</code>
</code></pre><p>Now we can do things like:</p><pre><code class="lang-js"><code class="source-code prettyprint">await Captain.create({ name: "Jack Sparrow" });
const ship = await Ship.create({ name: "Black Pearl", captainName: "Jack Sparrow" });
console.log((await ship.getCaptain()).name); // "Jack Sparrow"</code>
</code></pre><h3>For <code>hasOne</code> and <code>hasMany</code> relationships</h3><p>The exact same idea can be applied to the <code>hasOne</code> and <code>hasMany</code> associations, but instead of providing a <code>targetKey</code>, we provide a <code>sourceKey</code> when defining the association. This is because unlike <code>belongsTo</code>, the <code>hasOne</code> and <code>hasMany</code> associations keep the foreign key on the target model:</p><pre><code class="lang-js"><code class="source-code prettyprint">const Foo = sequelize.define('foo', {
  name: { type: DataTypes.TEXT, unique: true }
}, { timestamps: false });
const Bar = sequelize.define('bar', {
  title: { type: DataTypes.TEXT, unique: true }
}, { timestamps: false });
const Baz = sequelize.define('baz', { summary: DataTypes.TEXT }, { timestamps: false });
Foo.hasOne(Bar, { sourceKey: 'name', foreignKey: 'fooName' });
Bar.hasMany(Baz, { sourceKey: 'title', foreignKey: 'barTitle' });
// [...]
await Bar.setFoo("Foo's Name Here");
await Baz.addBar("Bar's Title Here");</code>
</code></pre><h3>For <code>belongsToMany</code> relationships</h3><p>The same idea can also be applied to <code>belongsToMany</code> relationships. However, unlike the other situations, in which we have only one foreign key involved, the <code>belongsToMany</code> relationship involves two foreign keys which are kept on an extra table (the junction table).</p><p>Consider the following setup:</p><pre><code class="lang-js"><code class="source-code prettyprint">const Foo = sequelize.define('foo', {
  name: { type: DataTypes.TEXT, unique: true }
}, { timestamps: false });
const Bar = sequelize.define('bar', {
  title: { type: DataTypes.TEXT, unique: true }
}, { timestamps: false });</code>
</code></pre><p>There are four cases to consider:</p><ul>
<li>We might want a many-to-many relationship using the default primary keys for both <code>Foo</code> and <code>Bar</code>:</li>
</ul><pre><code class="lang-js"><code class="source-code prettyprint">Foo.belongsToMany(Bar, { through: 'foo_bar' });
// This creates a junction table `foo_bar` with fields `fooId` and `barId`</code>
</code></pre><ul>
<li>We might want a many-to-many relationship using the default primary key for <code>Foo</code> but a different field for <code>Bar</code>:</li>
</ul><pre><code class="lang-js"><code class="source-code prettyprint">Foo.belongsToMany(Bar, { through: 'foo_bar', targetKey: 'title' });
// This creates a junction table `foo_bar` with fields `fooId` and `barTitle`</code>
</code></pre><ul>
<li>We might want a many-to-many relationship using the a different field for <code>Foo</code> and the default primary key for <code>Bar</code>:</li>
</ul><pre><code class="lang-js"><code class="source-code prettyprint">Foo.belongsToMany(Bar, { through: 'foo_bar', sourceKey: 'name' });
// This creates a junction table `foo_bar` with fields `fooName` and `barId`</code>
</code></pre><ul>
<li>We might want a many-to-many relationship using different fields for both <code>Foo</code> and <code>Bar</code>:</li>
</ul><pre><code class="lang-js"><code class="source-code prettyprint">Foo.belongsToMany(Bar, { through: 'foo_bar', sourceKey: 'name', targetKey: 'title' });
// This creates a junction table `foo_bar` with fields `fooName` and `barTitle`</code>
</code></pre><h3>Notes</h3><p>Don't forget that the field referenced in the association must have a unique constraint placed on it. Otherwise, an error will be thrown (and sometimes with a mysterious error message - such as <code>SequelizeDatabaseError: SQLITE_ERROR: foreign key mismatch - "ships" referencing "captains"</code> for SQLite).</p><p>The trick to deciding between <code>sourceKey</code> and <code>targetKey</code> is just to remember where each relationship places its foreign key. As mentioned in the beginning of this guide:</p><ul>
<li><p><code>A.belongsTo(B)</code> keeps the foreign key in the source model (<code>A</code>), therefore the referenced key is in the target model, hence the usage of <code>targetKey</code>.</p>
</li>
<li><p><code>A.hasOne(B)</code> and <code>A.hasMany(B)</code> keep the foreign key in the target model (<code>B</code>), therefore the referenced key is in the source model, hence the usage of <code>sourceKey</code>.</p>
</li>
<li><p><code>A.belongsToMany(B)</code> involves an extra table (the junction table), therefore both <code>sourceKey</code> and <code>targetKey</code> are usable, with <code>sourceKey</code> corresponding to some field in <code>A</code> (the source) and <code>targetKey</code> corresponding to some field in <code>B</code> (the target).</p>
</li>
</ul></div>
        <a data-ice="link" href="manual/assocs.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Paranoid</h1><p>Sequelize supports the concept of <em>paranoid</em> tables. A <em>paranoid</em> table is one that, when told to delete a record, it will not truly delete it. Instead, a special column called <code>deletedAt</code> will have its value set to the timestamp of that deletion request.</p><p>This means that paranoid tables perform a <em>soft-deletion</em> of records, instead of a <em>hard-deletion</em>.</p><h2>Defining a model as paranoid</h2><p>To make a model paranoid, you must pass the <code>paranoid: true</code> option to the model definition. Paranoid requires timestamps to work (i.e. it won't work if you also pass <code>timestamps: false</code>).</p><p>You can also change the default column name (which is <code>deletedAt</code>) to something else.</p><pre><code class="lang-js"><code class="source-code prettyprint">class Post extends Model {}
Post.init({ /* attributes here */ }, {
  sequelize,
  paranoid: true,

  // If you want to give a custom name to the deletedAt column
  deletedAt: 'destroyTime'
});</code>
</code></pre><h2>Deleting</h2><p>When you call the <code>destroy</code> method, a soft-deletion will happen:</p><pre><code class="lang-js"><code class="source-code prettyprint">await Post.destroy({
  where: {
    id: 1
  }
});
// UPDATE "posts" SET "deletedAt"=[timestamp] WHERE "deletedAt" IS NULL AND "id" = 1</code>
</code></pre><p>If you really want a hard-deletion and your model is paranoid, you can force it using the <code>force: true</code> option:</p><pre><code class="lang-js"><code class="source-code prettyprint">await Post.destroy({
  where: {
    id: 1
  },
  force: true
});
// DELETE FROM "posts" WHERE "id" = 1</code>
</code></pre><p>The above examples used the static <code>destroy</code> method as an example (<code>Post.destroy</code>), but everything works in the same way with the instance method:</p><pre><code class="lang-js"><code class="source-code prettyprint">const post = await Post.create({ title: 'test' });
console.log(post instanceof Post); // true
await post.destroy(); // Would just set the `deletedAt` flag
await post.destroy({ force: true }); // Would really delete the record</code>
</code></pre><h2>Restoring</h2><p>To restore soft-deleted records, you can use the <code>restore</code> method, which comes both in the static version as well as in the instance version:</p><pre><code class="lang-js"><code class="source-code prettyprint">// Example showing the instance `restore` method
// We create a post, soft-delete it and then restore it back
const post = await Post.create({ title: 'test' });
console.log(post instanceof Post); // true
await post.destroy();
console.log('soft-deleted!');
await post.restore();
console.log('restored!');

// Example showing the static `restore` method.
// Restoring every soft-deleted post with more than 100 likes
await Post.restore({
  where: {
    likes: {
      [Op.gt]: 100
    }
  }
});</code>
</code></pre><h2>Behavior with other queries</h2><p>Every query performed by Sequelize will automatically ignore soft-deleted records (except raw queries, of course).</p><p>This means that, for example, the <code>findAll</code> method will not see the soft-deleted records, fetching only the ones that were not deleted.</p><p>Even if you simply call <code>findByPk</code> providing the primary key of a soft-deleted record, the result will be <code>null</code> as if that record didn't exist.</p><p>If you really want to let the query see the soft-deleted records, you can pass the <code>paranoid: false</code> option to the query method. For example:</p><pre><code class="lang-js"><code class="source-code prettyprint">await Post.findByPk(123); // This will return `null` if the record of id 123 is soft-deleted
await Post.findByPk(123, { paranoid: false }); // This will retrieve the record

await Post.findAll({
  where: { foo: 'bar' }
}); // This will not retrieve soft-deleted records

await Post.findAll({
  where: { foo: 'bar' },
  paranoid: false
}); // This will also retrieve soft-deleted records</code>
</code></pre></div>
        <a data-ice="link" href="manual/paranoid.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Eager Loading</h1><p>As briefly mentioned in <a href="./manual/assocs.html">the associations guide</a>, eager Loading is the act of querying data of several models at once (one 'main' model and one or more associated models). At the SQL level, this is a query with one or more <a href="https://en.wikipedia.org/wiki/Join_\(SQL\">joins</a>).</p><p>When this is done, the associated models will be added by Sequelize in appropriately named, automatically created field(s) in the returned objects.</p><p>In Sequelize, eager loading is mainly done by using the <code>include</code> option on a model finder query (such as <code>findOne</code>, <code>findAll</code>, etc).</p><h2>Basic example</h2><p>Let's assume the following setup:</p><pre><code class="lang-js"><code class="source-code prettyprint">const User = sequelize.define('user', { name: DataTypes.STRING }, { timestamps: false });
const Task = sequelize.define('task', { name: DataTypes.STRING }, { timestamps: false });
const Tool = sequelize.define('tool', {
  name: DataTypes.STRING,
  size: DataTypes.STRING
}, { timestamps: false });
User.hasMany(Task);
Task.belongsTo(User);
User.hasMany(Tool, { as: 'Instruments' });</code>
</code></pre><h3>Fetching a single associated element</h3><p>OK. So, first of all, let's load all tasks with their associated user:</p><pre><code class="lang-js"><code class="source-code prettyprint">const tasks = await Task.findAll({ include: User });
console.log(JSON.stringify(tasks, null, 2));</code>
</code></pre><p>Output:</p><pre><code class="lang-json"><code class="source-code prettyprint">[{
  "name": "A Task",
  "id": 1,
  "userId": 1,
  "user": {
    "name": "John Doe",
    "id": 1
  }
}]</code>
</code></pre><p>Here, <code>tasks[0].user instanceof User</code> is <code>true</code>. This shows that when Sequelize fetches associated models, they are added to the output object as model instances.</p><p>Above, the associated model was added to a new field called <code>user</code> in the fetched task. The name of this field was automatically chosen by Sequelize based on the name of the associated model, where its pluralized form is used when applicable (i.e., when  the association is <code>hasMany</code> or <code>belongsToMany</code>). In other words, since <code>Task.belongsTo(User)</code>, a task is associated to one user, therefore the logical choice is the singular form (which Sequelize follows automatically).</p><h3>Fetching all associated elements</h3><p>Now, instead of loading the user that is associated to a given task, we will do the opposite - we will find all tasks associated to a given user.</p><p>The method call is essentially the same. The only difference is that now the extra field created in the query result uses the pluralized form (<code>tasks</code> in this case), and its value is an array of task instances (instead of a single instance, as above).</p><pre><code class="lang-js"><code class="source-code prettyprint">const users = await User.findAll({ include: Task });
console.log(JSON.stringify(users, null, 2));</code>
</code></pre><p>Output:</p><pre><code class="lang-json"><code class="source-code prettyprint">[{
  "name": "John Doe",
  "id": 1,
  "tasks": [{
    "name": "A Task",
    "id": 1,
    "userId": 1
  }]
}]</code>
</code></pre><p>Notice that the accessor (the <code>tasks</code> property in the resulting instance) is pluralized since the association is one-to-many.</p><h3>Fetching an Aliased association</h3><p>If an association is aliased (using the <code>as</code> option), you must specify this alias when including the model. Instead of passing the model directly to the <code>include</code> option, you should instead provide an object with two options: <code>model</code> and <code>as</code>.</p><p>Notice how the user's <code>Tool</code>s are aliased as <code>Instruments</code> above. In order to get that right you have to specify the model you want to load, as well as the alias:</p><pre><code class="lang-js"><code class="source-code prettyprint">const users = await User.findAll({
  include: { model: Tool, as: 'Instruments' }
});
console.log(JSON.stringify(users, null, 2));</code>
</code></pre><p>Output:</p><pre><code class="lang-json"><code class="source-code prettyprint">[{
  "name": "John Doe",
  "id": 1,
  "Instruments": [{
    "name": "Scissor",
    "id": 1,
    "userId": 1
  }]
}]</code>
</code></pre><p>You can also include by alias name by specifying a string that matches the association alias:</p><pre><code class="lang-js"><code class="source-code prettyprint">User.findAll({ include: 'Instruments' }); // Also works
User.findAll({ include: { association: 'Instruments' } }); // Also works</code>
</code></pre><h3>Required eager loading</h3><p>When eager loading, we can force the query to return only records which have an associated model, effectively converting the query from the default <code>OUTER JOIN</code> to an <code>INNER JOIN</code>. This is done with the <code>required: true</code> option, as follows:</p><pre><code class="lang-js"><code class="source-code prettyprint">User.findAll({
  include: {
    model: Task,
    required: true
  }
});</code>
</code></pre><p>This option also works on nested includes.</p><h3>Eager loading filtered at the associated model level</h3><p>When eager loading, we can also filter the associated model using the <code>where</code> option, as in the following example:</p><pre><code class="lang-js"><code class="source-code prettyprint">User.findAll({
  include: {
    model: Tool,
    as: 'Instruments'
    where: {
      size: {
        [Op.ne]: 'small'
      }
    }
  }
});</code>
</code></pre><p>Generated SQL:</p><pre><code class="lang-sql"><code class="source-code prettyprint">SELECT
  `user`.`id`,
  `user`.`name`,
  `Instruments`.`id` AS `Instruments.id`,
  `Instruments`.`name` AS `Instruments.name`,
  `Instruments`.`size` AS `Instruments.size`,
  `Instruments`.`userId` AS `Instruments.userId`
FROM `users` AS `user`
INNER JOIN `tools` AS `Instruments` ON
  `user`.`id` = `Instruments`.`userId` AND
  `Instruments`.`size` != 'small';</code>
</code></pre><p>Note that the SQL query generated above will only fetch users that have at least one tool that matches the condition (of not being <code>small</code>, in this case). This is the case because, when the <code>where</code> option is used inside an <code>include</code>, Sequelize automatically sets the <code>required</code> option to <code>true</code>. This means that, instead of an <code>OUTER JOIN</code>, an <code>INNER JOIN</code> is done, returning only the parent models with at least one matching children.</p><p>Note also that the <code>where</code> option used was converted into a condition for the <code>ON</code> clause of the <code>INNER JOIN</code>. In order to obtain a <em>top-level</em> <code>WHERE</code> clause, instead of an <code>ON</code> clause, something different must be done. This will be shown next.</p><h4>Referring to other columns</h4><p>If you want to apply a <code>WHERE</code> clause in an included model referring to a value from an associated model, you can simply use the <code>Sequelize.col</code> function, as show in the example below:</p><pre><code class="lang-js"><code class="source-code prettyprint">// Find all projects with a least one task where task.state === project.state
Project.findAll({
  include: {
    model: Task,
    where: {
      state: Sequelize.col('project.state')
    }
  }
})</code>
</code></pre><h3>Complex where clauses at the top-level</h3><p>To obtain top-level <code>WHERE</code> clauses that involve nested columns, Sequelize provides a way to reference nested columns: the <code>'$nested.column$'</code> syntax.</p><p>It can be used, for example, to move the where conditions from an included model from the <code>ON</code> condition to a top-level <code>WHERE</code> clause.</p><pre><code class="lang-js"><code class="source-code prettyprint">User.findAll({
  where: {
    '$Instruments.size$': { [Op.ne]: 'small' }
  },
  include: [{
    model: Tool,
    as: 'Instruments'
  }]
});</code>
</code></pre><p>Generated SQL:</p><pre><code class="lang-sql"><code class="source-code prettyprint">SELECT
  `user`.`id`,
  `user`.`name`,
  `Instruments`.`id` AS `Instruments.id`,
  `Instruments`.`name` AS `Instruments.name`,
  `Instruments`.`size` AS `Instruments.size`,
  `Instruments`.`userId` AS `Instruments.userId`
FROM `users` AS `user`
LEFT OUTER JOIN `tools` AS `Instruments` ON
  `user`.`id` = `Instruments`.`userId`
WHERE `Instruments`.`size` != 'small';</code>
</code></pre><p>The <code>$nested.column$</code> syntax also works for columns that are nested several levels deep, such as <code>$some.super.deeply.nested.column$</code>. Therefore, you can use this to make complex filters on deeply nested columns.</p><p>For a better understanding of all differences between the inner <code>where</code> option (used inside an <code>include</code>), with and without the <code>required</code> option, and a top-level <code>where</code> using the <code>$nested.column$</code> syntax, below we have four examples for you:</p><pre><code class="lang-js"><code class="source-code prettyprint">// Inner where, with default `required: true`
await User.findAll({
  include: {
    model: Tool,
    as: 'Instruments',
    where: {
      size: { [Op.ne]: 'small' }
    }
  }
});

// Inner where, `required: false`
await User.findAll({
  include: {
    model: Tool,
    as: 'Instruments',
    where: {
      size: { [Op.ne]: 'small' }
    },
    required: false
  }
});

// Top-level where, with default `required: false`
await User.findAll({
  where: {
    '$Instruments.size$': { [Op.ne]: 'small' }
  },
  include: {
    model: Tool,
    as: 'Instruments'
  }
});

// Top-level where, `required: true`
await User.findAll({
  where: {
    '$Instruments.size$': { [Op.ne]: 'small' }
  },
  include: {
    model: Tool,
    as: 'Instruments',
    required: true
  }
});</code>
</code></pre><p>Generated SQLs, in order:</p><pre><code class="lang-sql"><code class="source-code prettyprint">-- Inner where, with default `required: true`
SELECT [...] FROM `users` AS `user`
INNER JOIN `tools` AS `Instruments` ON
  `user`.`id` = `Instruments`.`userId`
  AND `Instruments`.`size` != 'small';

-- Inner where, `required: false`
SELECT [...] FROM `users` AS `user`
LEFT OUTER JOIN `tools` AS `Instruments` ON
  `user`.`id` = `Instruments`.`userId`
  AND `Instruments`.`size` != 'small';

-- Top-level where, with default `required: false`
SELECT [...] FROM `users` AS `user`
LEFT OUTER JOIN `tools` AS `Instruments` ON
  `user`.`id` = `Instruments`.`userId`
WHERE `Instruments`.`size` != 'small';

-- Top-level where, `required: true`
SELECT [...] FROM `users` AS `user`
INNER JOIN `tools` AS `Instruments` ON
  `user`.`id` = `Instruments`.`userId`
WHERE `Instruments`.`size` != 'small';</code>
</code></pre><h3>Fetching with <code>RIGHT OUTER JOIN</code> (MySQL, MariaDB, PostgreSQL and MSSQL only)</h3><p>By default, associations are loaded using a <code>LEFT OUTER JOIN</code> - that is to say it only includes records from the parent table. You can change this behavior to a <code>RIGHT OUTER JOIN</code> by passing the <code>right</code> option, if the dialect you are using supports it.</p><p>Currenly, SQLite does not support <a href="https://www.sqlite.org/omitted.html">right joins</a>.</p><p><em>Note:</em> <code>right</code> is only respected if <code>required</code> is false.</p><pre><code class="lang-js"><code class="source-code prettyprint">User.findAll({
  include: [{
    model: Task // will create a left join
  }]
});
User.findAll({
  include: [{
    model: Task,
    right: true // will create a right join
  }]
});
User.findAll({
  include: [{
    model: Task,
    required: true,
    right: true // has no effect, will create an inner join
  }]
});
User.findAll({
  include: [{
    model: Task,
    where: { name: { [Op.ne]: 'empty trash' } },
    right: true // has no effect, will create an inner join
  }]
});
User.findAll({
  include: [{
    model: Tool,
    where: { name: { [Op.ne]: 'empty trash' } },
    required: false // will create a left join
  }]
});
User.findAll({
  include: [{
    model: Tool,
    where: { name: { [Op.ne]: 'empty trash' } },
    required: false
    right: true // will create a right join
  }]
});</code>
</code></pre><h2>Multiple eager loading</h2><p>The <code>include</code> option can receive an array in order to fetch multiple associated models at once:</p><pre><code class="lang-js"><code class="source-code prettyprint">Foo.findAll({
  include: [
    {
      model: Bar,
      required: true
    },
    {
      model: Baz,
      where: /* ... */
    },
    Qux // Shorthand syntax for { model: Qux } also works here
  ]
})</code>
</code></pre><h2>Eager loading with Many-to-Many relationships</h2><p>When you perform eager loading on a model with a Belongs-to-Many relationship, Sequelize will fetch the junction table data as well, by default. For example:</p><pre><code class="lang-js"><code class="source-code prettyprint">const Foo = sequelize.define('Foo', { name: DataTypes.TEXT });
const Bar = sequelize.define('Bar', { name: DataTypes.TEXT });
Foo.belongsToMany(Bar, { through: 'Foo_Bar' });
Bar.belongsToMany(Foo, { through: 'Foo_Bar' });

await sequelize.sync();
const foo = await Foo.create({ name: 'foo' });
const bar = await Bar.create({ name: 'bar' });
await foo.addBar(bar);
const fetchedFoo = await Foo.findOne({ include: Bar });
console.log(JSON.stringify(fetchedFoo, null, 2));</code>
</code></pre><p>Output:</p><pre><code class="lang-json"><code class="source-code prettyprint">{
  "id": 1,
  "name": "foo",
  "Bars": [
    {
      "id": 1,
      "name": "bar",
      "Foo_Bar": {
        "FooId": 1,
        "BarId": 1
      }
    }
  ]
}</code>
</code></pre><p>Note that every bar instance eager loaded into the <code>"Bars"</code> property has an extra property called <code>Foo_Bar</code> which is the relevant Sequelize instance of the junction model. By default, Sequelize fetches all attributes from the junction table in order to build this extra property.</p><p>However, you can specify which attributes you want fetched. This is done with the <code>attributes</code> option applied inside the <code>through</code> option of the include. For example:</p><pre><code class="lang-js"><code class="source-code prettyprint">Foo.findAll({
  include: [{
    model: Bar,
    through: {
      attributes: [/* list the wanted attributes here */]
    }
  }]
});</code>
</code></pre><p>If you don't want anything from the junction table, you can explicitly provide an empty array to the <code>attributes</code> option inside the <code>through</code> option of the <code>include</code> option, and in this case nothing will be fetched and the extra property will not even be created:</p><pre><code class="lang-js"><code class="source-code prettyprint">Foo.findOne({
  include: {
    model: Bar,
    through: {
      attributes: []
    }
  }
});</code>
</code></pre><p>Output:</p><pre><code class="lang-json"><code class="source-code prettyprint">{
  "id": 1,
  "name": "foo",
  "Bars": [
    {
      "id": 1,
      "name": "bar"
    }
  ]
}</code>
</code></pre><p>Whenever including a model from a Many-to-Many relationship, you can also apply a filter on the junction table. This is done with the <code>where</code> option applied inside the <code>through</code> option of the include. For example:</p><pre><code class="lang-js"><code class="source-code prettyprint">User.findAll({
  include: [{
    model: Project,
    through: {
      where: {
        // Here, `completed` is a column present at the junction table
        completed: true
      }
    }
  }]
});</code>
</code></pre><p>Generated SQL (using SQLite):</p><pre><code class="lang-sql"><code class="source-code prettyprint">SELECT
  `User`.`id`,
  `User`.`name`,
  `Projects`.`id` AS `Projects.id`,
  `Projects`.`name` AS `Projects.name`,
  `Projects-&gt;User_Project`.`completed` AS `Projects.User_Project.completed`,
  `Projects-&gt;User_Project`.`UserId` AS `Projects.User_Project.UserId`,
  `Projects-&gt;User_Project`.`ProjectId` AS `Projects.User_Project.ProjectId`
FROM `Users` AS `User`
LEFT OUTER JOIN `User_Projects` AS `Projects-&gt;User_Project` ON
  `User`.`id` = `Projects-&gt;User_Project`.`UserId`
LEFT OUTER JOIN `Projects` AS `Projects` ON
  `Projects`.`id` = `Projects-&gt;User_Project`.`ProjectId` AND
  `Projects-&gt;User_Project`.`completed` = 1;</code>
</code></pre><h2>Including everything</h2><p>To include all associated models, you can use the <code>all</code> and <code>nested</code> options:</p><pre><code class="lang-js"><code class="source-code prettyprint">// Fetch all models associated with User
User.findAll({ include: { all: true }});

// Fetch all models associated with User and their nested associations (recursively)
User.findAll({ include: { all: true, nested: true }});</code>
</code></pre><h2>Including soft deleted records</h2><p>In case you want to eager load soft deleted records you can do that by setting <code>include.paranoid</code> to <code>false</code>:</p><pre><code class="lang-js"><code class="source-code prettyprint">User.findAll({
  include: [{
    model: Tool,
    as: 'Instruments',
    where: { size: { [Op.ne]: 'small' } },
    paranoid: false
  }]
});</code>
</code></pre><h2>Ordering eager loaded associations</h2><p>When you want to apply <code>ORDER</code> clauses to eager loaded models, you must use the top-level <code>order</code> option with augmented arrays, starting with the specification of the nested model you want to sort.</p><p>This is better understood with examples.</p><pre><code class="lang-js"><code class="source-code prettyprint">Company.findAll({
  include: Division,
  order: [
    // We start the order array with the model we want to sort
    [Division, 'name', 'ASC']
  ]
});
Company.findAll({
  include: Division,
  order: [
    [Division, 'name', 'DESC']
  ]
});
Company.findAll({
  // If the include uses an alias...
  include: { model: Division, as: 'Div' },
  order: [
    // ...we use the same syntax from the include
    // in the beginning of the order array
    [{ model: Division, as: 'Div' }, 'name', 'DESC']
  ]
});

Company.findAll({
  // If we have includes nested in several levels...
  include: {
    model: Division,
    include: Department
  },
  order: [
    // ... we replicate the include chain of interest
    // at the beginning of the order array
    [Division, Department, 'name', 'DESC']
  ]
});</code>
</code></pre><p>In the case of many-to-many relationships, you are also able to sort by attributes in the through table. For example, assuming we have a Many-to-Many relationship between <code>Division</code> and <code>Department</code> whose junction model is <code>DepartmentDivision</code>, you can do:</p><pre><code class="lang-js"><code class="source-code prettyprint">Company.findAll({
  include: {
    model: Division,
    include: Department
  },
  order: [
    [Division, DepartmentDivision, 'name', 'ASC']
  ]
});</code>
</code></pre><p>In all the above examples, you have noticed that the <code>order</code> option is used at the top-level. The only situation in which <code>order</code> also works inside the include option is when <code>separate: true</code> is used. In that case, the usage is as follows:</p><pre><code class="lang-js"><code class="source-code prettyprint">// This only works for `separate: true` (which in turn
// only works for has-many relationships).
User.findAll({
  include: {
    model: Post,
    separate: true,
    order: [
      ['createdAt', 'DESC']
    ]
  }
});</code>
</code></pre><h3>Complex ordering involving sub-queries</h3><p>Take a look at the <a href="./manual/sub-queries.html">guide on sub-queries</a> for an example of how to use a sub-query to assist a more complex ordering.</p><h2>Nested eager loading</h2><p>You can use nested eager loading to load all related models of a related model:</p><pre><code class="lang-js"><code class="source-code prettyprint">const users = await User.findAll({
  include: {
    model: Tool,
    as: 'Instruments',
    include: {
      model: Teacher,
      include: [ /* etc */ ]
    }
  }
});
console.log(JSON.stringify(users, null, 2));</code>
</code></pre><p>Output:</p><pre><code class="lang-json"><code class="source-code prettyprint">[{
  "name": "John Doe",
  "id": 1,
  "Instruments": [{ // 1:M and N:M association
    "name": "Scissor",
    "id": 1,
    "userId": 1,
    "Teacher": { // 1:1 association
      "name": "Jimi Hendrix"
    }
  }]
}]</code>
</code></pre><p>This will produce an outer join. However, a <code>where</code> clause on a related model will create an inner join and return only the instances that have matching sub-models. To return all parent instances, you should add <code>required: false</code>.</p><pre><code class="lang-js"><code class="source-code prettyprint">User.findAll({
  include: [{
    model: Tool,
    as: 'Instruments',
    include: [{
      model: Teacher,
      where: {
        school: "Woodstock Music School"
      },
      required: false
    }]
  }]
});</code>
</code></pre><p>The query above will return all users, and all their instruments, but only those teachers associated with <code>Woodstock Music School</code>.</p><h2>Using <code>findAndCountAll</code> with includes</h2><p>The <code>findAndCountAll</code> utility function supports includes. Only the includes that are marked as <code>required</code> will be considered in <code>count</code>. For example, if you want to find and count all users who have a profile:</p><pre><code class="lang-js"><code class="source-code prettyprint">User.findAndCountAll({
  include: [
    { model: Profile, required: true }
  ],
  limit: 3
});</code>
</code></pre><p>Because the include for <code>Profile</code> has <code>required</code> set it will result in an inner join, and only the users who have a profile will be counted. If we remove <code>required</code> from the include, both users with and without profiles will be counted. Adding a <code>where</code> clause to the include automatically makes it required:</p><pre><code class="lang-js"><code class="source-code prettyprint">User.findAndCountAll({
  include: [
    { model: Profile, where: { active: true } }
  ],
  limit: 3
});</code>
</code></pre><p>The query above will only count users who have an active profile, because <code>required</code> is implicitly set to true when you add a where clause to the include.</p></div>
        <a data-ice="link" href="manual/eager-loading.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Creating with Associations</h1><p>An instance can be created with nested association in one step, provided all elements are new.</p><p>In contrast, performing updates and deletions involving nested objects is currently not possible. For that, you will have to perform each separate action explicitly.</p><h2>BelongsTo / HasMany / HasOne association</h2><p>Consider the following models:</p><pre><code class="lang-js"><code class="source-code prettyprint">class Product extends Model {}
Product.init({
  title: Sequelize.STRING
}, { sequelize, modelName: 'product' });
class User extends Model {}
User.init({
  firstName: Sequelize.STRING,
  lastName: Sequelize.STRING
}, { sequelize, modelName: 'user' });
class Address extends Model {}
Address.init({
  type: DataTypes.STRING,
  line1: Sequelize.STRING,
  line2: Sequelize.STRING,
  city: Sequelize.STRING,
  state: Sequelize.STRING,
  zip: Sequelize.STRING,
}, { sequelize, modelName: 'address' });

// We save the return values of the association setup calls to use them later
Product.User = Product.belongsTo(User);
User.Addresses = User.hasMany(Address);
// Also works for `hasOne`</code>
</code></pre><p>A new <code>Product</code>, <code>User</code>, and one or more <code>Address</code> can be created in one step in the following way:</p><pre><code class="lang-js"><code class="source-code prettyprint">return Product.create({
  title: 'Chair',
  user: {
    firstName: 'Mick',
    lastName: 'Broadstone',
    addresses: [{
      type: 'home',
      line1: '100 Main St.',
      city: 'Austin',
      state: 'TX',
      zip: '78704'
    }]
  }
}, {
  include: [{
    association: Product.User,
    include: [ User.Addresses ]
  }]
});</code>
</code></pre><p>Observe the usage of the <code>include</code> option in the <code>Product.create</code> call. That is necessary for Sequelize to understand what you are trying to create along with the association.</p><p>Note: here, our user model is called <code>user</code>, with a lowercase <code>u</code> - This means that the property in the object should also be <code>user</code>. If the name given to <code>sequelize.define</code> was <code>User</code>, the key in the object should also be <code>User</code>. Likewise for <code>addresses</code>, except it's pluralized being a <code>hasMany</code> association.</p><h2>BelongsTo association with an alias</h2><p>The previous example can be extended to support an association alias.</p><pre><code class="lang-js"><code class="source-code prettyprint">const Creator = Product.belongsTo(User, { as: 'creator' });

return Product.create({
  title: 'Chair',
  creator: {
    firstName: 'Matt',
    lastName: 'Hansen'
  }
}, {
  include: [ Creator ]
});</code>
</code></pre><h2>HasMany / BelongsToMany association</h2><p>Let's introduce the ability to associate a product with many tags. Setting up the models could look like:</p><pre><code class="lang-js"><code class="source-code prettyprint">class Tag extends Model {}
Tag.init({
  name: Sequelize.STRING
}, { sequelize, modelName: 'tag' });

Product.hasMany(Tag);
// Also works for `belongsToMany`.</code>
</code></pre><p>Now we can create a product with multiple tags in the following way:</p><pre><code class="lang-js"><code class="source-code prettyprint">Product.create({
  id: 1,
  title: 'Chair',
  tags: [
    { name: 'Alpha'},
    { name: 'Beta'}
  ]
}, {
  include: [ Tag ]
})</code>
</code></pre><p>And, we can modify this example to support an alias as well:</p><pre><code class="lang-js"><code class="source-code prettyprint">const Categories = Product.hasMany(Tag, { as: 'categories' });

Product.create({
  id: 1,
  title: 'Chair',
  categories: [
    { id: 1, name: 'Alpha' },
    { id: 2, name: 'Beta' }
  ]
}, {
  include: [{
    association: Categories,
    as: 'categories'
  }]
})</code>
</code></pre></div>
        <a data-ice="link" href="manual/creating-with-associations.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Advanced M:N Associations</h1><p>Make sure you have read the <a href="./manual/assocs.html">associations guide</a> before reading this guide.</p><p>Let's start with an example of a Many-to-Many relationship between <code>User</code> and <code>Profile</code>.</p><pre><code class="lang-js"><code class="source-code prettyprint">const User = sequelize.define('user', {
  username: DataTypes.STRING,
  points: DataTypes.INTEGER
}, { timestamps: false });
const Profile = sequelize.define('profile', {
  name: DataTypes.STRING
}, { timestamps: false });</code>
</code></pre><p>The simplest way to define the Many-to-Many relationship is:</p><pre><code class="lang-js"><code class="source-code prettyprint">User.belongsToMany(Profile, { through: 'User_Profiles' });
Profile.belongsToMany(User, { through: 'User_Profiles' });</code>
</code></pre><p>By passing a string to <code>through</code> above, we are asking Sequelize to automatically generate a model named <code>User_Profiles</code> as the <em>through table</em> (also known as junction table), with only two columns: <code>userId</code> and <code>profileId</code>. A composite unique key will be established on these two columns.</p><p>We can also define ourselves a model to be used as the through table.</p><pre><code class="lang-js"><code class="source-code prettyprint">const User_Profile = sequelize.define('User_Profile', {}, { timestamps: false });
User.belongsToMany(Profile, { through: User_Profile });
Profile.belongsToMany(User, { through: User_Profile });</code>
</code></pre><p>The above has the exact same effect. Note that we didn't define any attributes on the <code>User_Profile</code> model. The fact that we passed it into a <code>belongsToMany</code> call tells sequelize to create the two attributes <code>userId</code> and <code>profileId</code> automatically, just like other associations also cause Sequelize to automatically add a column to one of the involved models.</p><p>However, defining the model by ourselves has several advantages. We can, for example, define more columns on our through table:</p><pre><code class="lang-js"><code class="source-code prettyprint">const User_Profile = sequelize.define('User_Profile', {
  selfGranted: DataTypes.BOOLEAN
}, { timestamps: false });
User.belongsToMany(Profile, { through: User_Profile });
Profile.belongsToMany(User, { through: User_Profile });</code>
</code></pre><p>With this, we can now track an extra information at the through table, namely the <code>selfGranted</code> boolean. For example, when calling the <code>user.addProfile()</code> we can pass values for the extra columns using the <code>through</code> option.</p><p>Example:</p><pre><code class="lang-js"><code class="source-code prettyprint">const amidala = await User.create({ username: 'p4dm3', points: 1000 });
const queen = await Profile.create({ name: 'Queen' });
await amidala.addProfile(queen, { through: { selfGranted: false } });
const result = await User.findOne({
  where: { username: 'p4dm3' },
  include: Profile
});
console.log(result);</code>
</code></pre><p>Output:</p><pre><code class="lang-json"><code class="source-code prettyprint">{
  "id": 4,
  "username": "p4dm3",
  "points": 1000,
  "profiles": [
    {
      "id": 6,
      "name": "queen",
      "User_Profile": {
        "userId": 4,
        "profileId": 6,
        "selfGranted": false
      }
    }
  ]
}</code>
</code></pre><p>You can create all relationship in single <code>create</code> call too.</p><p>Example:</p><pre><code class="lang-js"><code class="source-code prettyprint">const amidala = await User.create({
  username: 'p4dm3',
  points: 1000,
  profiles: [{
    name: 'Queen',
    User_Profile: {
      selfGranted: true
    }
  }]
}, {
  include: Profile
});

const result = await User.findOne({
  where: { username: 'p4dm3' },
  include: Profile
});

console.log(result);</code>
</code></pre><p>Output:</p><pre><code class="lang-json"><code class="source-code prettyprint">{
  "id": 1,
  "username": "p4dm3",
  "points": 1000,
  "profiles": [
    {
      "id": 1,
      "name": "Queen",
      "User_Profile": {
        "selfGranted": true,
        "userId": 1,
        "profileId": 1
      }
    }
  ]
}</code>
</code></pre><p>You probably noticed that the <code>User_Profiles</code> table does not have an <code>id</code> field. As mentioned above, it has a composite unique key instead. The name of this composite unique key is chosen automatically by Sequelize but can be customized with the <code>uniqueKey</code> option:</p><pre><code class="lang-js"><code class="source-code prettyprint">User.belongsToMany(Profile, { through: User_Profiles, uniqueKey: 'my_custom_unique' });</code>
</code></pre><p>Another possibility, if desired, is to force the through table to have a primary key just like other standard tables. To do this, simply define the primary key in the model:</p><pre><code class="lang-js"><code class="source-code prettyprint">const User_Profile = sequelize.define('User_Profile', {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true,
    allowNull: false
  },
  selfGranted: DataTypes.BOOLEAN
}, { timestamps: false });
User.belongsToMany(Profile, { through: User_Profile });
Profile.belongsToMany(User, { through: User_Profile });</code>
</code></pre><p>The above will still create two columns <code>userId</code> and <code>profileId</code>, of course, but instead of setting up a composite unique key on them, the model will use its <code>id</code> column as primary key. Everything else will still work just fine.</p><h2>Through tables versus normal tables and the "Super Many-to-Many association"</h2><p>Now we will compare the usage of the last Many-to-Many setup shown above with the usual One-to-Many relationships, so that in the end we conclude with the concept of a <em>"Super Many-to-Many relationship"</em>.</p><h3>Models recap (with minor rename)</h3><p>To make things easier to follow, let's rename our <code>User_Profile</code> model to <code>grant</code>. Note that everything works in the same way as before. Our models are:</p><pre><code class="lang-js"><code class="source-code prettyprint">const User = sequelize.define('user', {
  username: DataTypes.STRING,
  points: DataTypes.INTEGER
}, { timestamps: false });

const Profile = sequelize.define('profile', {
  name: DataTypes.STRING
}, { timestamps: false });

const Grant = sequelize.define('grant', {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true,
    allowNull: false
  },
  selfGranted: DataTypes.BOOLEAN
}, { timestamps: false });</code>
</code></pre><p>We established a Many-to-Many relationship between <code>User</code> and <code>Profile</code> using the <code>Grant</code> model as the through table:</p><pre><code class="lang-js"><code class="source-code prettyprint">User.belongsToMany(Profile, { through: Grant });
Profile.belongsToMany(User, { through: Grant });</code>
</code></pre><p>This automatically added the columns <code>userId</code> and <code>profileId</code> to the <code>Grant</code> model.</p><p><strong>Note:</strong> As shown above, we have chosen to force the <code>grant</code> model to have a single primary key (called <code>id</code>, as usual). This is necessary for the <em>Super Many-to-Many relationship</em> that will be defined soon.</p><h3>Using One-to-Many relationships instead</h3><p>Instead of setting up the Many-to-Many relationship defined above, what if we did the following instead?</p><pre><code class="lang-js"><code class="source-code prettyprint">// Setup a One-to-Many relationship between User and Grant
User.hasMany(Grant);
Grant.belongsTo(User);

// Also setup a One-to-Many relationship between Profile and Grant
Profile.hasMany(Grant);
Grant.belongsTo(Profile);</code>
</code></pre><p>The result is essentially the same! This is because <code>User.hasMany(Grant)</code> and <code>Profile.hasMany(Grant)</code> will automatically add the <code>userId</code> and <code>profileId</code> columns to <code>Grant</code>, respectively.</p><p>This shows that one Many-to-Many relationship isn't very different from two One-to-Many relationships. The tables in the database look the same.</p><p>The only difference is when you try to perform an eager load with Sequelize.</p><pre><code class="lang-js"><code class="source-code prettyprint">// With the Many-to-Many approach, you can do:
User.findAll({ include: Profile });
Profile.findAll({ include: User });
// However, you can't do:
User.findAll({ include: Grant });
Profile.findAll({ include: Grant });
Grant.findAll({ include: User });
Grant.findAll({ include: Profile });

// On the other hand, with the double One-to-Many approach, you can do:
User.findAll({ include: Grant });
Profile.findAll({ include: Grant });
Grant.findAll({ include: User });
Grant.findAll({ include: Profile });
// However, you can't do:
User.findAll({ include: Profile });
Profile.findAll({ include: User });
// Although you can emulate those with nested includes, as follows:
User.findAll({
  include: {
    model: Grant,
    include: Profile
  }
}); // This emulates the `User.findAll({ include: Profile })`, however
    // the resulting object structure is a bit different. The original
    // structure has the form `user.profiles[].grant`, while the emulated
    // structure has the form `user.grants[].profiles[]`.</code>
</code></pre><h3>The best of both worlds: the Super Many-to-Many relationship</h3><p>We can simply combine both approaches shown above!</p><pre><code class="lang-js"><code class="source-code prettyprint">// The Super Many-to-Many relationship
User.belongsToMany(Profile, { through: Grant });
Profile.belongsToMany(User, { through: Grant });
User.hasMany(Grant);
Grant.belongsTo(User);
Profile.hasMany(Grant);
Grant.belongsTo(Profile);</code>
</code></pre><p>This way, we can do all kinds of eager loading:</p><pre><code class="lang-js"><code class="source-code prettyprint">// All these work:
User.findAll({ include: Profile });
Profile.findAll({ include: User });
User.findAll({ include: Grant });
Profile.findAll({ include: Grant });
Grant.findAll({ include: User });
Grant.findAll({ include: Profile });</code>
</code></pre><p>We can even perform all kinds of deeply nested includes:</p><pre><code class="lang-js"><code class="source-code prettyprint">User.findAll({
  include: [
    {
      model: Grant,
      include: [User, Profile]
    },
    {
      model: Profile,
      include: {
        model: User,
        include: {
          model: Grant,
          include: [User, Profile]
        }
      }
    }
  ]
});</code>
</code></pre><h2>Aliases and custom key names</h2><p>Similarly to the other relationships, aliases can be defined for Many-to-Many relationships.</p><p>Before proceeding, please recall <a href="./manual/assocs.html#defining-an-alias">the aliasing example for <code>belongsTo</code></a> on the <a href="./manual/assocs.html">associations guide</a>. Note that, in that case, defining an association impacts both the way includes are done (i.e. passing the association name) and the name Sequelize chooses for the foreign key (in that example, <code>leaderId</code> was created on the <code>Ship</code> model).</p><p>Defining an alias for a <code>belongsToMany</code> association also impacts the way includes are performed:</p><pre><code class="lang-js"><code class="source-code prettyprint">Product.belongsToMany(Category, { as: 'groups', through: 'product_categories' });
Category.belongsToMany(Product, { as: 'items', through: 'product_categories' });

// [...]

await Product.findAll({ include: Category }); // This doesn't work

await Product.findAll({ // This works, passing the alias
  include: {
    model: Category,
    as: 'groups'
  }
});

await Product.findAll({ include: 'groups' }); // This also works</code>
</code></pre><p>However, defining an alias here has nothing to do with the foreign key names. The names of both foreign keys created in the through table are still constructed by Sequelize based on the name of the models being associated. This can readily be seen by inspecting the generated SQL for the through table in the example above:</p><pre><code class="lang-sql"><code class="source-code prettyprint">CREATE TABLE IF NOT EXISTS `product_categories` (
  `createdAt` DATETIME NOT NULL,
  `updatedAt` DATETIME NOT NULL,
  `productId` INTEGER NOT NULL REFERENCES `products` (`id`) ON DELETE CASCADE ON UPDATE CASCADE,
  `categoryId` INTEGER NOT NULL REFERENCES `categories` (`id`) ON DELETE CASCADE ON UPDATE CASCADE,
  PRIMARY KEY (`productId`, `categoryId`)
);</code>
</code></pre><p>We can see that the foreign keys are <code>productId</code> and <code>categoryId</code>. To change these names, Sequelize accepts the options <code>foreignKey</code> and <code>otherKey</code> respectively (i.e., the <code>foreignKey</code> defines the key for the source model in the through relation, and <code>otherKey</code> defines it for the target model):</p><pre><code class="lang-js"><code class="source-code prettyprint">Product.belongsToMany(Category, {
  through: 'product_categories',
  foreignKey: 'objectId', // replaces `productId`
  otherKey: 'typeId' // replaces `categoryId`
});
Category.belongsToMany(Product, {
  through: 'product_categories',
  foreignKey: 'typeId', // replaces `categoryId`
  otherKey: 'objectId' // replaces `productId`
});</code>
</code></pre><p>Generated SQL:</p><pre><code class="lang-sql"><code class="source-code prettyprint">CREATE TABLE IF NOT EXISTS `product_categories` (
  `createdAt` DATETIME NOT NULL,
  `updatedAt` DATETIME NOT NULL,
  `objectId` INTEGER NOT NULL REFERENCES `products` (`id`) ON DELETE CASCADE ON UPDATE CASCADE,
  `typeId` INTEGER NOT NULL REFERENCES `categories` (`id`) ON DELETE CASCADE ON UPDATE CASCADE,
  PRIMARY KEY (`objectId`, `typeId`)
);</code>
</code></pre><p>As shown above, when you define a Many-to-Many relationship with two <code>belongsToMany</code> calls (which is the standard way), you should provide the <code>foreignKey</code> and <code>otherKey</code> options appropriately in both calls. If you pass these options in only one of the calls, the Sequelize behavior will be unreliable.</p><h2>Self-references</h2><p>Sequelize supports self-referential Many-to-Many relationships, intuitively:</p><pre><code class="lang-js"><code class="source-code prettyprint">Person.belongsToMany(Person, { as: 'Children', through: 'PersonChildren' })
// This will create the table PersonChildren which stores the ids of the objects.</code>
</code></pre><h2>Specifying attributes from the through table</h2><p>By default, when eager loading a many-to-many relationship, Sequelize will return data in the following structure (based on the first example in this guide):</p><pre><code class="lang-json"><code class="source-code prettyprint">// User.findOne({ include: Profile })
{
  "id": 4,
  "username": "p4dm3",
  "points": 1000,
  "profiles": [
    {
      "id": 6,
      "name": "queen",
      "grant": {
        "userId": 4,
        "profileId": 6,
        "selfGranted": false
      }
    }
  ]
}</code>
</code></pre><p>Notice that the outer object is an <code>User</code>, which has a field called <code>profiles</code>, which is a <code>Profile</code> array, such that each <code>Profile</code> comes with an extra field called <code>grant</code> which is a <code>Grant</code> instance. This is the default structure created by Sequelize when eager loading from a Many-to-Many relationship.</p><p>However, if you want only some of the attributes of the through table, you can provide an array with the attributes you want in the <code>attributes</code> option. For example, if you only want the <code>selfGranted</code> attribute from the through table:</p><pre><code class="lang-js"><code class="source-code prettyprint">User.findOne({
  include: {
    model: Profile,
    through: {
      attributes: ['selfGranted']
    }
  }
});</code>
</code></pre><p>Output:</p><pre><code class="lang-json"><code class="source-code prettyprint">{
  "id": 4,
  "username": "p4dm3",
  "points": 1000,
  "profiles": [
    {
      "id": 6,
      "name": "queen",
      "grant": {
        "selfGranted": false
      }
    }
  ]
}</code>
</code></pre><p>If you don't want the nested <code>grant</code> field at all, use <code>attributes: []</code>:</p><pre><code class="lang-js"><code class="source-code prettyprint">User.findOne({
  include: {
    model: Profile,
    through: {
      attributes: []
    }
  }
});</code>
</code></pre><p>Output:</p><pre><code class="lang-json"><code class="source-code prettyprint">{
  "id": 4,
  "username": "p4dm3",
  "points": 1000,
  "profiles": [
    {
      "id": 6,
      "name": "queen"
    }
  ]
}</code>
</code></pre><p>If you are using mixins (such as <code>user.getProfiles()</code>) instead of finder methods (such as <code>User.findAll()</code>), you have to use the <code>joinTableAttributes</code> option instead:</p><pre><code class="lang-js"><code class="source-code prettyprint">someUser.getProfiles({ joinTableAttributes: ['selfGranted'] });</code>
</code></pre><p>Output:</p><pre><code class="lang-json"><code class="source-code prettyprint">[
  {
    "id": 6,
    "name": "queen",
    "grant": {
      "selfGranted": false
    }
  }
]</code>
</code></pre><h2>Many-to-many-to-many relationships and beyond</h2><p>Consider you are trying to model a game championship. There are players and teams. Teams play games. However, players can change teams in the middle of the championship (but not in the middle of a game). So, given one specific game, there are certain teams participating in that game, and each of these teams has a set of players (for that game).</p><p>So we start by defining the three relevant models:</p><pre><code class="lang-js"><code class="source-code prettyprint">const Player = sequelize.define('Player', { username: DataTypes.STRING });
const Team = sequelize.define('Team', { name: DataTypes.STRING });
const Game = sequelize.define('Game', { name: DataTypes.INTEGER });</code>
</code></pre><p>Now, the question is: how to associate them?</p><p>First, we note that:</p><ul>
<li>One game has many teams associated to it (the ones that are playing that game);</li>
<li>One team may have participated in many games.</li>
</ul><p>The above observations show that we need a Many-to-Many relationship between Game and Team. Let's use the Super Many-to-Many relationship as explained earlier in this guide:</p><pre><code class="lang-js"><code class="source-code prettyprint">// Super Many-to-Many relationship between Game and Team
const GameTeam = sequelize.define('GameTeam', {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true,
    allowNull: false
  }
});
Team.belongsToMany(Game, { through: GameTeam });
Game.belongsToMany(Team, { through: GameTeam });
GameTeam.belongsTo(Game);
GameTeam.belongsTo(Team);
Game.hasMany(GameTeam);
Team.hasMany(GameTeam);</code>
</code></pre><p>The part about players is trickier. We note that the set of players that form a team depends not only on the team (obviously), but also on which game is being considered. Therefore, we don't want a Many-to-Many relationship between Player and Team. We also don't want a Many-to-Many relationship between Player and Game. Instead of associating a Player to any of those models, what we need is an association between a Player and something like a <em>"team-game pair constraint"</em>, since it is the pair (team plus game) that defines which players belong there. So what we are looking for turns out to be precisely the junction model, GameTeam, itself! And, we note that, since a given <em>game-team pair</em> specifies many players, and on the other hand that the same player can participate of many <em>game-team pairs</em>, we need a Many-to-Many relationship between Player and GameTeam!</p><p>To provide the greatest flexibility, let's use the Super Many-to-Many relationship construction here again:</p><pre><code class="lang-js"><code class="source-code prettyprint">// Super Many-to-Many relationship between Player and GameTeam
const PlayerGameTeam = sequelize.define('PlayerGameTeam', {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true,
    allowNull: false
  }
});
Player.belongsToMany(GameTeam, { through: PlayerGameTeam });
GameTeam.belongsToMany(Player, { through: PlayerGameTeam });
PlayerGameTeam.belongsTo(Player);
PlayerGameTeam.belongsTo(GameTeam);
Player.hasMany(PlayerGameTeam);
GameTeam.hasMany(PlayerGameTeam);</code>
</code></pre><p>The above associations achieve precisely what we want. Here is a full runnable example of this:</p><pre><code class="lang-js"><code class="source-code prettyprint">const { Sequelize, Op, Model, DataTypes } = require('sequelize');
const sequelize = new Sequelize('sqlite::memory:', {
  define: { timestamps: false } // Just for less clutter in this example
});
const Player = sequelize.define('Player', { username: DataTypes.STRING });
const Team = sequelize.define('Team', { name: DataTypes.STRING });
const Game = sequelize.define('Game', { name: DataTypes.INTEGER });

// We apply a Super Many-to-Many relationship between Game and Team
const GameTeam = sequelize.define('GameTeam', {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true,
    allowNull: false
  }
});
Team.belongsToMany(Game, { through: GameTeam });
Game.belongsToMany(Team, { through: GameTeam });
GameTeam.belongsTo(Game);
GameTeam.belongsTo(Team);
Game.hasMany(GameTeam);
Team.hasMany(GameTeam);

// We apply a Super Many-to-Many relationship between Player and GameTeam
const PlayerGameTeam = sequelize.define('PlayerGameTeam', {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true,
    allowNull: false
  }
});
Player.belongsToMany(GameTeam, { through: PlayerGameTeam });
GameTeam.belongsToMany(Player, { through: PlayerGameTeam });
PlayerGameTeam.belongsTo(Player);
PlayerGameTeam.belongsTo(GameTeam);
Player.hasMany(PlayerGameTeam);
GameTeam.hasMany(PlayerGameTeam);

(async () =&gt; {

  await sequelize.sync();
  await Player.bulkCreate([
    { username: 's0me0ne' },
    { username: 'empty' },
    { username: 'greenhead' },
    { username: 'not_spock' },
    { username: 'bowl_of_petunias' }
  ]);
  await Game.bulkCreate([
    { name: 'The Big Clash' },
    { name: 'Winter Showdown' },
    { name: 'Summer Beatdown' }
  ]);
  await Team.bulkCreate([
    { name: 'The Martians' },
    { name: 'The Earthlings' },
    { name: 'The Plutonians' }
  ]);

  // Let's start defining which teams were in which games. This can be done
  // in several ways, such as calling `.setTeams` on each game. However, for
  // brevity, we will use direct `create` calls instead, referring directly
  // to the IDs we want. We know that IDs are given in order starting from 1.
  await GameTeam.bulkCreate([
    { GameId: 1, TeamId: 1 },   // this GameTeam will get id 1
    { GameId: 1, TeamId: 2 },   // this GameTeam will get id 2
    { GameId: 2, TeamId: 1 },   // this GameTeam will get id 3
    { GameId: 2, TeamId: 3 },   // this GameTeam will get id 4
    { GameId: 3, TeamId: 2 },   // this GameTeam will get id 5
    { GameId: 3, TeamId: 3 }    // this GameTeam will get id 6
  ]);

  // Now let's specify players.
  // For brevity, let's do it only for the second game (Winter Showdown).
  // Let's say that that s0me0ne and greenhead played for The Martians, while
  // not_spock and bowl_of_petunias played for The Plutonians:
  await PlayerGameTeam.bulkCreate([
    // In 'Winter Showdown' (i.e. GameTeamIds 3 and 4):
    { PlayerId: 1, GameTeamId: 3 },   // s0me0ne played for The Martians
    { PlayerId: 3, GameTeamId: 3 },   // greenhead played for The Martians
    { PlayerId: 4, GameTeamId: 4 },   // not_spock played for The Plutonians
    { PlayerId: 5, GameTeamId: 4 }    // bowl_of_petunias played for The Plutonians
  ]);

  // Now we can make queries!
  const game = await Game.findOne({
    where: {
      name: "Winter Showdown"
    },
    include: {
      model: GameTeam,
      include: [
        {
          model: Player,
          through: { attributes: [] } // Hide unwanted `PlayerGameTeam` nested object from results
        },
        Team
      ]
    }
  });

  console.log(`Found game: "${game.name}"`);
  for (let i = 0; i &lt; game.GameTeams.length; i++) {
    const team = game.GameTeams[i].Team;
    const players = game.GameTeams[i].Players;
    console.log(`- Team "${team.name}" played game "${game.name}" with the following players:`);
    console.log(players.map(p =&gt; `--- ${p.username}`).join('\n'));
  }

})();</code>
</code></pre><p>Output:</p><pre><code class="lang-text"><code class="source-code prettyprint">Found game: "Winter Showdown"
- Team "The Martians" played game "Winter Showdown" with the following players:
--- s0me0ne
--- greenhead
- Team "The Plutonians" played game "Winter Showdown" with the following players:
--- not_spock
--- bowl_of_petunias</code>
</code></pre><p>So this is how we can achieve a <em>many-to-many-to-many</em> relationship between three models in Sequelize, by taking advantage of the Super Many-to-Many relationship technique!</p><p>This idea can be applied recursively for even more complex, <em>many-to-many-to-...-to-many</em> relationships (although at some point queries might become slow).</p></div>
        <a data-ice="link" href="manual/advanced-many-to-many.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Association Scopes</h1><p>This section concerns association scopes, which are similar but not the same as <a href="./manual/scopes.html">model scopes</a>.</p><p>Association scopes can be placed both on the associated model (the target of the association) and on the through table for Many-to-Many relationships.</p><h2>Concept</h2><p>Similarly to how a <a href="./manual/scopes.html">model scope</a> is automatically applied on the model static calls, such as <code>Model.scope('foo').findAll()</code>, an association scope is a rule (more precisely, a set of default attributes and options) that is automatically applied on instance calls from the model. Here, <em>instance calls</em> mean method calls that are called from an instance (rather than from the Model itself). Mixins are the main example of instance methods (<code>instance.getSomething</code>, <code>instance.setSomething</code>, <code>instance.addSomething</code> and <code>instance.createSomething</code>).</p><p>Association scopes behave just like model scopes, in the sense that both cause an automatic application of things like <code>where</code> clauses to finder calls; the difference being that instead of applying to static finder calls (which is the case for model scopes), the association scopes automatically apply to instance finder calls (such as mixins).</p><h2>Example</h2><p>A basic example of an association scope for the One-to-Many association between models <code>Foo</code> and <code>Bar</code> is shown below.</p><ul>
<li><p>Setup:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">  const Foo = sequelize.define('foo', { name: DataTypes.STRING });
  const Bar = sequelize.define('bar', { status: DataTypes.STRING });
  Foo.hasMany(Bar, {
      scope: {
          status: 'open'
      },
      as: 'openBars'
  });
  await sequelize.sync();
  const myFoo = await Foo.create({ name: "My Foo" });</code>
</code></pre>
</li>
<li><p>After this setup, calling <code>myFoo.getOpenBars()</code> generates the following SQL:</p>
<pre><code class="lang-sql"><code class="source-code prettyprint">  SELECT
      `id`, `status`, `createdAt`, `updatedAt`, `fooId`
  FROM `bars` AS `bar`
  WHERE `bar`.`status` = 'open' AND `bar`.`fooId` = 1;</code>
</code></pre>
</li>
</ul><p>With this we can see that upon calling the <code>.getOpenBars()</code> mixin, the association scope <code>{ status: 'open' }</code> was automatically applied into the <code>WHERE</code> clause of the generated SQL.</p><h2>Achieving the same behavior with standard scopes</h2><p>We could have achieved the same behavior with standard scopes:</p><pre><code class="lang-js"><code class="source-code prettyprint">// Foo.hasMany(Bar, {
//     scope: {
//         status: 'open'
//     },
//     as: 'openBars'
// });

Bar.addScope('open', {
    where: {
        status: 'open'
    }
});
Foo.hasMany(Bar);
Foo.hasMany(Bar.scope('open'), { as: 'openBars' });</code>
</code></pre><p>With the above code, <code>myFoo.getOpenBars()</code> yields the same SQL shown above.</p></div>
        <a data-ice="link" href="manual/association-scopes.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Polymorphic Associations</h1><p><em><strong>Note:</strong> the usage of polymorphic associations in Sequelize, as outlined in this guide, should be done with caution. Don't just copy-paste code from here, otherwise you might easily make mistakes and introduce bugs in your code. Make sure you understand what is going on.</em></p><h2>Concept</h2><p>A <strong>polymorphic association</strong> consists on two (or more) associations happening with the same foreign key.</p><p>For example, consider the models <code>Image</code>, <code>Video</code> and <code>Comment</code>. The first two represent something that a user might post. We want to allow comments to be placed in both of them. This way, we immediately think of establishing the following associations:</p><ul>
<li><p>A One-to-Many association between <code>Image</code> and <code>Comment</code>:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">Image.hasMany(Comment);
Comment.belongsTo(Image);</code>
</code></pre>
</li>
<li><p>A One-to-Many association between <code>Video</code> and <code>Comment</code>:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">Video.hasMany(Comment);
Comment.belongsTo(Video);</code>
</code></pre>
</li>
</ul><p>However, the above would cause Sequelize to create two foreign keys on the <code>Comment</code> table: <code>ImageId</code> and <code>VideoId</code>. This is not ideal because this structure makes it look like a comment can be attached at the same time to one image and one video, which isn't true. Instead, what we really want here is precisely a polymorphic association, in which a <code>Comment</code> points to a single <strong>Commentable</strong>, an abstract polymorphic entity that represents one of <code>Image</code> or <code>Video</code>.</p><p>Before proceeding to how to configure such an association, let's see how using it looks like:</p><pre><code class="lang-js"><code class="source-code prettyprint">const image = await Image.create({ url: "https://placekitten.com/408/287" });
const comment = await image.createComment({ content: "Awesome!" });

console.log(comment.commentableId === image.id); // true

// We can also retrieve which type of commentable a comment is associated to.
// The following prints the model name of the associated commentable instance.
console.log(comment.commentableType); // "Image"

// We can use a polymorphic method to retrieve the associated commentable, without
// having to worry whether it's an Image or a Video.
const associatedCommentable = await comment.getCommentable();

// In this example, `associatedCommentable` is the same thing as `image`:
const isDeepEqual = require('deep-equal');
console.log(isDeepEqual(image, commentable)); // true</code>
</code></pre><h2>Configuring a One-to-Many polymorphic association</h2><p>To setup the polymorphic association for the example above (which is an example of One-to-Many polymorphic association), we have the following steps:</p><ul>
<li>Define a string field called <code>commentableType</code> in the <code>Comment</code> model;</li>
<li>Define the <code>hasMany</code> and <code>belongsTo</code> association between <code>Image</code>/<code>Video</code> and <code>Comment</code>:<ul>
<li>Disabling constraints (i.e. using <code>{ constraints: false }</code>), since the same foreign key is referencing multiple tables;</li>
<li>Specifying the appropriate <a href="./manual/association-scopes.html">association scopes</a>;</li>
</ul>
</li>
<li>To properly support lazy loading, define a new instance method on the <code>Comment</code> model called <code>getCommentable</code> which calls, under the hood, the correct mixin to fetch the appropriate commentable;</li>
<li>To properly support eager loading, define an <code>afterFind</code> hook on the <code>Comment</code> model that automatically populates the <code>commentable</code> field in every instance;</li>
<li>To prevent bugs/mistakes in eager loading, you can also delete the concrete fields <code>image</code> and <code>video</code> from Comment instances in the same <code>afterFind</code> hook, leaving only the abstract <code>commentable</code> field available.</li>
</ul><p>Here is an example:</p><pre><code class="lang-js"><code class="source-code prettyprint">// Helper function
const uppercaseFirst = str =&gt; `${str[0].toUpperCase()}${str.substr(1)}`;

class Image extends Model {}
Image.init({
  title: DataTypes.STRING,
  url: DataTypes.STRING
}, { sequelize, modelName: 'image' });

class Video extends Model {}
Video.init({
  title: DataTypes.STRING,
  text: DataTypes.STRING
}, { sequelize, modelName: 'video' });

class Comment extends Model {
  getCommentable(options) {
    if (!this.commentableType) return Promise.resolve(null);
    const mixinMethodName = `get${uppercaseFirst(this.commentableType)}`;
    return this[mixinMethodName](options);
  }
}
Comment.init({
  title: DataTypes.STRING,
  commentableId: DataTypes.INTEGER,
  commentableType: DataTypes.STRING
}, { sequelize, modelName: 'comment' });

Image.hasMany(Comment, {
  foreignKey: 'commentableId',
  constraints: false,
  scope: {
    commentableType: 'image'
  }
});
Comment.belongsTo(Image, { foreignKey: 'commentableId', constraints: false });

Video.hasMany(Comment, {
  foreignKey: 'commentableId',
  constraints: false,
  scope: {
    commentableType: 'video'
  }
});
Comment.belongsTo(Video, { foreignKey: 'commentableId', constraints: false });

Comment.addHook("afterFind", findResult =&gt; {
  if (!Array.isArray(findResult)) findResult = [findResult];
  for (const instance of findResult) {
    if (instance.commentableType === "image" &amp;&amp; instance.image !== undefined) {
      instance.commentable = instance.image;
    } else if (instance.commentableType === "video" &amp;&amp; instance.video !== undefined) {
      instance.commentable = instance.video;
    }
    // To prevent mistakes:
    delete instance.image;
    delete instance.dataValues.image;
    delete instance.video;
    delete instance.dataValues.video;
  }
});</code>
</code></pre><p>Since the <code>commentableId</code> column references several tables (two in this case), we cannot add a <code>REFERENCES</code> constraint to it. This is why the <code>constraints: false</code> option was used.</p><p>Note that, in the code above:</p><ul>
<li>The <em>Image -&gt; Comment</em> association defined an association scope: <code>{ commentableType: 'image' }</code></li>
<li>The <em>Video -&gt; Comment</em> association defined an association scope: <code>{ commentableType: 'video' }</code></li>
</ul><p>These scopes are automatically applied when using the association functions (as explained in the <a href="./manual/association-scopes.html">Association Scopes</a> guide). Some examples are below, with their generated SQL statements:</p><ul>
<li><p><code>image.getComments()</code>:</p>
<pre><code class="lang-sql"><code class="source-code prettyprint">SELECT "id", "title", "commentableType", "commentableId", "createdAt", "updatedAt"
FROM "comments" AS "comment"
WHERE "comment"."commentableType" = 'image' AND "comment"."commentableId" = 1;</code>
</code></pre>
<p>Here we can see that <code>`comment`.`commentableType` = 'image'</code> was automatically added to the <code>WHERE</code> clause of the generated SQL. This is exactly the behavior we want.</p>
</li>
<li><p><code>image.createComment({ title: 'Awesome!' })</code>:</p>
<pre><code class="lang-sql"><code class="source-code prettyprint">INSERT INTO "comments" (
  "id", "title", "commentableType", "commentableId", "createdAt", "updatedAt"
) VALUES (
  DEFAULT, 'Awesome!', 'image', 1,
  '2018-04-17 05:36:40.454 +00:00', '2018-04-17 05:36:40.454 +00:00'
) RETURNING *;</code>
</code></pre>
</li>
<li><p><code>image.addComment(comment)</code>:</p>
<pre><code class="lang-sql"><code class="source-code prettyprint">UPDATE "comments"
SET "commentableId"=1, "commentableType"='image', "updatedAt"='2018-04-17 05:38:43.948 +00:00'
WHERE "id" IN (1)</code>
</code></pre>
</li>
</ul><h3>Polymorphic lazy loading</h3><p>The <code>getCommentable</code> instance method on <code>Comment</code> provides an abstraction for lazy loading the associated commentable - working whether the comment belongs to an Image or a Video.</p><p>It works by simply converting the <code>commentableType</code> string into a call to the correct mixin (either <code>getImage</code> or <code>getVideo</code>).</p><p>Note that the <code>getCommentable</code> implementation above:</p><ul>
<li>Returns <code>null</code> when no association is present (which is good);</li>
<li>Allows you to pass an options object to <code>getCommentable(options)</code>, just like any other standard Sequelize method. This is useful to specify where-conditions or includes, for example.</li>
</ul><h3>Polymorphic eager loading</h3><p>Now, we want to perform a polymorphic eager loading of the associated commentables for one (or more) comments. We want to achieve something similar to the following idea:</p><pre><code class="lang-js"><code class="source-code prettyprint">const comment = await Comment.findOne({
  include: [ /* What to put here? */ ]
});
console.log(comment.commentable); // This is our goal</code>
</code></pre><p>The solution is to tell Sequelize to include both Images and Videos, so that our <code>afterFind</code> hook defined above will do the work, automatically adding the <code>commentable</code> field to the instance object, providing the abstraction we want.</p><p>For example:</p><pre><code class="lang-js"><code class="source-code prettyprint">const comments = await Comment.findAll({
  include: [Image, Video]
});
for (const comment of comments) {
  const message = `Found comment #${comment.id} with ${comment.commentableType} commentable:`;
  console.log(message, comment.commentable.toJSON());
}</code>
</code></pre><p>Output example:</p><pre><code class="lang-text"><code class="source-code prettyprint">Found comment #1 with image commentable: { id: 1,
  title: 'Meow',
  url: 'https://placekitten.com/408/287',
  createdAt: 2019-12-26T15:04:53.047Z,
  updatedAt: 2019-12-26T15:04:53.047Z }</code>
</code></pre><h3>Caution - possibly invalid eager/lazy loading!</h3><p>Consider a comment <code>Foo</code> whose <code>commentableId</code> is 2 and <code>commentableType</code> is <code>image</code>. Consider also that <code>Image A</code> and <code>Video X</code> both happen to have an id equal to 2. Conceptually, it is clear that <code>Video X</code> is not associated to <code>Foo</code>, because even though its id is 2, the <code>commentableType</code> of <code>Foo</code> is <code>image</code>, not <code>video</code>. However, this distinction is made by Sequelize only at the level of the abstractions performed by <code>getCommentable</code> and the hook we created above.</p><p>This means that if you call <code>Comment.findAll({ include: Video })</code> in the situation above, <code>Video X</code> will be eager loaded into <code>Foo</code>. Thankfully, our <code>afterFind</code> hook will delete it automatically, to help prevent bugs, but regardless it is important that you understand what is going on.</p><p>The best way to prevent this kind of mistake is to <strong>avoid using the concrete accessors and mixins directly at all costs</strong> (such as <code>.image</code>, <code>.getVideo()</code>, <code>.setImage()</code>, etc), always preferring the abstractions we created, such as <code>.getCommentable()</code> and <code>.commentable</code>. If you really need to access eager-loaded <code>.image</code> and <code>.video</code> for some reason, make sure you wrap that in a type check such as <code>comment.commentableType === 'image'</code>.</p><h2>Configuring a Many-to-Many polymorphic association</h2><p>In the above example, we had the models <code>Image</code> and <code>Video</code> being abstractly called <em>commentables</em>, with one <em>commentable</em> having many comments. However, one given comment would belong to a single <em>commentable</em> - this is why the whole situation is a One-to-Many polymorphic association.</p><p>Now, to consider a Many-to-Many polymorphic association, instead of considering comments, we will consider tags. For convenience, instead of calling Image and Video as <em>commentables</em>, we will now call them <em>taggables</em>. One <em>taggable</em> may have several tags, and at the same time one tag can be placed in several <em>taggables</em>.</p><p>The setup for this goes as follows:</p><ul>
<li>Define the junction model explicitly, specifying the two foreign keys as <code>tagId</code> and <code>taggableId</code> (this way it is a junction model for a Many-to-Many relationship between <code>Tag</code> and the abstract concept of <em>taggable</em>);</li>
<li>Define a string field called <code>taggableType</code> in the junction model;</li>
<li>Define the <code>belongsToMany</code> associations between the two models and <code>Tag</code>:<ul>
<li>Disabling constraints (i.e. using <code>{ constraints: false }</code>), since the same foreign key is referencing multiple tables;</li>
<li>Specifying the appropriate <a href="./manual/association-scopes.html">association scopes</a>;</li>
</ul>
</li>
<li>Define a new instance method on the <code>Tag</code> model called <code>getTaggables</code> which calls, under the hood, the correct mixin to fetch the appropriate taggables.</li>
</ul><p>Implementation:</p><pre><code class="lang-js"><code class="source-code prettyprint">class Tag extends Model {
  getTaggables(options) {
    const images = await this.getImages(options);
    const videos = await this.getVideos(options);
    // Concat images and videos in a single array of taggables
    return images.concat(videos);
  }
}
Tag.init({
  name: DataTypes.STRING
}, { sequelize, modelName: 'tag' });

// Here we define the junction model explicitly
class Tag_Taggable extends Model {}
Tag_Taggable.init({
  tagId: {
    type: DataTypes.INTEGER,
    unique: 'tt_unique_constraint'
  },
  taggableId: {
    type: DataTypes.INTEGER,
    unique: 'tt_unique_constraint',
    references: null
  },
  taggableType: {
    type: DataTypes.STRING,
    unique: 'tt_unique_constraint'
  }
}, { sequelize, modelName: 'tag_taggable' });

Image.belongsToMany(Tag, {
  through: {
    model: Tag_Taggable,
    unique: false,
    scope: {
      taggableType: 'image'
    }
  },
  foreignKey: 'taggableId',
  constraints: false
});
Tag.belongsToMany(Image, {
  through: {
    model: Tag_Taggable,
    unique: false
  },
  foreignKey: 'tagId',
  constraints: false
});

Video.belongsToMany(Tag, {
  through: {
    model: Tag_Taggable,
    unique: false,
    scope: {
      taggableType: 'video'
    }
  },
  foreignKey: 'taggableId',
  constraints: false
});
Tag.belongsToMany(Video, {
  through: {
    model: Tag_Taggable,
    unique: false
  },
  foreignKey: 'tagId',
  constraints: false
});</code>
</code></pre><p>The <code>constraints: false</code> option disables references constraints, as the <code>taggableId</code> column references several tables, we cannot add a <code>REFERENCES</code> constraint to it.</p><p>Note that:</p><ul>
<li>The <em>Image -&gt; Tag</em> association defined an association scope: <code>{ taggableType: 'image' }</code></li>
<li>The <em>Video -&gt; Tag</em> association defined an association scope: <code>{ taggableType: 'video' }</code></li>
</ul><p>These scopes are automatically applied when using the association functions. Some examples are below, with their generated SQL statements:</p><ul>
<li><p><code>image.getTags()</code>:</p>
<pre><code class="lang-sql"><code class="source-code prettyprint">SELECT
  `tag`.`id`,
  `tag`.`name`,
  `tag`.`createdAt`,
  `tag`.`updatedAt`,
  `tag_taggable`.`tagId` AS `tag_taggable.tagId`,
  `tag_taggable`.`taggableId` AS `tag_taggable.taggableId`,
  `tag_taggable`.`taggableType` AS `tag_taggable.taggableType`,
  `tag_taggable`.`createdAt` AS `tag_taggable.createdAt`,
  `tag_taggable`.`updatedAt` AS `tag_taggable.updatedAt`
FROM `tags` AS `tag`
INNER JOIN `tag_taggables` AS `tag_taggable` ON
  `tag`.`id` = `tag_taggable`.`tagId` AND
  `tag_taggable`.`taggableId` = 1 AND
  `tag_taggable`.`taggableType` = 'image';</code>
</code></pre>
<p>Here we can see that <code>`tag_taggable`.`taggableType` = 'image'</code> was automatically added to the <code>WHERE</code> clause of the generated SQL. This is exactly the behavior we want.</p>
</li>
<li><p><code>tag.getTaggables()</code>:</p>
<pre><code class="lang-sql"><code class="source-code prettyprint">SELECT
  `image`.`id`,
  `image`.`url`,
  `image`.`createdAt`,
  `image`.`updatedAt`,
  `tag_taggable`.`tagId` AS `tag_taggable.tagId`,
  `tag_taggable`.`taggableId` AS `tag_taggable.taggableId`,
  `tag_taggable`.`taggableType` AS `tag_taggable.taggableType`,
  `tag_taggable`.`createdAt` AS `tag_taggable.createdAt`,
  `tag_taggable`.`updatedAt` AS `tag_taggable.updatedAt`
FROM `images` AS `image`
INNER JOIN `tag_taggables` AS `tag_taggable` ON
  `image`.`id` = `tag_taggable`.`taggableId` AND
  `tag_taggable`.`tagId` = 1;

SELECT
  `video`.`id`,
  `video`.`url`,
  `video`.`createdAt`,
  `video`.`updatedAt`,
  `tag_taggable`.`tagId` AS `tag_taggable.tagId`,
  `tag_taggable`.`taggableId` AS `tag_taggable.taggableId`,
  `tag_taggable`.`taggableType` AS `tag_taggable.taggableType`,
  `tag_taggable`.`createdAt` AS `tag_taggable.createdAt`,
  `tag_taggable`.`updatedAt` AS `tag_taggable.updatedAt`
FROM `videos` AS `video`
INNER JOIN `tag_taggables` AS `tag_taggable` ON
  `video`.`id` = `tag_taggable`.`taggableId` AND
  `tag_taggable`.`tagId` = 1;</code>
</code></pre>
</li>
</ul><p>Note that the above implementation of <code>getTaggables()</code> allows you to pass an options object to <code>getCommentable(options)</code>, just like any other standard Sequelize method. This is useful to specify where-conditions or includes, for example.</p><h3>Applying scopes on the target model</h3><p>In the example above, the <code>scope</code> options (such as <code>scope: { taggableType: 'image' }</code>) were applied to the <em>through</em> model, not the <em>target</em> model, since it was used under the <code>through</code> option.</p><p>We can also apply an association scope on the target model. We can even do both at the same time.</p><p>To illustrate this, consider an extension of the above example between tags and taggables, where each tag has a status. This way, to get all pending tags of an image, we could establish another <code>belognsToMany</code> relationship between <code>Image</code> and <code>Tag</code>, this time applying a scope on the through model and another scope on the target model:</p><pre><code class="lang-js"><code class="source-code prettyprint">Image.belongsToMany(Tag, {
  through: {
    model: Tag_Taggable,
    unique: false,
    scope: {
      taggableType: 'image'
    }
  },
  scope: {
    status: 'pending'
  },
  as: 'pendingTags',
  foreignKey: 'taggableId',
  constraints: false
});</code>
</code></pre><p>This way, when calling <code>image.getPendingTags()</code>, the following SQL query will be generated:</p><pre><code class="lang-sql"><code class="source-code prettyprint">SELECT
  `tag`.`id`,
  `tag`.`name`,
  `tag`.`status`,
  `tag`.`createdAt`,
  `tag`.`updatedAt`,
  `tag_taggable`.`tagId` AS `tag_taggable.tagId`,
  `tag_taggable`.`taggableId` AS `tag_taggable.taggableId`,
  `tag_taggable`.`taggableType` AS `tag_taggable.taggableType`,
  `tag_taggable`.`createdAt` AS `tag_taggable.createdAt`,
  `tag_taggable`.`updatedAt` AS `tag_taggable.updatedAt`
FROM `tags` AS `tag`
INNER JOIN `tag_taggables` AS `tag_taggable` ON
  `tag`.`id` = `tag_taggable`.`tagId` AND
  `tag_taggable`.`taggableId` = 1 AND
  `tag_taggable`.`taggableType` = 'image'
WHERE (
  `tag`.`status` = 'pending'
);</code>
</code></pre><p>We can see that both scopes were applied automatically:</p><ul>
<li><code>`tag_taggable`.`taggableType` = 'image'</code> was added automatically to the <code>INNER JOIN</code>;</li>
<li><code>`tag`.`status` = 'pending'</code> was added automatically to an outer where clause.</li>
</ul></div>
        <a data-ice="link" href="manual/polymorphic-associations.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Dialect-Specific Things</h1><h2>Underlying Connector Libraries</h2><h3>MySQL</h3><p>The underlying connector library used by Sequelize for MySQL is the <a href="https://www.npmjs.com/package/mysql2">mysql2</a> npm package (version 1.5.2 or higher).</p><p>You can provide custom options to it using the <code>dialectOptions</code> in the Sequelize constructor:</p><pre><code class="lang-js"><code class="source-code prettyprint">const sequelize = new Sequelize('database', 'username', 'password', {
  dialect: 'mysql',
  dialectOptions: {
    // Your mysql2 options here
  }
})</code>
</code></pre><p><code>dialectOptions</code> are passed directly to the MySQL connection constructor. A full list of options can be found in the <a href="https://www.npmjs.com/package/mysql#connection-options">MySQL docs</a>.</p><h3>MariaDB</h3><p>The underlying connector library used by Sequelize for MariaDB is the <a href="https://www.npmjs.com/package/mariadb">mariadb</a> npm package.</p><p>You can provide custom options to it using the <code>dialectOptions</code> in the Sequelize constructor:</p><pre><code class="lang-js"><code class="source-code prettyprint">const sequelize = new Sequelize('database', 'username', 'password', {
  dialect: 'mariadb',
  dialectOptions: {
    // Your mariadb options here
    // connectTimeout: 1000
  }
});</code>
</code></pre><p><code>dialectOptions</code> are passed directly to the MariaDB connection constructor. A full list of options can be found in the <a href="https://mariadb.com/kb/en/nodejs-connection-options/">MariaDB docs</a>.</p><h3>SQLite</h3><p>The underlying connector library used by Sequelize for SQLite is the <a href="https://www.npmjs.com/package/sqlite3">sqlite3</a> npm package (version 4.0.0 or above).</p><p>You specify the storage file in the Sequelize constructor with the <code>storage</code> option (use <code>:memory:</code> for an in-memory SQLite instance).</p><p>You can provide custom options to it using the <code>dialectOptions</code> in the Sequelize constructor:</p><pre><code class="lang-js"><code class="source-code prettyprint">const sequelize = new Sequelize('database', 'username', 'password', {
  dialect: 'sqlite',
  storage: 'path/to/database.sqlite' // or ':memory:'
  dialectOptions: {
    // Your sqlite3 options here
  }
});</code>
</code></pre><p>The following fields may be passed to SQLite <code>dialectOptions</code>:</p><ul>
<li><code>readWriteMode</code>: Set the opening mode for the SQLite connection. Potential values are provided by the sqlite3 package, and can include sqlite3.OPEN_READONLY, sqlite3.OPEN_READWRITE, or sqlite3.OPEN_CREATE. See the <a href="https://www.sqlite.org/c3ref/open.html">SQLite C interface documentation for more details</a>.</li>
</ul><h3>PostgreSQL</h3><p>The underlying connector library used by Sequelize for PostgreSQL is the <a href="https://www.npmjs.com/package/pg">pg</a> package (for Node 10 &amp; 12, use pg version 7.0.0 or above. For Node 14 and above you need to use pg version 8.2.x or above, as per <a href="https://node-postgres.com/#version-compatibility">the pg documentation</a>). The module <a href="https://www.npmjs.com/package/pg-hstore">pg-hstore</a> is also necessary.</p><p>You can provide custom options to it using the <code>dialectOptions</code> in the Sequelize constructor:</p><pre><code class="lang-js"><code class="source-code prettyprint">const sequelize = new Sequelize('database', 'username', 'password', {
  dialect: 'postgres',
  dialectOptions: {
    // Your pg options here
  }
});</code>
</code></pre><p>The following fields may be passed to Postgres <code>dialectOptions</code>:</p><ul>
<li><code>application_name</code>: Name of application in pg_stat_activity. See the <a href="https://www.postgresql.org/docs/current/runtime-config-logging.html#GUC-APPLICATION-NAME">Postgres docs</a> for details.</li>
<li><code>ssl</code>: SSL options. See the <a href="https://node-postgres.com/features/ssl"><code>pg</code> docs</a> for details.</li>
<li><code>client_encoding</code>: // Setting 'auto' determines locale based on the client LC_CTYPE environment variable. See the <a href="https://www.postgresql.org/docs/current/multibyte.html">Postgres docs</a> for details.</li>
<li><code>keepAlive</code>: Boolean to enable TCP KeepAlive. See the <a href="https://github.com/brianc/node-postgres/blob/master/CHANGELOG.md#v600"><code>pg</code> changelog</a> for details.</li>
<li><code>statement_timeout</code>: Times out queries after a set time in milliseconds. Added in pg v7.3. See the <a href="https://www.postgresql.org/docs/current/runtime-config-client.html#GUC-STATEMENT-TIMEOUT">Postgres docs</a> for details.</li>
<li><code>idle_in_transaction_session_timeout</code>: Terminate any session with an open transaction that has been idle for longer than the specified duration in milliseconds. See the <a href="https://www.postgresql.org/docs/current/runtime-config-client.html#GUC-IDLE-IN-TRANSACTION-SESSION-TIMEOUT">Postgres docs</a> for details.</li>
</ul><p>To connect over a unix domain socket, specify the path to the socket directory in the <code>host</code> option. The socket path must start with <code>/</code>.</p><pre><code class="lang-js"><code class="source-code prettyprint">const sequelize = new Sequelize('database', 'username', 'password', {
  dialect: 'postgres',
  host: '/path/to/socket_directory'
});</code>
</code></pre><p>The default <code>client_min_messages</code> config in sequelize is <code>WARNING</code>.</p><h3>Redshift</h3><p>Most configuration is same as PostgreSQL above.</p><p>Redshift doesn't support <code>client_min_messages</code>, 'ignore' is needed to skip the configuration:</p><pre><code class="lang-js"><code class="source-code prettyprint">const sequelize = new Sequelize('database', 'username', 'password', {
  dialect: 'postgres',
  dialectOptions: {
    // Your pg options here
    // ...
    clientMinMessages: 'ignore' // case insensitive
  }
});</code>
</code></pre><h3>MSSQL</h3><p>The underlying connector library used by Sequelize for MSSQL is the <a href="https://www.npmjs.com/package/tedious">tedious</a> npm package (version 6.0.0 or above).</p><p>You can provide custom options to it using <code>dialectOptions.options</code> in the Sequelize constructor:</p><pre><code class="lang-js"><code class="source-code prettyprint">const sequelize = new Sequelize('database', 'username', 'password', {
  dialect: 'mssql',
  dialectOptions: {
    // Observe the need for this nested `options` field for MSSQL
    options: {
      // Your tedious options here
      useUTC: false,
      dateFirst: 1
    }
  }
});</code>
</code></pre><p>A full list of options can be found in the <a href="https://tediousjs.github.io/tedious/api-connection.html#function_newConnection">tedious docs</a>.</p><h4>MSSQL Domain Account</h4><p>In order to connect with a domain account, use the following format.</p><pre><code class="lang-js"><code class="source-code prettyprint">const sequelize = new Sequelize('database', null, null, {
  dialect: 'mssql',
  dialectOptions: {
    authentication: {
      type: 'ntlm',
      options: {
        domain: 'yourDomain',
        userName: 'username',
        password: 'password'
      }
    },
    options: {
      instanceName: 'SQLEXPRESS'
    }
  }
})</code>
</code></pre><h3>Snowflake (Experiment)</h3><p>The underlying connector library used by Sequelize for Snowflake is the <a href="https://www.npmjs.com/package/snowflake-sdk">snowflake-sdk</a> npm package.</p><p>In order to connect with an account, use the following format:</p><pre><code class="lang-js"><code class="source-code prettyprint">const sequelize = new Sequelize('database', null, null, {
  dialect: 'snowflake',
  dialectOptions: {
    // put your snowflake account here,
    account: 'myAccount',  // my-app.us-east-1

    // below option should be optional
    role: 'myRole',
    warehouse: 'myWarehouse',
    schema: 'mySchema'
  },
  // same as other dialect
  username: 'myUserName',
  password: 'myPassword',
  database: 'myDatabaseName'
})</code>
</code></pre><p><strong>NOTE</strong> There is no test sandbox provided so the snowflake integration test is not part of the pipeline. Also it is difficult for core team to triage and debug. This dialect needs to be maintained by the snowflake user/community for now.</p><p>For running integration test:</p><pre><code class="lang-sh"><code class="source-code prettyprint">SEQ_ACCOUNT=myAccount SEQ_USER=myUser SEQ_PW=myPassword SEQ_ROLE=myRole SEQ_DB=myDatabaseName SEQ_SCHEMA=mySchema SEQ_WH=myWareHouse npm run test-integration-snowflake</code>
</code></pre><h2>Data type: TIMESTAMP WITHOUT TIME ZONE - PostgreSQL only</h2><p>If you are working with the PostgreSQL <code>TIMESTAMP WITHOUT TIME ZONE</code> and you need to parse it to a different timezone, please use the pg library's own parser:</p><pre><code class="lang-js"><code class="source-code prettyprint">require('pg').types.setTypeParser(1114, stringValue =&gt; {
  return new Date(stringValue + '+0000');
  // e.g., UTC offset. Use any offset that you would like.
});</code>
</code></pre><h2>Data type: ARRAY(ENUM) - PostgreSQL only</h2><p>Array(Enum) type requireS special treatment. Whenever Sequelize will talk to the database, it has to typecast array values with ENUM name.</p><p>So this enum name must follow this pattern <code>enum_&lt;table_name&gt;_&lt;col_name&gt;</code>. If you are using <code>sync</code> then correct name will automatically be generated.</p><h2>Table Hints - MSSQL only</h2><p>The <code>tableHint</code> option can be used to define a table hint. The hint must be a value from <code>TableHints</code> and should only be used when absolutely necessary. Only a single table hint is currently supported per query.</p><p>Table hints override the default behavior of MSSQL query optimizer by specifing certain options. They only affect the table or view referenced in that clause.</p><pre><code class="lang-js"><code class="source-code prettyprint">const { TableHints } = require('sequelize');
Project.findAll({
  // adding the table hint NOLOCK
  tableHint: TableHints.NOLOCK
  // this will generate the SQL 'WITH (NOLOCK)'
})</code>
</code></pre><h2>Index Hints - MySQL/MariaDB only</h2><p>The <code>indexHints</code> option can be used to define index hints. The hint type must be a value from <code>IndexHints</code> and the values should reference existing indexes.</p><p>Index hints <a href="https://dev.mysql.com/doc/refman/5.7/en/index-hints.html">override the default behavior of the MySQL query optimizer</a>.</p><pre><code class="lang-js"><code class="source-code prettyprint">const { IndexHints } = require("sequelize");
Project.findAll({
  indexHints: [
    { type: IndexHints.USE, values: ['index_project_on_name'] }
  ],
  where: {
    id: {
      [Op.gt]: 623
    },
    name: {
      [Op.like]: 'Foo %'
    }
  }
});</code>
</code></pre><p>The above will generate a MySQL query that looks like this:</p><pre><code class="lang-sql"><code class="source-code prettyprint">SELECT * FROM Project USE INDEX (index_project_on_name) WHERE name LIKE 'FOO %' AND id &gt; 623;</code>
</code></pre><p><code>Sequelize.IndexHints</code> includes <code>USE</code>, <code>FORCE</code>, and <code>IGNORE</code>.</p><p>See <a href="https://github.com/sequelize/sequelize/issues/9421">Issue #9421</a> for the original API proposal.</p><h2>Engines - MySQL/MariaDB only</h2><p>The default engine for a model is InnoDB.</p><p>You can change the engine for a model with the <code>engine</code> option (e.g., to MyISAM):</p><pre><code class="lang-js"><code class="source-code prettyprint">const Person = sequelize.define('person', { /* attributes */ }, {
  engine: 'MYISAM'
});</code>
</code></pre><p>Like every option for the definition of a model, this setting can also be changed globally with the <code>define</code> option of the Sequelize constructor:</p><pre><code class="lang-js"><code class="source-code prettyprint">const sequelize = new Sequelize(db, user, pw, {
  define: { engine: 'MYISAM' }
})</code>
</code></pre><h2>Table comments - MySQL/MariaDB/PostgreSQL only</h2><p>You can specify a comment for a table when defining the model:</p><pre><code class="lang-js"><code class="source-code prettyprint">class Person extends Model {}
Person.init({ /* attributes */ }, {
  comment: "I'm a table comment!",
  sequelize
})</code>
</code></pre><p>The comment will be set when calling <code>sync()</code>.</p></div>
        <a data-ice="link" href="manual/dialect-specific-things.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Transactions</h1><p>Sequelize does not use <a href="https://en.wikipedia.org/wiki/Database_transaction">transactions</a> by default. However, for production-ready usage of Sequelize, you should definitely configure Sequelize to use transactions.</p><p>Sequelize supports two ways of using transactions:</p><ol>
<li><p><strong>Unmanaged transactions:</strong> Committing and rolling back the transaction should be done manually by the user (by calling the appropriate Sequelize methods).</p>
</li>
<li><p><strong>Managed transactions</strong>: Sequelize will automatically rollback the transaction if any error is thrown, or commit the transaction otherwise. Also, if CLS (Continuation Local Storage) is enabled, all queries within the transaction callback will automatically receive the transaction object.</p>
</li>
</ol><h2>Unmanaged transactions</h2><p>Let's start with an example:</p><pre><code class="lang-js"><code class="source-code prettyprint">// First, we start a transaction and save it into a variable
const t = await sequelize.transaction();

try {

  // Then, we do some calls passing this transaction as an option:

  const user = await User.create({
    firstName: 'Bart',
    lastName: 'Simpson'
  }, { transaction: t });

  await user.addSibling({
    firstName: 'Lisa',
    lastName: 'Simpson'
  }, { transaction: t });

  // If the execution reaches this line, no errors were thrown.
  // We commit the transaction.
  await t.commit();

} catch (error) {

  // If the execution reaches this line, an error was thrown.
  // We rollback the transaction.
  await t.rollback();

}</code>
</code></pre><p>As shown above, the <em>unmanaged transaction</em> approach requires that you commit and rollback the transaction manually, when necessary.</p><h2>Managed transactions</h2><p>Managed transactions handle committing or rolling back the transaction automatically. You start a managed transaction by passing a callback to <code>sequelize.transaction</code>. This callback can be <code>async</code> (and usually is).</p><p>The following will happen in this case:</p><ul>
<li>Sequelize will automatically start a transaction and obtain a transaction object <code>t</code></li>
<li>Then, Sequelize will execute the callback you provided, passing <code>t</code> into it</li>
<li>If your callback throws, Sequelize will automatically rollback the transaction</li>
<li>If your callback succeeds, Sequelize will automatically commit the transaction</li>
<li>Only then the <code>sequelize.transaction</code> call will settle:<ul>
<li>Either resolving with the resolution of your callback</li>
<li>Or, if your callback throws, rejecting with the thrown error</li>
</ul>
</li>
</ul><p>Example code:</p><pre><code class="lang-js"><code class="source-code prettyprint">try {

  const result = await sequelize.transaction(async (t) =&gt; {

    const user = await User.create({
      firstName: 'Abraham',
      lastName: 'Lincoln'
    }, { transaction: t });

    await user.setShooter({
      firstName: 'John',
      lastName: 'Boothe'
    }, { transaction: t });

    return user;

  });

  // If the execution reaches this line, the transaction has been committed successfully
  // `result` is whatever was returned from the transaction callback (the `user`, in this case)

} catch (error) {

  // If the execution reaches this line, an error occurred.
  // The transaction has already been rolled back automatically by Sequelize!

}</code>
</code></pre><p>Note that <code>t.commit()</code> and <code>t.rollback()</code> were not called directly (which is correct).</p><h3>Throw errors to rollback</h3><p>When using the managed transaction you should <em>never</em> commit or rollback the transaction manually. If all queries are successful (in the sense of not throwing any error), but you still want to rollback the transaction, you should throw an error yourself:</p><pre><code class="lang-js"><code class="source-code prettyprint">await sequelize.transaction(async t =&gt; {
  const user = await User.create({
    firstName: 'Abraham',
    lastName: 'Lincoln'
  }, { transaction: t });

  // Woops, the query was successful but we still want to roll back!
  // We throw an error manually, so that Sequelize handles everything automatically.
  throw new Error();
});</code>
</code></pre><h3>Automatically pass transactions to all queries</h3><p>In the examples above, the transaction is still manually passed, by passing <code>{ transaction: t }</code> as the second argument. To automatically pass the transaction to all queries you must install the <a href="https://github.com/Jeff-Lewis/cls-hooked">cls-hooked</a> (CLS) module and instantiate a namespace in your own code:</p><pre><code class="lang-js"><code class="source-code prettyprint">const cls = require('cls-hooked');
const namespace = cls.createNamespace('my-very-own-namespace');</code>
</code></pre><p>To enable CLS you must tell sequelize which namespace to use by using a static method of the sequelize constructor:</p><pre><code class="lang-js"><code class="source-code prettyprint">const Sequelize = require('sequelize');
Sequelize.useCLS(namespace);

new Sequelize(....);</code>
</code></pre><p>Notice, that the <code>useCLS()</code> method is on the <em>constructor</em>, not on an instance of sequelize. This means that all instances will share the same namespace, and that CLS is all-or-nothing - you cannot enable it only for some instances.</p><p>CLS works like a thread-local storage for callbacks. What this means in practice is that different callback chains can access local variables by using the CLS namespace. When CLS is enabled sequelize will set the <code>transaction</code> property on the namespace when a new transaction is created. Since variables set within a callback chain are private to that chain several concurrent transactions can exist at the same time:</p><pre><code class="lang-js"><code class="source-code prettyprint">sequelize.transaction((t1) =&gt; {
  namespace.get('transaction') === t1; // true
});

sequelize.transaction((t2) =&gt; {
  namespace.get('transaction') === t2; // true
});</code>
</code></pre><p>In most case you won't need to access <code>namespace.get('transaction')</code> directly, since all queries will automatically look for a transaction on the namespace:</p><pre><code class="lang-js"><code class="source-code prettyprint">sequelize.transaction((t1) =&gt; {
  // With CLS enabled, the user will be created inside the transaction
  return User.create({ name: 'Alice' });
});</code>
</code></pre><h2>Concurrent/Partial transactions</h2><p>You can have concurrent transactions within a sequence of queries or have some of them excluded from any transactions. Use the <code>transaction</code> option to control which transaction a query belongs to:</p><p><strong>Note:</strong> <em>SQLite does not support more than one transaction at the same time.</em></p><h3>With CLS enabled</h3><pre><code class="lang-js"><code class="source-code prettyprint">sequelize.transaction((t1) =&gt; {
  return sequelize.transaction((t2) =&gt; {
    // With CLS enabled, queries here will by default use t2.
    // Pass in the `transaction` option to define/alter the transaction they belong to.
    return Promise.all([
        User.create({ name: 'Bob' }, { transaction: null }),
        User.create({ name: 'Mallory' }, { transaction: t1 }),
        User.create({ name: 'John' }) // this would default to t2
    ]);
  });
});</code>
</code></pre><h2>Passing options</h2><p>The <code>sequelize.transaction</code> method accepts options.</p><p>For unmanaged transactions, just use <code>sequelize.transaction(options)</code>.</p><p>For managed transactions, use <code>sequelize.transaction(options, callback)</code>.</p><h2>Isolation levels</h2><p>The possible isolations levels to use when starting a transaction:</p><pre><code class="lang-js"><code class="source-code prettyprint">const { Transaction } = require('sequelize');

// The following are valid isolation levels:
Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED // "READ UNCOMMITTED"
Transaction.ISOLATION_LEVELS.READ_COMMITTED // "READ COMMITTED"
Transaction.ISOLATION_LEVELS.REPEATABLE_READ  // "REPEATABLE READ"
Transaction.ISOLATION_LEVELS.SERIALIZABLE // "SERIALIZABLE"</code>
</code></pre><p>By default, sequelize uses the isolation level of the database. If you want to use a different isolation level, pass in the desired level as the first argument:</p><pre><code class="lang-js"><code class="source-code prettyprint">const { Transaction } = require('sequelize');

await sequelize.transaction({
  isolationLevel: Transaction.ISOLATION_LEVELS.SERIALIZABLE
}, async (t) =&gt; {
  // Your code
});</code>
</code></pre><p>You can also overwrite the <code>isolationLevel</code> setting globally with an option in the Sequelize constructor:</p><pre><code class="lang-js"><code class="source-code prettyprint">const { Sequelize, Transaction } = require('sequelize');

const sequelize = new Sequelize('sqlite::memory:', {
  isolationLevel: Transaction.ISOLATION_LEVELS.SERIALIZABLE
});</code>
</code></pre><p><strong>Note for MSSQL:</strong> <em>The <code>SET ISOLATION LEVEL</code> queries are not logged since the specified <code>isolationLevel</code> is passed directly to <code>tedious</code>.</em></p><h2>Usage with other sequelize methods</h2><p>The <code>transaction</code> option goes with most other options, which are usually the first argument of a method.</p><p>For methods that take values, like <code>.create</code>, <code>.update()</code>, etc. <code>transaction</code> should be passed to the option in the second argument.</p><p>If unsure, refer to the API documentation for the method you are using to be sure of the signature.</p><p>Examples:</p><pre><code class="lang-js"><code class="source-code prettyprint">await User.create({ name: 'Foo Bar' }, { transaction: t });

await User.findAll({
  where: {
    name: 'Foo Bar'
  },
  transaction: t
});</code>
</code></pre><h2>The <code>afterCommit</code> hook</h2><p>A <code>transaction</code> object allows tracking if and when it is committed.</p><p>An <code>afterCommit</code> hook can be added to both managed and unmanaged transaction objects:</p><pre><code class="lang-js"><code class="source-code prettyprint">// Managed transaction:
await sequelize.transaction(async (t) =&gt; {
  t.afterCommit(() =&gt; {
    // Your logic
  });
});

// Unmanaged transaction:
const t = await sequelize.transaction();
t.afterCommit(() =&gt; {
  // Your logic
});
await t.commit();</code>
</code></pre><p>The callback passed to <code>afterCommit</code> can be <code>async</code>. In this case:</p><ul>
<li>For a managed transaction: the <code>sequelize.transaction</code> call will wait for it before settling;</li>
<li>For an unmanaged transaction: the <code>t.commit</code> call will wait for it before settling.</li>
</ul><p>Notes:</p><ul>
<li>The <code>afterCommit</code> hook is not raised if the transaction is rolled back;</li>
<li>The <code>afterCommit</code> hook does not modify the return value of the transaction (unlike most hooks)</li>
</ul><p>You can use the <code>afterCommit</code> hook in conjunction with model hooks to know when a instance is saved and available outside of a transaction</p><pre><code class="lang-js"><code class="source-code prettyprint">User.afterSave((instance, options) =&gt; {
  if (options.transaction) {
    // Save done within a transaction, wait until transaction is committed to
    // notify listeners the instance has been saved
    options.transaction.afterCommit(() =&gt; /* Notify */)
    return;
  }
  // Save done outside a transaction, safe for callers to fetch the updated model
  // Notify
});</code>
</code></pre><h2>Locks</h2><p>Queries within a <code>transaction</code> can be performed with locks:</p><pre><code class="lang-js"><code class="source-code prettyprint">return User.findAll({
  limit: 1,
  lock: true,
  transaction: t1
});</code>
</code></pre><p>Queries within a transaction can skip locked rows:</p><pre><code class="lang-js"><code class="source-code prettyprint">return User.findAll({
  limit: 1,
  lock: true,
  skipLocked: true,
  transaction: t2
});</code>
</code></pre></div>
        <a data-ice="link" href="manual/transactions.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Hooks</h1><p>Hooks (also known as lifecycle events), are functions which are called before and after calls in sequelize are executed. For example, if you want to always set a value on a model before saving it, you can add a <code>beforeUpdate</code> hook.</p><p><strong>Note:</strong> <em>You can't use hooks with instances. Hooks are used with models.</em></p><h2>Available hooks</h2><p>Sequelize provides a lot of hooks. The full list can be found in directly in the <a href="https://github.com/sequelize/sequelize/blob/v6/src/hooks.js#L7">source code - src/hooks.js</a>.</p><h2>Hooks firing order</h2><p>The diagram below shows the firing order for the most common hooks.</p><p><em><strong>Note:</strong> this list is not exhaustive.</em></p><pre><code class="lang-text"><code class="source-code prettyprint">(1)
  beforeBulkCreate(instances, options)
  beforeBulkDestroy(options)
  beforeBulkUpdate(options)
(2)
  beforeValidate(instance, options)

[... validation happens ...]

(3)
  afterValidate(instance, options)
  validationFailed(instance, options, error)
(4)
  beforeCreate(instance, options)
  beforeDestroy(instance, options)
  beforeUpdate(instance, options)
  beforeSave(instance, options)
  beforeUpsert(values, options)

[... creation/update/destruction happens ...]

(5)
  afterCreate(instance, options)
  afterDestroy(instance, options)
  afterUpdate(instance, options)
  afterSave(instance, options)
  afterUpsert(created, options)
(6)
  afterBulkCreate(instances, options)
  afterBulkDestroy(options)
  afterBulkUpdate(options)</code>
</code></pre><h2>Declaring Hooks</h2><p>Arguments to hooks are passed by reference. This means, that you can change the values, and this will be reflected in the insert / update statement. A hook may contain async actions - in this case the hook function should return a promise.</p><p>There are currently three ways to programmatically add hooks:</p><pre><code class="lang-js"><code class="source-code prettyprint">// Method 1 via the .init() method
class User extends Model {}
User.init({
  username: DataTypes.STRING,
  mood: {
    type: DataTypes.ENUM,
    values: ['happy', 'sad', 'neutral']
  }
}, {
  hooks: {
    beforeValidate: (user, options) =&gt; {
      user.mood = 'happy';
    },
    afterValidate: (user, options) =&gt; {
      user.username = 'Toni';
    }
  },
  sequelize
});

// Method 2 via the .addHook() method
User.addHook('beforeValidate', (user, options) =&gt; {
  user.mood = 'happy';
});

User.addHook('afterValidate', 'someCustomName', (user, options) =&gt; {
  return Promise.reject(new Error("I'm afraid I can't let you do that!"));
});

// Method 3 via the direct method
User.beforeCreate(async (user, options) =&gt; {
  const hashedPassword = await hashPassword(user.password);
  user.password = hashedPassword;
});

User.afterValidate('myHookAfter', (user, options) =&gt; {
  user.username = 'Toni';
});</code>
</code></pre><h2>Removing hooks</h2><p>Only a hook with name param can be removed.</p><pre><code class="lang-js"><code class="source-code prettyprint">class Book extends Model {}
Book.init({
  title: DataTypes.STRING
}, { sequelize });

Book.addHook('afterCreate', 'notifyUsers', (book, options) =&gt; {
  // ...
});

Book.removeHook('afterCreate', 'notifyUsers');</code>
</code></pre><p>You can have many hooks with same name. Calling <code>.removeHook()</code> will remove all of them.</p><h2>Global / universal hooks</h2><p>Global hooks are hooks that are run for all models. They are especially useful for plugins and can define behaviours that you want for all your models, for example to allow customization on timestamps using <code>sequelize.define</code> on your models:</p><pre><code class="lang-js"><code class="source-code prettyprint">const User = sequelize.define('User', {}, {
    tableName: 'users',
    hooks : {
        beforeCreate : (record, options) =&gt; {
            record.dataValues.createdAt = new Date().toISOString().replace(/T/, ' ').replace(/\..+/g, '');
            record.dataValues.updatedAt = new Date().toISOString().replace(/T/, ' ').replace(/\..+/g, '');
        },
        beforeUpdate : (record, options) =&gt; {
            record.dataValues.updatedAt = new Date().toISOString().replace(/T/, ' ').replace(/\..+/g, '');
        }
    }
});</code>
</code></pre><p>They can be defined in many ways, which have slightly different semantics:</p><h3>Default Hooks (on Sequelize constructor options)</h3><pre><code class="lang-js"><code class="source-code prettyprint">const sequelize = new Sequelize(..., {
  define: {
    hooks: {
      beforeCreate() {
        // Do stuff
      }
    }
  }
});</code>
</code></pre><p>This adds a default hook to all models, which is run if the model does not define its own <code>beforeCreate</code> hook:</p><pre><code class="lang-js"><code class="source-code prettyprint">const User = sequelize.define('User', {});
const Project = sequelize.define('Project', {}, {
  hooks: {
    beforeCreate() {
      // Do other stuff
    }
  }
});

await User.create({});    // Runs the global hook
await Project.create({}); // Runs its own hook (because the global hook is overwritten)</code>
</code></pre><h3>Permanent Hooks (with <code>sequelize.addHook</code>)</h3><pre><code class="lang-js"><code class="source-code prettyprint">sequelize.addHook('beforeCreate', () =&gt; {
  // Do stuff
});</code>
</code></pre><p>This hook is always run, whether or not the model specifies its own <code>beforeCreate</code> hook. Local hooks are always run before global hooks:</p><pre><code class="lang-js"><code class="source-code prettyprint">const User = sequelize.define('User', {});
const Project = sequelize.define('Project', {}, {
  hooks: {
    beforeCreate() {
      // Do other stuff
    }
  }
});

await User.create({});    // Runs the global hook
await Project.create({}); // Runs its own hook, followed by the global hook</code>
</code></pre><p>Permanent hooks may also be defined in the options passed to the Sequelize constructor:</p><pre><code class="lang-js"><code class="source-code prettyprint">new Sequelize(..., {
  hooks: {
    beforeCreate() {
      // do stuff
    }
  }
});</code>
</code></pre><p>Note that the above is not the same as the <em>Default Hooks</em> mentioned above. That one uses the <code>define</code> option of the constructor. This one does not.</p><h3>Connection Hooks</h3><p>Sequelize provides four hooks that are executed immediately before and after a database connection is obtained or released:</p><ul>
<li><code>sequelize.beforeConnect(callback)</code><ul>
<li>The callback has the form <code>async (config) =&gt; /* ... */</code></li>
</ul>
</li>
<li><code>sequelize.afterConnect(callback)</code><ul>
<li>The callback has the form <code>async (connection, config) =&gt; /* ... */</code></li>
</ul>
</li>
<li><code>sequelize.beforeDisconnect(callback)</code><ul>
<li>The callback has the form <code>async (connection) =&gt; /* ... */</code></li>
</ul>
</li>
<li><code>sequelize.afterDisconnect(callback)</code><ul>
<li>The callback has the form <code>async (connection) =&gt; /* ... */</code></li>
</ul>
</li>
</ul><p>These hooks can be useful if you need to asynchronously obtain database credentials, or need to directly access the low-level database connection after it has been created.</p><p>For example, we can asynchronously obtain a database password from a rotating token store, and mutate Sequelize's configuration object with the new credentials:</p><pre><code class="lang-js"><code class="source-code prettyprint">sequelize.beforeConnect(async (config) =&gt; {
  config.password = await getAuthToken();
});</code>
</code></pre><p>These hooks may <em>only</em> be declared as a permanent global hook, as the connection pool is shared by all models.</p><h2>Instance hooks</h2><p>The following hooks will emit whenever you're editing a single object:</p><ul>
<li><code>beforeValidate</code></li>
<li><code>afterValidate</code> / <code>validationFailed</code></li>
<li><code>beforeCreate</code> / <code>beforeUpdate</code> / <code>beforeSave</code> / <code>beforeDestroy</code></li>
<li><code>afterCreate</code> / <code>afterUpdate</code> / <code>afterSave</code> / <code>afterDestroy</code></li>
</ul><pre><code class="lang-js"><code class="source-code prettyprint">User.beforeCreate(user =&gt; {
  if (user.accessLevel &gt; 10 &amp;&amp; user.username !== "Boss") {
    throw new Error("You can't grant this user an access level above 10!");
  }
});</code>
</code></pre><p>The following example will throw an error:</p><pre><code class="lang-js"><code class="source-code prettyprint">try {
  await User.create({ username: 'Not a Boss', accessLevel: 20 });
} catch (error) {
  console.log(error); // You can't grant this user an access level above 10!
};</code>
</code></pre><p>The following example will be successful:</p><pre><code class="lang-js"><code class="source-code prettyprint">const user = await User.create({ username: 'Boss', accessLevel: 20 });
console.log(user); // user object with username 'Boss' and accessLevel of 20</code>
</code></pre><h3>Model hooks</h3><p>Sometimes you'll be editing more than one record at a time by using methods like <code>bulkCreate</code>, <code>update</code> and <code>destroy</code>. The following hooks will emit whenever you're using one of those methods:</p><ul>
<li><code>YourModel.beforeBulkCreate(callback)</code><ul>
<li>The callback has the form <code>(instances, options) =&gt; /* ... */</code></li>
</ul>
</li>
<li><code>YourModel.beforeBulkUpdate(callback)</code><ul>
<li>The callback has the form <code>(options) =&gt; /* ... */</code></li>
</ul>
</li>
<li><code>YourModel.beforeBulkDestroy(callback)</code><ul>
<li>The callback has the form <code>(options) =&gt; /* ... */</code></li>
</ul>
</li>
<li><code>YourModel.afterBulkCreate(callback)</code><ul>
<li>The callback has the form <code>(instances, options) =&gt; /* ... */</code></li>
</ul>
</li>
<li><code>YourModel.afterBulkUpdate(callback)</code><ul>
<li>The callback has the form <code>(options) =&gt; /* ... */</code></li>
</ul>
</li>
<li><code>YourModel.afterBulkDestroy(callback)</code><ul>
<li>The callback has the form <code>(options) =&gt; /* ... */</code></li>
</ul>
</li>
</ul><p>Note: methods like <code>bulkCreate</code> do not emit individual hooks by default - only the bulk hooks. However, if you want individual hooks to be emitted as well, you can pass the <code>{ individualHooks: true }</code> option to the query call. However, this can drastically impact performance, depending on the number of records involved (since, among other things, all instances will be loaded into memory). Examples:</p><pre><code class="lang-js"><code class="source-code prettyprint">await Model.destroy({
  where: { accessLevel: 0 },
  individualHooks: true
});
// This will select all records that are about to be deleted and emit `beforeDestroy` and `afterDestroy` on each instance.

await Model.update({ username: 'Tony' }, {
  where: { accessLevel: 0 },
  individualHooks: true
});
// This will select all records that are about to be updated and emit `beforeUpdate` and `afterUpdate` on each instance.</code>
</code></pre><p>If you use <code>Model.bulkCreate(...)</code> with the <code>updateOnDuplicate</code> option, changes made in the hook to fields that aren't given in the <code>updateOnDuplicate</code> array will not be persisted to the database. However it is possible to change the <code>updateOnDuplicate</code> option inside the hook if this is what you want.</p><pre><code class="lang-js"><code class="source-code prettyprint">User.beforeBulkCreate((users, options) =&gt; {
  for (const user of users) {
    if (user.isMember) {
      user.memberSince = new Date();
    }
  }

  // Add `memberSince` to updateOnDuplicate otherwise it won't be persisted
  if (options.updateOnDuplicate &amp;&amp; !options.updateOnDuplicate.includes('memberSince')) {
    options.updateOnDuplicate.push('memberSince');
  }
});

// Bulk updating existing users with updateOnDuplicate option
await Users.bulkCreate([
  { id: 1, isMember: true },
  { id: 2, isMember: false }
], {
  updateOnDuplicate: ['isMember']
});</code>
</code></pre><h2>Associations</h2><p>For the most part hooks will work the same for instances when being associated.</p><h3>One-to-One and One-to-Many associations</h3><ul>
<li><p>When using <code>add</code>/<code>set</code> mixin methods the <code>beforeUpdate</code> and <code>afterUpdate</code> hooks will run.</p>
</li>
<li><p>The <code>beforeDestroy</code> and <code>afterDestroy</code> hooks will only be called on associations that have <code>onDelete: 'CASCADE'</code> and <code>hooks: true</code>. For example:</p>
</li>
</ul><pre><code class="lang-js"><code class="source-code prettyprint">class Projects extends Model {}
Projects.init({
  title: DataTypes.STRING
}, { sequelize });

class Tasks extends Model {}
Tasks.init({
  title: DataTypes.STRING
}, { sequelize });

Projects.hasMany(Tasks, { onDelete: 'CASCADE', hooks: true });
Tasks.belongsTo(Projects);</code>
</code></pre><p>This code will run <code>beforeDestroy</code> and <code>afterDestroy</code> hooks on the Tasks model.</p><p>Sequelize, by default, will try to optimize your queries as much as possible. When calling cascade on delete, Sequelize will simply execute:</p><pre><code class="lang-sql"><code class="source-code prettyprint">DELETE FROM `table` WHERE associatedIdentifier = associatedIdentifier.primaryKey</code>
</code></pre><p>However, adding <code>hooks: true</code> explicitly tells Sequelize that optimization is not of your concern. Then, Sequelize will first perform a <code>SELECT</code> on the associated objects and destroy each instance, one by one, in order to be able to properly call the hooks (with the right parameters).</p><h3>Many-to-Many associations</h3><ul>
<li><p>When using <code>add</code> mixin methods for <code>belongsToMany</code> relationships (that will add one or more records to the junction table) the <code>beforeBulkCreate</code> and <code>afterBulkCreate</code> hooks in the junction model will run.</p>
<ul>
<li>If <code>{ individualHooks: true }</code> was passed to the call, then each individual hook will also run.</li>
</ul>
</li>
<li><p>When using <code>remove</code> mixin methods for <code>belongsToMany</code> relationships (that will remove one or more records to the junction table) the <code>beforeBulkDestroy</code> and <code>afterBulkDestroy</code> hooks in the junction model will run.</p>
<ul>
<li>If <code>{ individualHooks: true }</code> was passed to the call, then each individual hook will also run.</li>
</ul>
</li>
</ul><p>If your association is Many-to-Many, you may be interested in firing hooks on the through model when using the <code>remove</code> call. Internally, sequelize is using <code>Model.destroy</code> resulting in calling the <code>bulkDestroy</code> instead of the <code>before/afterDestroy</code> hooks on each through instance.</p><h2>Hooks and Transactions</h2><p>Many model operations in Sequelize allow you to specify a transaction in the options parameter of the method. If a transaction <em>is</em> specified in the original call, it will be present in the options parameter passed to the hook function. For example, consider the following snippet:</p><pre><code class="lang-js"><code class="source-code prettyprint">User.addHook('afterCreate', async (user, options) =&gt; {
  // We can use `options.transaction` to perform some other call
  // using the same transaction of the call that triggered this hook
  await User.update({ mood: 'sad' }, {
    where: {
      id: user.id
    },
    transaction: options.transaction
  });
});

await sequelize.transaction(async t =&gt; {
  await User.create({
    username: 'someguy',
    mood: 'happy'
  }, {
    transaction: t
  });
});</code>
</code></pre><p>If we had not included the transaction option in our call to <code>User.update</code> in the preceding code, no change would have occurred, since our newly created user does not exist in the database until the pending transaction has been committed.</p><h3>Internal Transactions</h3><p>It is very important to recognize that sequelize may make use of transactions internally for certain operations such as <code>Model.findOrCreate</code>. If your hook functions execute read or write operations that rely on the object's presence in the database, or modify the object's stored values like the example in the preceding section, you should always specify <code>{ transaction: options.transaction }</code>:</p><ul>
<li>If a transaction was used, then <code>{ transaction: options.transaction }</code> will ensure it is used again;</li>
<li>Otherwise, <code>{ transaction: options.transaction }</code> will be equivalent to <code>{ transaction: undefined }</code>, which won't use a transaction (which is ok).</li>
</ul><p>This way your hooks will always behave correctly.</p></div>
        <a data-ice="link" href="manual/hooks.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Query Interface</h1><p>An instance of Sequelize uses something called <strong>Query Interface</strong> to communicate to the database in a dialect-agnostic way. Most of the methods you've learned in this manual are implemented with the help of several methods from the query interface.</p><p>The methods from the query interface are therefore lower-level methods; you should use them only if you do not find another way to do it with higher-level APIs from Sequelize. They are, of course, still higher-level than running raw queries directly (i.e., writing SQL by hand).</p><p>This guide shows a few examples, but for the full list of what it can do, and for detailed usage of each method, check the <a href="./manual/../class/src/dialects/abstract/query-interface.js~QueryInterface.html">QueryInterface API</a>.</p><h2>Obtaining the query interface</h2><p>From now on, we will call <code>queryInterface</code> the singleton instance of the <a href="./manual/../class/src/dialects/abstract/query-interface.js~QueryInterface.html">QueryInterface</a> class, which is available on your Sequelize instance:</p><pre><code class="lang-js"><code class="source-code prettyprint">const { Sequelize, DataTypes } = require('sequelize');
const sequelize = new Sequelize(/* ... */);
const queryInterface = sequelize.getQueryInterface();</code>
</code></pre><h2>Creating a table</h2><pre><code class="lang-js"><code class="source-code prettyprint">queryInterface.createTable('Person', {
  name: DataTypes.STRING,
  isBetaMember: {
    type: DataTypes.BOOLEAN,
    defaultValue: false,
    allowNull: false
  }
});</code>
</code></pre><p>Generated SQL (using SQLite):</p><pre><code class="lang-SQL"><code class="source-code prettyprint">CREATE TABLE IF NOT EXISTS `Person` (
  `name` VARCHAR(255),
  `isBetaMember` TINYINT(1) NOT NULL DEFAULT 0
);</code>
</code></pre><p><strong>Note:</strong> Consider defining a Model instead and calling <code>YourModel.sync()</code> instead, which is a higher-level approach.</p><h2>Adding a column to a table</h2><pre><code class="lang-js"><code class="source-code prettyprint">queryInterface.addColumn('Person', 'petName', { type: DataTypes.STRING });</code>
</code></pre><p>Generated SQL (using SQLite):</p><pre><code class="lang-sql"><code class="source-code prettyprint">ALTER TABLE `Person` ADD `petName` VARCHAR(255);</code>
</code></pre><h2>Changing the datatype of a column</h2><pre><code class="lang-js"><code class="source-code prettyprint">queryInterface.changeColumn('Person', 'foo', {
  type: DataTypes.FLOAT,
  defaultValue: 3.14,
  allowNull: false
});</code>
</code></pre><p>Generated SQL (using MySQL):</p><pre><code class="lang-sql"><code class="source-code prettyprint">ALTER TABLE `Person` CHANGE `foo` `foo` FLOAT NOT NULL DEFAULT 3.14;</code>
</code></pre><h2>Removing a column</h2><pre><code class="lang-js"><code class="source-code prettyprint">queryInterface.removeColumn('Person', 'petName', { /* query options */ });</code>
</code></pre><p>Generated SQL (using PostgreSQL):</p><pre><code class="lang-SQL"><code class="source-code prettyprint">ALTER TABLE "public"."Person" DROP COLUMN "petName";</code>
</code></pre><h2>Changing and removing columns in SQLite</h2><p>SQLite does not support directly altering and removing columns. However, Sequelize will try to work around this by recreating the whole table with the help of a backup table, inspired by <a href="https://www.sqlite.org/lang_altertable.html#otheralter">these instructions</a>.</p><p>For example:</p><pre><code class="lang-js"><code class="source-code prettyprint">// Assuming we have a table in SQLite created as follows:
queryInterface.createTable('Person', {
  name: DataTypes.STRING,
  isBetaMember: {
    type: DataTypes.BOOLEAN,
    defaultValue: false,
    allowNull: false
  },
  petName: DataTypes.STRING,
  foo: DataTypes.INTEGER
});

// And we change a column:
queryInterface.changeColumn('Person', 'foo', {
  type: DataTypes.FLOAT,
  defaultValue: 3.14,
  allowNull: false
});</code>
</code></pre><p>The following SQL calls are generated for SQLite:</p><pre><code class="lang-sql"><code class="source-code prettyprint">PRAGMA TABLE_INFO(`Person`);

CREATE TABLE IF NOT EXISTS `Person_backup` (
  `name` VARCHAR(255),
  `isBetaMember` TINYINT(1) NOT NULL DEFAULT 0,
  `foo` FLOAT NOT NULL DEFAULT '3.14',
  `petName` VARCHAR(255)
);

INSERT INTO `Person_backup`
  SELECT
    `name`,
    `isBetaMember`,
    `foo`,
    `petName`
  FROM `Person`;

DROP TABLE `Person`;

CREATE TABLE IF NOT EXISTS `Person` (
  `name` VARCHAR(255),
  `isBetaMember` TINYINT(1) NOT NULL DEFAULT 0,
  `foo` FLOAT NOT NULL DEFAULT '3.14',
  `petName` VARCHAR(255)
);

INSERT INTO `Person`
  SELECT
    `name`,
    `isBetaMember`,
    `foo`,
    `petName`
  FROM `Person_backup`;

DROP TABLE `Person_backup`;</code>
</code></pre><h2>Other</h2><p>As mentioned in the beginning of this guide, there is a lot more to the Query Interface available in Sequelize! Check the <a href="./manual/../class/src/dialects/abstract/query-interface.js~QueryInterface.html">QueryInterface API</a> for a full list of what can be done.</p></div>
        <a data-ice="link" href="manual/query-interface.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Naming Strategies</h1><h2>The <code>underscored</code> option</h2><p>Sequelize provides the <code>underscored</code> option for a model. When <code>true</code>, this option will set the <code>field</code> option on all attributes to the <a href="https://en.wikipedia.org/wiki/Snake_case">snake_case</a> version of its name. This also applies to foreign keys automatically generated by associations and other automatically generated fields. Example:</p><pre><code class="lang-js"><code class="source-code prettyprint">const User = sequelize.define('user', { username: Sequelize.STRING }, {
  underscored: true
});
const Task = sequelize.define('task', { title: Sequelize.STRING }, {
  underscored: true
});
User.hasMany(Task);
Task.belongsTo(User);</code>
</code></pre><p>Above we have the models User and Task, both using the <code>underscored</code> option. We also have a One-to-Many relationship between them. Also, recall that since <code>timestamps</code> is true by default, we should expect the <code>createdAt</code> and <code>updatedAt</code> fields to be automatically created as well.</p><p>Without the <code>underscored</code> option, Sequelize would automatically define:</p><ul>
<li>A <code>createdAt</code> attribute for each model, pointing to a column named <code>createdAt</code> in each table</li>
<li>An <code>updatedAt</code> attribute for each model, pointing to a column named <code>updatedAt</code> in each table</li>
<li>A <code>userId</code> attribute in the <code>Task</code> model, pointing to a column named <code>userId</code> in the task table</li>
</ul><p>With the <code>underscored</code> option enabled, Sequelize will instead define:</p><ul>
<li>A <code>createdAt</code> attribute for each model, pointing to a column named <code>created_at</code> in each table</li>
<li>An <code>updatedAt</code> attribute for each model, pointing to a column named <code>updated_at</code> in each table</li>
<li>A <code>userId</code> attribute in the <code>Task</code> model, pointing to a column named <code>user_id</code> in the task table</li>
</ul><p>Note that in both cases the fields are still <a href="https://en.wikipedia.org/wiki/Camel_case">camelCase</a> in the JavaScript side; this option only changes how these fields are mapped to the database itself. The <code>field</code> option of every attribute is set to their snake_case version, but the attribute itself remains camelCase.</p><p>This way, calling <code>sync()</code> on the above code will generate the following:</p><pre><code class="lang-sql"><code class="source-code prettyprint">CREATE TABLE IF NOT EXISTS "users" (
  "id" SERIAL,
  "username" VARCHAR(255),
  "created_at" TIMESTAMP WITH TIME ZONE NOT NULL,
  "updated_at" TIMESTAMP WITH TIME ZONE NOT NULL,
  PRIMARY KEY ("id")
);
CREATE TABLE IF NOT EXISTS "tasks" (
  "id" SERIAL,
  "title" VARCHAR(255),
  "created_at" TIMESTAMP WITH TIME ZONE NOT NULL,
  "updated_at" TIMESTAMP WITH TIME ZONE NOT NULL,
  "user_id" INTEGER REFERENCES "users" ("id") ON DELETE SET NULL ON UPDATE CASCADE,
  PRIMARY KEY ("id")
);</code>
</code></pre><h2>Singular vs. Plural</h2><p>At a first glance, it can be confusing whether the singular form or plural form of a name shall be used around in Sequelize. This section aims at clarifying that a bit.</p><p>Recall that Sequelize uses a library called <a href="https://www.npmjs.com/package/inflection">inflection</a> under the hood, so that irregular plurals (such as <code>person -&gt; people</code>) are computed correctly. However, if you're working in another language, you may want to define the singular and plural forms of names directly; sequelize allows you to do this with some options.</p><h3>When defining models</h3><p>Models should be defined with the singular form of a word. Example:</p><pre><code class="lang-js"><code class="source-code prettyprint">sequelize.define('foo', { name: DataTypes.STRING });</code>
</code></pre><p>Above, the model name is <code>foo</code> (singular), and the respective table name is <code>foos</code>, since Sequelize automatically gets the plural for the table name.</p><h3>When defining a reference key in a model</h3><pre><code class="lang-js"><code class="source-code prettyprint">sequelize.define('foo', {
  name: DataTypes.STRING,
  barId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: {
      model: "bars",
      key: "id"
    },
    onDelete: "CASCADE"
  },
});</code>
</code></pre><p>In the above example we are manually defining a key that references another model. It's not usual to do this, but if you have to, you should use the table name there. This is because the reference is created upon the referencced table name. In the example above, the plural form was used (<code>bars</code>), assuming that the <code>bar</code> model was created with the default settings (making its underlying table automatically pluralized).</p><h3>When retrieving data from eager loading</h3><p>When you perform an <code>include</code> in a query, the included data will be added to an extra field in the returned objects, according to the following rules:</p><ul>
<li>When including something from a single association (<code>hasOne</code> or <code>belongsTo</code>) - the field name will be the singular version of the model name;</li>
<li>When including something from a multiple association (<code>hasMany</code> or <code>belongsToMany</code>) - the field name will be the plural form of the model.</li>
</ul><p>In short, the name of the field will take the most logical form in each situation.</p><p>Examples:</p><pre><code class="lang-js"><code class="source-code prettyprint">// Assuming Foo.hasMany(Bar)
const foo = Foo.findOne({ include: Bar });
// foo.bars will be an array
// foo.bar will not exist since it doens't make sense

// Assuming Foo.hasOne(Bar)
const foo = Foo.findOne({ include: Bar });
// foo.bar will be an object (possibly null if there is no associated model)
// foo.bars will not exist since it doens't make sense

// And so on.</code>
</code></pre><h3>Overriding singulars and plurals when defining aliases</h3><p>When defining an alias for an association, instead of using simply <code>{ as: 'myAlias' }</code>, you can pass an object to specify the singular and plural forms:</p><pre><code class="lang-js"><code class="source-code prettyprint">Project.belongsToMany(User, {
  as: {
    singular: 'líder',
    plural: 'líderes'
  }
});</code>
</code></pre><p>If you know that a model will always use the same alias in associations, you can provide the singular and plural forms directly to the model itself:</p><pre><code class="lang-js"><code class="source-code prettyprint">const User = sequelize.define('user', { /* ... */ }, {
  name: {
    singular: 'líder',
    plural: 'líderes',
  }
});
Project.belongsToMany(User);</code>
</code></pre><p>The mixins added to the user instances will use the correct forms. For example, instead of <code>project.addUser()</code>, Sequelize will provide <code>project.getLíder()</code>. Also, instead of <code>project.setUsers()</code>, Sequelize will provide <code>project.setLíderes()</code>.</p><p>Note: recall that using <code>as</code> to change the name of the association will also change the name of the foreign key. Therefore it is recommended to also specify the foreign key(s) involved directly in this case.</p><pre><code class="lang-js"><code class="source-code prettyprint">// Example of possible mistake
Invoice.belongsTo(Subscription, { as: 'TheSubscription' });
Subscription.hasMany(Invoice);</code>
</code></pre><p>The first call above will establish a foreign key called <code>theSubscriptionId</code> on <code>Invoice</code>. However, the second call will also establish a foreign key on <code>Invoice</code> (since as we know, <code>hasMany</code> calls places foreign keys in the target model) - however, it will be named <code>subscriptionId</code>. This way you will have both <code>subscriptionId</code> and <code>theSubscriptionId</code> columns.</p><p>The best approach is to choose a name for the foreign key and place it explicitly in both calls. For example, if <code>subscription_id</code> was chosen:</p><pre><code class="lang-js"><code class="source-code prettyprint">// Fixed example
Invoice.belongsTo(Subscription, { as: 'TheSubscription', foreignKey: 'subscription_id' });
Subscription.hasMany(Invoice, { foreignKey: 'subscription_id' });</code>
</code></pre></div>
        <a data-ice="link" href="manual/naming-strategies.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Scopes</h1><p>Scopes are used to help you reuse code. You can define commonly used queries, specifying options such as <code>where</code>, <code>include</code>, <code>limit</code>, etc.</p><p>This guide concerns model scopes. You might also be interested in the <a href="./manual/association-scopes.html">guide for association scopes</a>, which are similar but not the same thing.</p><h2>Definition</h2><p>Scopes are defined in the model definition and can be finder objects, or functions returning finder objects - except for the default scope, which can only be an object:</p><pre><code class="lang-js"><code class="source-code prettyprint">class Project extends Model {}
Project.init({
  // Attributes
}, {
  defaultScope: {
    where: {
      active: true
    }
  },
  scopes: {
    deleted: {
      where: {
        deleted: true
      }
    },
    activeUsers: {
      include: [
        { model: User, where: { active: true } }
      ]
    },
    random() {
      return {
        where: {
          someNumber: Math.random()
        }
      }
    },
    accessLevel(value) {
      return {
        where: {
          accessLevel: {
            [Op.gte]: value
          }
        }
      }
    },
    sequelize,
    modelName: 'project'
  }
});</code>
</code></pre><p>You can also add scopes after a model has been defined by calling <a href="./manual/../class/src/model.js~Model.html#static-method-addScope"><code>YourModel.addScope</code></a>. This is especially useful for scopes with includes, where the model in the include might not be defined at the time the other model is being defined.</p><p>The default scope is always applied. This means, that with the model definition above, <code>Project.findAll()</code> will create the following query:</p><pre><code class="lang-sql"><code class="source-code prettyprint">SELECT * FROM projects WHERE active = true</code>
</code></pre><p>The default scope can be removed by calling <code>.unscoped()</code>, <code>.scope(null)</code>, or by invoking another scope:</p><pre><code class="lang-js"><code class="source-code prettyprint">await Project.scope('deleted').findAll(); // Removes the default scope</code>
</code></pre><pre><code class="lang-sql"><code class="source-code prettyprint">SELECT * FROM projects WHERE deleted = true</code>
</code></pre><p>It is also possible to include scoped models in a scope definition. This allows you to avoid duplicating <code>include</code>, <code>attributes</code> or <code>where</code> definitions. Using the above example, and invoking the <code>active</code> scope on the included User model (rather than specifying the condition directly in that include object):</p><pre><code class="lang-js"><code class="source-code prettyprint">// The `activeUsers` scope defined in the example above could also have been defined this way:
Project.addScope('activeUsers', {
  include: [
    { model: User.scope('active') }
  ]
});</code>
</code></pre><h2>Usage</h2><p>Scopes are applied by calling <code>.scope</code> on the model definition, passing the name of one or more scopes. <code>.scope</code> returns a fully functional model instance with all the regular methods: <code>.findAll</code>, <code>.update</code>, <code>.count</code>, <code>.destroy</code> etc. You can save this model instance and reuse it later:</p><pre><code class="lang-js"><code class="source-code prettyprint">const DeletedProjects = Project.scope('deleted');
await DeletedProjects.findAll();

// The above is equivalent to:
await Project.findAll({
  where: {
    deleted: true
  }
});</code>
</code></pre><p>Scopes apply to <code>.find</code>, <code>.findAll</code>, <code>.count</code>, <code>.update</code>, <code>.increment</code> and <code>.destroy</code>.</p><p>Scopes which are functions can be invoked in two ways. If the scope does not take any arguments it can be invoked as normally. If the scope takes arguments, pass an object:</p><pre><code class="lang-js"><code class="source-code prettyprint">await Project.scope('random', { method: ['accessLevel', 19] }).findAll();</code>
</code></pre><p>Generated SQL:</p><pre><code class="lang-sql"><code class="source-code prettyprint">SELECT * FROM projects WHERE someNumber = 42 AND accessLevel &gt;= 19</code>
</code></pre><h2>Merging</h2><p>Several scopes can be applied simultaneously by passing an array of scopes to <code>.scope</code>, or by passing the scopes as consecutive arguments.</p><pre><code class="lang-js"><code class="source-code prettyprint">// These two are equivalent
await Project.scope('deleted', 'activeUsers').findAll();
await Project.scope(['deleted', 'activeUsers']).findAll();</code>
</code></pre><p>Generated SQL:</p><pre><code class="lang-sql"><code class="source-code prettyprint">SELECT * FROM projects
INNER JOIN users ON projects.userId = users.id
WHERE projects.deleted = true
AND users.active = true</code>
</code></pre><p>If you want to apply another scope alongside the default scope, pass the key <code>defaultScope</code> to <code>.scope</code>:</p><pre><code class="lang-js"><code class="source-code prettyprint">await Project.scope('defaultScope', 'deleted').findAll();</code>
</code></pre><p>Generated SQL:</p><pre><code class="lang-sql"><code class="source-code prettyprint">SELECT * FROM projects WHERE active = true AND deleted = true</code>
</code></pre><p>When invoking several scopes, keys from subsequent scopes will overwrite previous ones (similarly to <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">Object.assign</a>), except for <code>where</code> and <code>include</code>, which will be merged. Consider two scopes:</p><pre><code class="lang-js"><code class="source-code prettyprint">YourMode.addScope('scope1', {
  where: {
    firstName: 'bob',
    age: {
      [Op.gt]: 20
    }
  },
  limit: 2
});
YourMode.addScope('scope2', {
  where: {
    age: {
      [Op.gt]: 30
    }
  },
  limit: 10
});</code>
</code></pre><p>Using <code>.scope('scope1', 'scope2')</code> will yield the following WHERE clause:</p><pre><code class="lang-sql"><code class="source-code prettyprint">WHERE firstName = 'bob' AND age &gt; 30 LIMIT 10</code>
</code></pre><p>Note how <code>limit</code> and <code>age</code> are overwritten by <code>scope2</code>, while <code>firstName</code> is preserved. The <code>limit</code>, <code>offset</code>, <code>order</code>, <code>paranoid</code>, <code>lock</code> and <code>raw</code> fields are overwritten, while <code>where</code> is shallowly merged (meaning that identical keys will be overwritten). The merge strategy for <code>include</code> will be discussed later on.</p><p>Note that <code>attributes</code> keys of multiple applied scopes are merged in such a way that <code>attributes.exclude</code> are always preserved. This allows merging several scopes and never leaking sensitive fields in final scope.</p><p>The same merge logic applies when passing a find object directly to <code>findAll</code> (and similar finders) on a scoped model:</p><pre><code class="lang-js"><code class="source-code prettyprint">Project.scope('deleted').findAll({
  where: {
    firstName: 'john'
  }
})</code>
</code></pre><p>Generated where clause:</p><pre><code class="lang-sql"><code class="source-code prettyprint">WHERE deleted = true AND firstName = 'john'</code>
</code></pre><p>Here the <code>deleted</code> scope is merged with the finder. If we were to pass <code>where: { firstName: 'john', deleted: false }</code> to the finder, the <code>deleted</code> scope would be overwritten.</p><h3>Merging includes</h3><p>Includes are merged recursively based on the models being included. This is a very powerful merge, added on v5, and is better understood with an example.</p><p>Consider the models <code>Foo</code>, <code>Bar</code>, <code>Baz</code> and <code>Qux</code>, with One-to-Many associations as follows:</p><pre><code class="lang-js"><code class="source-code prettyprint">const Foo = sequelize.define('Foo', { name: Sequelize.STRING });
const Bar = sequelize.define('Bar', { name: Sequelize.STRING });
const Baz = sequelize.define('Baz', { name: Sequelize.STRING });
const Qux = sequelize.define('Qux', { name: Sequelize.STRING });
Foo.hasMany(Bar, { foreignKey: 'fooId' });
Bar.hasMany(Baz, { foreignKey: 'barId' });
Baz.hasMany(Qux, { foreignKey: 'bazId' });</code>
</code></pre><p>Now, consider the following four scopes defined on Foo:</p><pre><code class="lang-js"><code class="source-code prettyprint">Foo.addScope('includeEverything', {
  include: {
    model: Bar,
    include: [{
      model: Baz,
      include: Qux
    }]
  }
});

Foo.addScope('limitedBars', {
  include: [{
    model: Bar,
    limit: 2
  }]
});

Foo.addScope('limitedBazs', {
  include: [{
    model: Bar,
    include: [{
      model: Baz,
      limit: 2
    }]
  }]
});

Foo.addScope('excludeBazName', {
  include: [{
    model: Bar,
    include: [{
      model: Baz,
      attributes: {
        exclude: ['name']
      }
    }]
  }]
});</code>
</code></pre><p>These four scopes can be deeply merged easily, for example by calling <code>Foo.scope('includeEverything', 'limitedBars', 'limitedBazs', 'excludeBazName').findAll()</code>, which would be entirely equivalent to calling the following:</p><pre><code class="lang-js"><code class="source-code prettyprint">await Foo.findAll({
  include: {
    model: Bar,
    limit: 2,
    include: [{
      model: Baz,
      limit: 2,
      attributes: {
        exclude: ['name']
      },
      include: Qux
    }]
  }
});

// The above is equivalent to:
await Foo.scope([
  'includeEverything',
  'limitedBars',
  'limitedBazs',
  'excludeBazName'
]).findAll();</code>
</code></pre><p>Observe how the four scopes were merged into one. The includes of scopes are merged based on the model being included. If one scope includes model A and another includes model B, the merged result will include both models A and B. On the other hand, if both scopes include the same model A, but with different options (such as nested includes or other attributes), those will be merged recursively, as shown above.</p><p>The merge illustrated above works in the exact same way regardless of the order applied to the scopes. The order would only make a difference if a certain option was set by two different scopes - which is not the case of the above example, since each scope does a different thing.</p><p>This merge strategy also works in the exact same way with options passed to <code>.findAll</code>, <code>.findOne</code> and the like.</p></div>
        <a data-ice="link" href="manual/scopes.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Sub Queries</h1><p>Consider you have two models, <code>Post</code> and <code>Reaction</code>, with a One-to-Many relationship set up, so that one post has many reactions:</p><pre><code class="lang-js"><code class="source-code prettyprint">const Post = sequelize.define('post', {
    content: DataTypes.STRING
}, { timestamps: false });

const Reaction = sequelize.define('reaction', {
    type: DataTypes.STRING
}, { timestamps: false });

Post.hasMany(Reaction);
Reaction.belongsTo(Post);</code>
</code></pre><p><em>Note: we have disabled timestamps just to have shorter queries for the next examples.</em></p><p>Let's fill our tables with some data:</p><pre><code class="lang-js"><code class="source-code prettyprint">async function makePostWithReactions(content, reactionTypes) {
    const post = await Post.create({ content });
    await Reaction.bulkCreate(
        reactionTypes.map(type =&gt; ({ type, postId: post.id }))
    );
    return post;
}

await makePostWithReactions('Hello World', [
    'Like', 'Angry', 'Laugh', 'Like', 'Like', 'Angry', 'Sad', 'Like'
]);
await makePostWithReactions('My Second Post', [
    'Laugh', 'Laugh', 'Like', 'Laugh'
]);</code>
</code></pre><p>Now, we are ready for examples of the power of subqueries.</p><p>Let's say we wanted to compute via SQL a <code>laughReactionsCount</code> for each post. We can achieve that with a sub-query, such as the following:</p><pre><code class="lang-sql"><code class="source-code prettyprint">SELECT
    *,
    (
        SELECT COUNT(*)
        FROM reactions AS reaction
        WHERE
            reaction.postId = post.id
            AND
            reaction.type = "Laugh"
    ) AS laughReactionsCount
FROM posts AS post</code>
</code></pre><p>If we run the above raw SQL query through Sequelize, we get:</p><pre><code class="lang-json"><code class="source-code prettyprint">[
  {
    "id": 1,
    "content": "Hello World",
    "laughReactionsCount": 1
  },
  {
    "id": 2,
    "content": "My Second Post",
    "laughReactionsCount": 3
  }
]</code>
</code></pre><p>So how can we achieve that with more help from Sequelize, without having to write the whole raw query by hand?</p><p>The answer: by combining the <code>attributes</code> option of the finder methods (such as <code>findAll</code>) with the <code>sequelize.literal</code> utility function, that allows you to directly insert arbitrary content into the query without any automatic escaping.</p><p>This means that Sequelize will help you with the main, larger query, but you will still have to write that sub-query by yourself:</p><pre><code class="lang-js"><code class="source-code prettyprint">Post.findAll({
    attributes: {
        include: [
            [
                // Note the wrapping parentheses in the call below!
                sequelize.literal(`(
                    SELECT COUNT(*)
                    FROM reactions AS reaction
                    WHERE
                        reaction.postId = post.id
                        AND
                        reaction.type = "Laugh"
                )`),
                'laughReactionsCount'
            ]
        ]
    }
});</code>
</code></pre><p><em>Important Note: Since <code>sequelize.literal</code> inserts arbitrary content without escaping to the query, it deserves very special attention since it may be a source of (major) security vulnerabilities. It should not be used on user-generated content.</em> However, here, we are using <code>sequelize.literal</code> with a fixed string, carefully written by us (the coders). This is ok, since we know what we are doing.</p><p>The above gives the following output:</p><pre><code class="lang-json"><code class="source-code prettyprint">[
  {
    "id": 1,
    "content": "Hello World",
    "laughReactionsCount": 1
  },
  {
    "id": 2,
    "content": "My Second Post",
    "laughReactionsCount": 3
  }
]</code>
</code></pre><p>Success!</p><h2>Using sub-queries for complex ordering</h2><p>This idea can be used to enable complex ordering, such as ordering posts by the number of laugh reactions they have:</p><pre><code class="lang-js"><code class="source-code prettyprint">Post.findAll({
    attributes: {
        include: [
            [
                sequelize.literal(`(
                    SELECT COUNT(*)
                    FROM reactions AS reaction
                    WHERE
                        reaction.postId = post.id
                        AND
                        reaction.type = "Laugh"
                )`),
                'laughReactionsCount'
            ]
        ]
    },
    order: [
        [sequelize.literal('laughReactionsCount'), 'DESC']
    ]
});</code>
</code></pre><p>Result:</p><pre><code class="lang-json"><code class="source-code prettyprint">[
  {
    "id": 2,
    "content": "My Second Post",
    "laughReactionsCount": 3
  },
  {
    "id": 1,
    "content": "Hello World",
    "laughReactionsCount": 1
  }
]</code>
</code></pre></div>
        <a data-ice="link" href="manual/sub-queries.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Other Data Types</h1><p>Apart from the most common data types mentioned in the Model Basics guide, Sequelize provides several other data types.</p><h2>Ranges (PostgreSQL only)</h2><pre><code class="lang-js"><code class="source-code prettyprint">DataTypes.RANGE(DataTypes.INTEGER)    // int4range
DataTypes.RANGE(DataTypes.BIGINT)     // int8range
DataTypes.RANGE(DataTypes.DATE)       // tstzrange
DataTypes.RANGE(DataTypes.DATEONLY)   // daterange
DataTypes.RANGE(DataTypes.DECIMAL)    // numrange</code>
</code></pre><p>Since range types have extra information for their bound inclusion/exclusion it's not very straightforward to just use a tuple to represent them in javascript.</p><p>When supplying ranges as values you can choose from the following APIs:</p><pre><code class="lang-js"><code class="source-code prettyprint">// defaults to inclusive lower bound, exclusive upper bound
const range = [
  new Date(Date.UTC(2016, 0, 1)),
  new Date(Date.UTC(2016, 1, 1))
];
// '["2016-01-01 00:00:00+00:00", "2016-02-01 00:00:00+00:00")'

// control inclusion
const range = [
  { value: new Date(Date.UTC(2016, 0, 1)), inclusive: false },
  { value: new Date(Date.UTC(2016, 1, 1)), inclusive: true },
];
// '("2016-01-01 00:00:00+00:00", "2016-02-01 00:00:00+00:00"]'

// composite form
const range = [
  { value: new Date(Date.UTC(2016, 0, 1)), inclusive: false },
  new Date(Date.UTC(2016, 1, 1)),
];
// '("2016-01-01 00:00:00+00:00", "2016-02-01 00:00:00+00:00")'

const Timeline = sequelize.define('Timeline', {
  range: DataTypes.RANGE(DataTypes.DATE)
});

await Timeline.create({ range });</code>
</code></pre><p>However, retrieved range values always come in the form of an array of objects. For example, if the stored value is <code>("2016-01-01 00:00:00+00:00", "2016-02-01 00:00:00+00:00"]</code>, after a finder query you will get:</p><pre><code class="lang-js"><code class="source-code prettyprint">[
  { value: Date, inclusive: false },
  { value: Date, inclusive: true }
]</code>
</code></pre><p>You will need to call <code>reload()</code> after updating an instance with a range type or use the <code>returning: true</code> option.</p><h3>Special Cases</h3><pre><code class="lang-js"><code class="source-code prettyprint">// empty range:
Timeline.create({ range: [] }); // range = 'empty'

// Unbounded range:
Timeline.create({ range: [null, null] }); // range = '[,)'
// range = '[,"2016-01-01 00:00:00+00:00")'
Timeline.create({ range: [null, new Date(Date.UTC(2016, 0, 1))] });

// Infinite range:
// range = '[-infinity,"2016-01-01 00:00:00+00:00")'
Timeline.create({ range: [-Infinity, new Date(Date.UTC(2016, 0, 1))] });</code>
</code></pre><h2>BLOBs</h2><pre><code class="lang-js"><code class="source-code prettyprint">DataTypes.BLOB                // BLOB (bytea for PostgreSQL)
DataTypes.BLOB('tiny')        // TINYBLOB (bytea for PostgreSQL)
DataTypes.BLOB('medium')      // MEDIUMBLOB (bytea for PostgreSQL)
DataTypes.BLOB('long')        // LONGBLOB (bytea for PostgreSQL)</code>
</code></pre><p>The blob datatype allows you to insert data both as strings and as buffers. However, when a blob is retrieved from database with Sequelize, it will always be retrieved as a buffer.</p><h2>ENUMs</h2><p>The ENUM is a data type that accepts only a few values, specified as a list.</p><pre><code class="lang-js"><code class="source-code prettyprint">DataTypes.ENUM('foo', 'bar') // An ENUM with allowed values 'foo' and 'bar'</code>
</code></pre><p>ENUMs can also be specified with the <code>values</code> field of the column definition, as follows:</p><pre><code class="lang-js"><code class="source-code prettyprint">sequelize.define('foo', {
  states: {
    type: DataTypes.ENUM,
    values: ['active', 'pending', 'deleted']
  }
});</code>
</code></pre><h2>JSON (SQLite, MySQL, MariaDB and PostgreSQL only)</h2><p>The <code>DataTypes.JSON</code> data type is only supported for SQLite, MySQL, MariaDB and PostgreSQL. However, there is a minimum support for MSSQL (see below).</p><h3>Note for PostgreSQL</h3><p>The JSON data type in PostgreSQL stores the value as plain text, as opposed to binary representation. If you simply want to store and retrieve a JSON representation, using JSON will take less disk space and less time to build from its input representation. However, if you want to do any operations on the JSON value, you should prefer the JSONB data type described below.</p><h3>JSONB (PostgreSQL only)</h3><p>PostgreSQL also supports a JSONB data type: <code>DataTypes.JSONB</code>. It can be queried in three different ways:</p><pre><code class="lang-js"><code class="source-code prettyprint">// Nested object
await Foo.findOne({
  where: {
    meta: {
      video: {
        url: {
          [Op.ne]: null
        }
      }
    }
  }
});

// Nested key
await Foo.findOne({
  where: {
    "meta.audio.length": {
      [Op.gt]: 20
    }
  }
});

// Containment
await Foo.findOne({
  where: {
    meta: {
      [Op.contains]: {
        site: {
          url: 'http://google.com'
        }
      }
    }
  }
});</code>
</code></pre><h3>MSSQL</h3><p>MSSQL does not have a JSON data type, however it does provide some support for JSON stored as strings through certain functions since SQL Server 2016. Using these functions, you will be able to query the JSON stored in the string, but any returned values will need to be parsed seperately.</p><pre><code class="lang-js"><code class="source-code prettyprint">// ISJSON - to test if a string contains valid JSON
await User.findAll({
  where: sequelize.where(sequelize.fn('ISJSON', sequelize.col('userDetails')), 1)
})

// JSON_VALUE - extract a scalar value from a JSON string
await User.findAll({
  attributes: [[ sequelize.fn('JSON_VALUE', sequelize.col('userDetails'), '$.address.Line1'), 'address line 1']]
})

// JSON_VALUE - query a scalar value from a JSON string
await User.findAll({
  where: sequelize.where(sequelize.fn('JSON_VALUE', sequelize.col('userDetails'), '$.address.Line1'), '14, Foo Street')
})

// JSON_QUERY - extract an object or array
await User.findAll({
  attributes: [[ sequelize.fn('JSON_QUERY', sequelize.col('userDetails'), '$.address'), 'full address']]
})</code>
</code></pre><h2>Others</h2><pre><code class="lang-js"><code class="source-code prettyprint">DataTypes.ARRAY(/* DataTypes.SOMETHING */)  // Defines an array of DataTypes.SOMETHING. PostgreSQL only.

DataTypes.CIDR                        // CIDR                  PostgreSQL only
DataTypes.INET                        // INET                  PostgreSQL only
DataTypes.MACADDR                     // MACADDR               PostgreSQL only

DataTypes.GEOMETRY                    // Spatial column. PostgreSQL (with PostGIS) or MySQL only.
DataTypes.GEOMETRY('POINT')           // Spatial column with geometry type. PostgreSQL (with PostGIS) or MySQL only.
DataTypes.GEOMETRY('POINT', 4326)     // Spatial column with geometry type and SRID. PostgreSQL (with PostGIS) or MySQL only.</code>
</code></pre></div>
        <a data-ice="link" href="manual/other-data-types.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Constraints &amp; Circularities</h1><p>Adding constraints between tables means that tables must be created in the database in a certain order, when using <code>sequelize.sync</code>. If <code>Task</code> has a reference to <code>User</code>, the <code>User</code> table must be created before the <code>Task</code> table can be created. This can sometimes lead to circular references, where Sequelize cannot find an order in which to sync. Imagine a scenario of documents and versions. A document can have multiple versions, and for convenience, a document has a reference to its current version.</p><pre><code class="lang-js"><code class="source-code prettyprint">const { Sequelize, Model, DataTypes } = require("sequelize");

class Document extends Model {}
Document.init({
    author: DataTypes.STRING
}, { sequelize, modelName: 'document' });

class Version extends Model {}
Version.init({
  timestamp: DataTypes.DATE
}, { sequelize, modelName: 'version' });

Document.hasMany(Version); // This adds documentId attribute to version
Document.belongsTo(Version, {
  as: 'Current',
  foreignKey: 'currentVersionId'
}); // This adds currentVersionId attribute to document</code>
</code></pre><p>However, unfortunately the code above will result in the following error:</p><pre><code class="lang-text"><code class="source-code prettyprint">Cyclic dependency found. documents is dependent of itself. Dependency chain: documents -&gt; versions =&gt; documents</code>
</code></pre><p>In order to alleviate that, we can pass <code>constraints: false</code> to one of the associations:</p><pre><code class="lang-js"><code class="source-code prettyprint">Document.hasMany(Version);
Document.belongsTo(Version, {
  as: 'Current',
  foreignKey: 'currentVersionId',
  constraints: false
});</code>
</code></pre><p>Which will allow us to sync the tables correctly:</p><pre><code class="lang-sql"><code class="source-code prettyprint">CREATE TABLE IF NOT EXISTS "documents" (
  "id" SERIAL,
  "author" VARCHAR(255),
  "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL,
  "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL,
  "currentVersionId" INTEGER,
  PRIMARY KEY ("id")
);

CREATE TABLE IF NOT EXISTS "versions" (
  "id" SERIAL,
  "timestamp" TIMESTAMP WITH TIME ZONE,
  "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL,
  "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL,
  "documentId" INTEGER REFERENCES "documents" ("id") ON DELETE
  SET
    NULL ON UPDATE CASCADE,
    PRIMARY KEY ("id")
);</code>
</code></pre><h2>Enforcing a foreign key reference without constraints</h2><p>Sometimes you may want to reference another table, without adding any constraints, or associations. In that case you can manually add the reference attributes to your schema definition, and mark the relations between them.</p><pre><code class="lang-js"><code class="source-code prettyprint">class Trainer extends Model {}
Trainer.init({
  firstName: Sequelize.STRING,
  lastName: Sequelize.STRING
}, { sequelize, modelName: 'trainer' });

// Series will have a trainerId = Trainer.id foreign reference key
// after we call Trainer.hasMany(series)
class Series extends Model {}
Series.init({
  title: Sequelize.STRING,
  subTitle: Sequelize.STRING,
  description: Sequelize.TEXT,
  // Set FK relationship (hasMany) with `Trainer`
  trainerId: {
    type: DataTypes.INTEGER,
    references: {
      model: Trainer,
      key: 'id'
    }
  }
}, { sequelize, modelName: 'series' });

// Video will have seriesId = Series.id foreign reference key
// after we call Series.hasOne(Video)
class Video extends Model {}
Video.init({
  title: Sequelize.STRING,
  sequence: Sequelize.INTEGER,
  description: Sequelize.TEXT,
  // set relationship (hasOne) with `Series`
  seriesId: {
    type: DataTypes.INTEGER,
    references: {
      model: Series, // Can be both a string representing the table name or a Sequelize model
      key: 'id'
    }
  }
}, { sequelize, modelName: 'video' });

Series.hasOne(Video);
Trainer.hasMany(Series);</code>
</code></pre></div>
        <a data-ice="link" href="manual/constraints-and-circularities.html"></a>
      </div>
    </div>

<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Indexes</h1><p>Sequelize supports adding indexes to the model definition which will be created on <a href="./manual/../class/src/sequelize.js~Sequelize.html#instance-method-sync"><code>sequelize.sync()</code></a>.</p><pre><code class="lang-js"><code class="source-code prettyprint">const User = sequelize.define('User', { /* attributes */ }, {
  indexes: [
    // Create a unique index on email
    {
      unique: true,
      fields: ['email']
    },

    // Creates a gin index on data with the jsonb_path_ops operator
    {
      fields: ['data'],
      using: 'gin',
      operator: 'jsonb_path_ops'
    },

    // By default index name will be [table]_[fields]
    // Creates a multi column partial index
    {
      name: 'public_by_author',
      fields: ['author', 'status'],
      where: {
        status: 'public'
      }
    },

    // A BTREE index with an ordered field
    {
      name: 'title_index',
      using: 'BTREE',
      fields: [
        'author',
        {
          name: 'title',
          collate: 'en_US',
          order: 'DESC',
          length: 5
        }
      ]
    }
  ]
});</code>
</code></pre></div>
        <a data-ice="link" href="manual/indexes.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Optimistic Locking</h1><p>Sequelize has built-in support for optimistic locking through a model instance version count.</p><p>Optimistic locking is disabled by default and can be enabled by setting the <code>version</code> property to true in a specific model definition or global model configuration. See <a href="./manual/models-definition.html#configuration">model configuration</a> for more details.</p><p>Optimistic locking allows concurrent access to model records for edits and prevents conflicts from overwriting data.  It does this by checking whether another process has made changes to a record since it was read and throws an OptimisticLockError when a conflict is detected.</p></div>
        <a data-ice="link" href="manual/optimistic-locking.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Read Replication</h1><p>Sequelize supports <a href="https://en.wikipedia.org/wiki/Replication_%28computing%29#Database_replication">read replication</a>, i.e. having multiple servers that you can connect to when you want to do a SELECT query. When you do read replication, you specify one or more servers to act as read replicas, and one server to act as the main writer, which handles all writes and updates and propagates them to the replicas (note that the actual replication process is <strong>not</strong> handled by Sequelize, but should be set up by database backend).</p><pre><code class="lang-js"><code class="source-code prettyprint">const sequelize = new Sequelize('database', null, null, {
  dialect: 'mysql',
  port: 3306,
  replication: {
    read: [
      { host: '8.8.8.8', username: 'read-1-username', password: process.env.READ_DB_1_PW },
      { host: '9.9.9.9', username: 'read-2-username', password: process.env.READ_DB_2_PW }
    ],
    write: { host: '1.1.1.1', username: 'write-username', password: process.env.WRITE_DB_PW }
  },
  pool: { // If you want to override the options used for the read/write pool you can do so here
    max: 20,
    idle: 30000
  },
})</code>
</code></pre><p>If you have any general settings that apply to all replicas you do not need to provide them for each instance. In the code above, database name and port is propagated to all replicas. The same will happen for user and password, if you leave them out for any of the replicas. Each replica has the following options:<code>host</code>,<code>port</code>,<code>username</code>,<code>password</code>,<code>database</code>.</p><p>Sequelize uses a pool to manage connections to your replicas. Internally Sequelize will maintain two pools created using <code>pool</code> configuration.</p><p>If you want to modify these, you can pass pool as an options when instantiating Sequelize, as shown above.</p><p>Each <code>write</code> or <code>useMaster: true</code> query will use write pool. For <code>SELECT</code> read pool will be used. Read replica are switched using a basic round robin scheduling.</p></div>
        <a data-ice="link" href="manual/read-replication.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Connection Pool</h1><p>If you're connecting to the database from a single process, you should create only one Sequelize instance. Sequelize will set up a connection pool on initialization. This connection pool can be configured through the constructor's <code>options</code> parameter (using <code>options.pool</code>), as is shown in the following example:</p><pre><code class="lang-js"><code class="source-code prettyprint">const sequelize = new Sequelize(/* ... */, {
  // ...
  pool: {
    max: 5,
    min: 0,
    acquire: 30000,
    idle: 10000
  }
});</code>
</code></pre><p>Learn more in the <a href="./manual/../class/src/sequelize.js~Sequelize.html#instance-constructor-constructor">API Reference for the Sequelize constructor</a>. If you're connecting to the database from multiple processes, you'll have to create one instance per process, but each instance should have a maximum connection pool size of such that the total maximum size is respected. For example, if you want a max connection pool size of 90 and you have three processes, the Sequelize instance of each process should have a max connection pool size of 30.</p></div>
        <a data-ice="link" href="manual/connection-pool.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Working with Legacy Tables</h1><p>While out of the box Sequelize will seem a bit opinionated it's easy to work legacy tables and forward proof your application by defining (otherwise generated) table and field names.</p><h2>Tables</h2><pre><code class="lang-js"><code class="source-code prettyprint">class User extends Model {}
User.init({
  // ...
}, {
  modelName: 'user',
  tableName: 'users',
  sequelize,
});</code>
</code></pre><h2>Fields</h2><pre><code class="lang-js"><code class="source-code prettyprint">class MyModel extends Model {}
MyModel.init({
  userId: {
    type: DataTypes.INTEGER,
    field: 'user_id'
  }
}, { sequelize });</code>
</code></pre><h2>Primary keys</h2><p>Sequelize will assume your table has a <code>id</code> primary key property by default.</p><p>To define your own primary key:</p><pre><code class="lang-js"><code class="source-code prettyprint">class Collection extends Model {}
Collection.init({
  uid: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true // Automatically gets converted to SERIAL for postgres
  }
}, { sequelize });

class Collection extends Model {}
Collection.init({
  uuid: {
    type: DataTypes.UUID,
    primaryKey: true
  }
}, { sequelize });</code>
</code></pre><p>And if your model has no primary key at all you can use <code>Model.removeAttribute('id');</code></p><h2>Foreign keys</h2><pre><code class="lang-js"><code class="source-code prettyprint">// 1:1
Organization.belongsTo(User, { foreignKey: 'owner_id' });
User.hasOne(Organization, { foreignKey: 'owner_id' });

// 1:M
Project.hasMany(Task, { foreignKey: 'tasks_pk' });
Task.belongsTo(Project, { foreignKey: 'tasks_pk' });

// N:M
User.belongsToMany(Role, { through: 'user_has_roles', foreignKey: 'user_role_user_id' });
Role.belongsToMany(User, { through: 'user_has_roles', foreignKey: 'roles_identifier' });</code>
</code></pre></div>
        <a data-ice="link" href="manual/legacy.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Migrations</h1><p>Just like you use <a href="https://en.wikipedia.org/wiki/Version_control">version control</a> systems such as <a href="https://en.wikipedia.org/wiki/Git">Git</a> to manage changes in your source code, you can use <strong>migrations</strong> to keep track of changes to the database. With migrations you can transfer your existing database into another state and vice versa: Those state transitions are saved in migration files, which describe how to get to the new state and how to revert the changes in order to get back to the old state.</p><p>You will need the <a href="https://github.com/sequelize/cli">Sequelize Command-Line Interface (CLI)</a>. The CLI ships support for migrations and project bootstrapping.</p><p>A Migration in Sequelize is javascript file which exports two functions, <code>up</code> and <code>down</code>, that dictate how to perform the migration and undo it. You define those functions manually, but you don't call them manually; they will be called automatically by the CLI. In these functions, you should simply perform whatever queries you need, with the help of <code>sequelize.query</code> and whichever other methods Sequelize provides to you. There is no extra magic beyond that.</p><h2>Installing the CLI</h2><p>To install the Sequelize CLI:</p><pre><code class="lang-text"><code class="source-code prettyprint">npm install --save-dev sequelize-cli</code>
</code></pre><p>For details see the <a href="https://github.com/sequelize/cli">CLI GitHub repository</a>.</p><h2>Project bootstrapping</h2><p>To create an empty project you will need to execute <code>init</code> command</p><pre><code class="lang-text"><code class="source-code prettyprint">npx sequelize-cli init</code>
</code></pre><p>This will create following folders</p><ul>
<li><code>config</code>, contains config file, which tells CLI how to connect with database</li>
<li><code>models</code>, contains all models for your project</li>
<li><code>migrations</code>, contains all migration files</li>
<li><code>seeders</code>, contains all seed files</li>
</ul><h3>Configuration</h3><p>Before continuing further we will need to tell the CLI how to connect to the database. To do that let's open default config file <code>config/config.json</code>. It looks something like this:</p><pre><code class="lang-json"><code class="source-code prettyprint">{
  "development": {
    "username": "root",
    "password": null,
    "database": "database_development",
    "host": "127.0.0.1",
    "dialect": "mysql"
  },
  "test": {
    "username": "root",
    "password": null,
    "database": "database_test",
    "host": "127.0.0.1",
    "dialect": "mysql"
  },
  "production": {
    "username": "root",
    "password": null,
    "database": "database_production",
    "host": "127.0.0.1",
    "dialect": "mysql"
  }
}</code>
</code></pre><p>Note that the Sequelize CLI assumes mysql by default. If you're using another dialect, you need to change the content of the <code>"dialect"</code> option.</p><p>Now edit this file and set correct database credentials and dialect. The keys of the objects (e.g. "development") are used on <code>model/index.js</code> for matching <code>process.env.NODE_ENV</code> (When undefined, "development" is a default value).</p><p>Sequelize will use the default connection port for each dialect (for example, for postgres, it is port 5432). If you need to specify a different port, use the <code>"port"</code> field (it is not present by default in <code>config/config.js</code> but you can simply add it).</p><p><strong>Note:</strong> <em>If your database doesn't exist yet, you can just call <code>db:create</code> command. With proper access it will create that database for you.</em></p><h2>Creating the first Model (and Migration)</h2><p>Once you have properly configured CLI config file you are ready to create your first migration. It's as simple as executing a simple command.</p><p>We will use <code>model:generate</code> command. This command requires two options:</p><ul>
<li><code>name</code>: the name of the model;</li>
<li><code>attributes</code>: the list of model attributes.</li>
</ul><p>Let's create a model named <code>User</code>.</p><pre><code class="lang-text"><code class="source-code prettyprint">npx sequelize-cli model:generate --name User --attributes firstName:string,lastName:string,email:string</code>
</code></pre><p>This will:</p><ul>
<li>Create a model file <code>user</code> in <code>models</code> folder;</li>
<li>Create a migration file with name like <code>XXXXXXXXXXXXXX-create-user.js</code> in <code>migrations</code> folder.</li>
</ul><p><strong>Note:</strong> <em>Sequelize will only use Model files, it's the table representation. On the other hand, the migration file is a change in that model or more specifically that table, used by CLI. Treat migrations like a commit or a log for some change in database.</em></p><h2>Running Migrations</h2><p>Until this step, we haven't inserted anything into the database. We have just created the required model and migration files for our first model, <code>User</code>. Now to actually create that table in the database you need to run <code>db:migrate</code> command.</p><pre><code class="lang-text"><code class="source-code prettyprint">npx sequelize-cli db:migrate</code>
</code></pre><p>This command will execute these steps:</p><ul>
<li>Will ensure a table called <code>SequelizeMeta</code> in database. This table is used to record which migrations have run on the current database</li>
<li>Start looking for any migration files which haven't run yet. This is possible by checking <code>SequelizeMeta</code> table. In this case it will run <code>XXXXXXXXXXXXXX-create-user.js</code> migration, which we created in last step.</li>
<li>Creates a table called <code>Users</code> with all columns as specified in its migration file.</li>
</ul><h2>Undoing Migrations</h2><p>Now our table has been created and saved in the database. With migration you can revert to old state by just running a command.</p><p>You can use <code>db:migrate:undo</code>, this command will revert most the recent migration.</p><pre><code class="lang-text"><code class="source-code prettyprint">npx sequelize-cli db:migrate:undo</code>
</code></pre><p>You can revert back to the initial state by undoing all migrations with the <code>db:migrate:undo:all</code> command. You can also revert back to a specific migration by passing its name with the <code>--to</code> option.</p><pre><code class="lang-text"><code class="source-code prettyprint">npx sequelize-cli db:migrate:undo:all --to XXXXXXXXXXXXXX-create-posts.js</code>
</code></pre><h3>Creating the first Seed</h3><p>Suppose we want to insert some data into a few tables by default. If we follow up on the previous example we can consider creating a demo user for the <code>User</code> table.</p><p>To manage all data migrations you can use seeders. Seed files are some change in data that can be used to populate database tables with sample or test data.</p><p>Let's create a seed file which will add a demo user to our <code>User</code> table.</p><pre><code class="lang-text"><code class="source-code prettyprint">npx sequelize-cli seed:generate --name demo-user</code>
</code></pre><p>This command will create a seed file in <code>seeders</code> folder. File name will look something like <code>XXXXXXXXXXXXXX-demo-user.js</code>. It follows the same <code>up / down</code> semantics as the migration files.</p><p>Now we should edit this file to insert demo user to <code>User</code> table.</p><pre><code class="lang-js"><code class="source-code prettyprint">module.exports = {
  up: (queryInterface, Sequelize) =&gt; {
    return queryInterface.bulkInsert('Users', [{
      firstName: 'John',
      lastName: 'Doe',
      email: 'example@example.com',
      createdAt: new Date(),
      updatedAt: new Date()
    }]);
  },
  down: (queryInterface, Sequelize) =&gt; {
    return queryInterface.bulkDelete('Users', null, {});
  }
};</code>
</code></pre><h2>Running Seeds</h2><p>In last step you created a seed file; however, it has not been committed to the database. To do that we run a simple command.</p><pre><code class="lang-text"><code class="source-code prettyprint">npx sequelize-cli db:seed:all</code>
</code></pre><p>This will execute that seed file and a demo user will be inserted into the <code>User</code> table.</p><p><strong>Note:</strong> <em>Seeder execution history is not stored anywhere, unlike migrations, which use the <code>SequelizeMeta</code> table. If you wish to change this behavior, please read the <code>Storage</code> section.</em></p><h2>Undoing Seeds</h2><p>Seeders can be undone if they are using any storage. There are two commands available for that:</p><p>If you wish to undo the most recent seed:</p><pre><code class="lang-text"><code class="source-code prettyprint">npx sequelize-cli db:seed:undo</code>
</code></pre><p>If you wish to undo a specific seed:</p><pre><code class="lang-text"><code class="source-code prettyprint">npx sequelize-cli db:seed:undo --seed name-of-seed-as-in-data</code>
</code></pre><p>If you wish to undo all seeds:</p><pre><code class="lang-text"><code class="source-code prettyprint">npx sequelize-cli db:seed:undo:all</code>
</code></pre><h2>Migration Skeleton</h2><p>The following skeleton shows a typical migration file.</p><pre><code class="lang-js"><code class="source-code prettyprint">module.exports = {
  up: (queryInterface, Sequelize) =&gt; {
    // logic for transforming into the new state
  },
  down: (queryInterface, Sequelize) =&gt; {
    // logic for reverting the changes
  }
}</code>
</code></pre><p>We can generate this file using <code>migration:generate</code>. This will create <code>xxx-migration-skeleton.js</code> in your migration folder.</p><pre><code class="lang-text"><code class="source-code prettyprint">npx sequelize-cli migration:generate --name migration-skeleton</code>
</code></pre><p>The passed <code>queryInterface</code> object can be used to modify the database. The <code>Sequelize</code> object stores the available data types such as <code>STRING</code> or <code>INTEGER</code>. Function <code>up</code> or <code>down</code> should return a <code>Promise</code>. Let's look at an example:</p><pre><code class="lang-js"><code class="source-code prettyprint">module.exports = {
  up: (queryInterface, Sequelize) =&gt; {
    return queryInterface.createTable('Person', {
      name: Sequelize.DataTypes.STRING,
      isBetaMember: {
        type: Sequelize.DataTypes.BOOLEAN,
        defaultValue: false,
        allowNull: false
      }
    });
  },
  down: (queryInterface, Sequelize) =&gt; {
    return queryInterface.dropTable('Person');
  }
};</code>
</code></pre><p>The following is an example of a migration that performs two changes in the database, using an automatically-managed transaction to ensure that all instructions are successfully executed or rolled back in case of failure:</p><pre><code class="lang-js"><code class="source-code prettyprint">module.exports = {
  up: (queryInterface, Sequelize) =&gt; {
    return queryInterface.sequelize.transaction(t =&gt; {
      return Promise.all([
        queryInterface.addColumn('Person', 'petName', {
          type: Sequelize.DataTypes.STRING
        }, { transaction: t }),
        queryInterface.addColumn('Person', 'favoriteColor', {
          type: Sequelize.DataTypes.STRING,
        }, { transaction: t })
      ]);
    });
  },
  down: (queryInterface, Sequelize) =&gt; {
    return queryInterface.sequelize.transaction(t =&gt; {
      return Promise.all([
        queryInterface.removeColumn('Person', 'petName', { transaction: t }),
        queryInterface.removeColumn('Person', 'favoriteColor', { transaction: t })
      ]);
    });
  }
};</code>
</code></pre><p>The next example is of a migration that has a foreign key. You can use references to specify a foreign key:</p><pre><code class="lang-js"><code class="source-code prettyprint">module.exports = {
  up: (queryInterface, Sequelize) =&gt; {
    return queryInterface.createTable('Person', {
      name: Sequelize.DataTypes.STRING,
      isBetaMember: {
        type: Sequelize.DataTypes.BOOLEAN,
        defaultValue: false,
        allowNull: false
      },
      userId: {
        type: Sequelize.DataTypes.INTEGER,
        references: {
          model: {
            tableName: 'users',
            schema: 'schema'
          },
          key: 'id'
        },
        allowNull: false
      },
    });
  },
  down: (queryInterface, Sequelize) =&gt; {
    return queryInterface.dropTable('Person');
  }
}</code>
</code></pre><p>The next example is of a migration that uses async/await where you create an unique index on a new column, with a manually-managed transaction:</p><pre><code class="lang-js"><code class="source-code prettyprint">module.exports = {
  async up(queryInterface, Sequelize) {
    const transaction = await queryInterface.sequelize.transaction();
    try {
      await queryInterface.addColumn(
        'Person',
        'petName',
        {
          type: Sequelize.DataTypes.STRING,
        },
        { transaction }
      );
      await queryInterface.addIndex(
        'Person',
        'petName',
        {
          fields: 'petName',
          unique: true,
          transaction,
        }
      );
      await transaction.commit();
    } catch (err) {
      await transaction.rollback();
      throw err;
    }
  },
  async down(queryInterface, Sequelize) {
    const transaction = await queryInterface.sequelize.transaction();
    try {
      await queryInterface.removeColumn('Person', 'petName', { transaction });
      await transaction.commit();
    } catch (err) {
      await transaction.rollback();
      throw err;
    }
  }
};</code>
</code></pre><p>The next example is of a migration that creates an unique index composed of multiple fields with a condition, which allows a relation to exist multiple times but only one can satisfy the condition:</p><pre><code class="lang-js"><code class="source-code prettyprint">module.exports = {
  up: (queryInterface, Sequelize) =&gt; {
    queryInterface.createTable('Person', {
      name: Sequelize.DataTypes.STRING,
      bool: {
        type: Sequelize.DataTypes.BOOLEAN,
        defaultValue: false
      }
    }).then((queryInterface, Sequelize) =&gt; {
      queryInterface.addIndex(
        'Person',
        ['name', 'bool'],
        {
          indicesType: 'UNIQUE',
          where: { bool : 'true' },
        }
      );
    });
  },
  down: (queryInterface, Sequelize) =&gt; {
    return queryInterface.dropTable('Person');
  }
}</code>
</code></pre><h3>The <code>.sequelizerc</code> file</h3><p>This is a special configuration file. It lets you specify the following options that you would usually pass as arguments to CLI:</p><ul>
<li><code>env</code>: The environment to run the command in</li>
<li><code>config</code>: The path to the config file</li>
<li><code>options-path</code>: The path to a JSON file with additional options</li>
<li><code>migrations-path</code>: The path to the migrations folder</li>
<li><code>seeders-path</code>: The path to the seeders folder</li>
<li><code>models-path</code>: The path to the models folder</li>
<li><code>url</code>: The database connection string to use. Alternative to using --config files</li>
<li><code>debug</code>: When available show various debug information</li>
</ul><p>Some scenarios where you can use it:</p><ul>
<li>You want to override default path to <code>migrations</code>, <code>models</code>, <code>seeders</code> or <code>config</code> folder.</li>
<li>You want to rename <code>config.json</code> to something else like <code>database.json</code></li>
</ul><p>And a whole lot more. Let's see how you can use this file for custom configuration.</p><p>To begin, let's create the <code>.sequelizerc</code> file in the root directory of your project, with the following content:</p><pre><code class="lang-js"><code class="source-code prettyprint">// .sequelizerc

const path = require('path');

module.exports = {
  'config': path.resolve('config', 'database.json'),
  'models-path': path.resolve('db', 'models'),
  'seeders-path': path.resolve('db', 'seeders'),
  'migrations-path': path.resolve('db', 'migrations')
};</code>
</code></pre><p>With this config you are telling the CLI to:</p><ul>
<li>Use <code>config/database.json</code> file for config settings;</li>
<li>Use <code>db/models</code> as models folder;</li>
<li>Use <code>db/seeders</code> as seeders folder;</li>
<li>Use <code>db/migrations</code> as migrations folder.</li>
</ul><h3>Dynamic configuration</h3><p>The configuration file is by default a JSON file called <code>config.json</code>. But sometimes you need a dynamic configuration, for example to access environment variables or execute some other code to determine the configuration.</p><p>Thankfully, the Sequelize CLI can read from both <code>.json</code> and <code>.js</code> files. This can be setup with <code>.sequelizerc</code> file. You just have to provide the path to your <code>.js</code> file as the <code>config</code> option of your exported object:</p><pre><code class="lang-js"><code class="source-code prettyprint">const path = require('path');

module.exports = {
  'config': path.resolve('config', 'config.js')
}</code>
</code></pre><p>Now the Sequelize CLI will load <code>config/config.js</code> for getting configuration options.</p><p>An example of <code>config/config.js</code> file:</p><pre><code class="lang-js"><code class="source-code prettyprint">const fs = require('fs');

module.exports = {
  development: {
    username: 'database_dev',
    password: 'database_dev',
    database: 'database_dev',
    host: '127.0.0.1',
    port: 3306,
    dialect: 'mysql',
    dialectOptions: {
      bigNumberStrings: true
    }
  },
  test: {
    username: process.env.CI_DB_USERNAME,
    password: process.env.CI_DB_PASSWORD,
    database: process.env.CI_DB_NAME,
    host: '127.0.0.1',
    port: 3306,
    dialect: 'mysql',
    dialectOptions: {
      bigNumberStrings: true
    }
  },
  production: {
    username: process.env.PROD_DB_USERNAME,
    password: process.env.PROD_DB_PASSWORD,
    database: process.env.PROD_DB_NAME,
    host: process.env.PROD_DB_HOSTNAME,
    port: process.env.PROD_DB_PORT,
    dialect: 'mysql',
    dialectOptions: {
      bigNumberStrings: true,
      ssl: {
        ca: fs.readFileSync(__dirname + '/mysql-ca-main.crt')
      }
    }
  }
};</code>
</code></pre><p>The example above also shows how to add custom dialect options to the configuration.</p><h3>Using Babel</h3><p>To enable more modern constructions in your migrations and seeders, you can simply install <code>babel-register</code> and require it at the beginning of <code>.sequelizerc</code>:</p><pre><code class="lang-text"><code class="source-code prettyprint">npm i --save-dev babel-register</code>
</code></pre><pre><code class="lang-js"><code class="source-code prettyprint">// .sequelizerc

require("babel-register");

const path = require('path');

module.exports = {
  'config': path.resolve('config', 'config.json'),
  'models-path': path.resolve('models'),
  'seeders-path': path.resolve('seeders'),
  'migrations-path': path.resolve('migrations')
}</code>
</code></pre><p>Of course, the outcome will depend upon your babel configuration (such as in a <code>.babelrc</code> file). Learn more at <a href="https://babeljs.io">babeljs.io</a>.</p><h3>Security tip</h3><p>Use environment variables for config settings. This is because secrets such as passwords should never be part of the source code (and especially not committed to version control).</p><h3>Storage</h3><p>There are three types of storage that you can use: <code>sequelize</code>, <code>json</code>, and <code>none</code>.</p><ul>
<li><code>sequelize</code> : stores migrations and seeds in a table on the sequelize database</li>
<li><code>json</code> : stores migrations and seeds on a json file</li>
<li><code>none</code> : does not store any migration/seed</li>
</ul><h4>Migration Storage</h4><p>By default the CLI will create a table in your database called <code>SequelizeMeta</code> containing an entry for each executed migration. To change this behavior, there are three options you can add to the configuration file. Using <code>migrationStorage</code>, you can choose the type of storage to be used for migrations. If you choose <code>json</code>, you can specify the path of the file using <code>migrationStoragePath</code> or the CLI will write to the file <code>sequelize-meta.json</code>. If you want to keep the information in the database, using <code>sequelize</code>, but want to use a different table, you can change the table name using <code>migrationStorageTableName</code>. Also you can define a different schema for the <code>SequelizeMeta</code> table by providing the <code>migrationStorageTableSchema</code> property.</p><pre><code class="lang-json"><code class="source-code prettyprint">{
  "development": {
    "username": "root",
    "password": null,
    "database": "database_development",
    "host": "127.0.0.1",
    "dialect": "mysql",

    // Use a different storage type. Default: sequelize
    "migrationStorage": "json",

    // Use a different file name. Default: sequelize-meta.json
    "migrationStoragePath": "sequelizeMeta.json",

    // Use a different table name. Default: SequelizeMeta
    "migrationStorageTableName": "sequelize_meta",

    // Use a different schema for the SequelizeMeta table
    "migrationStorageTableSchema": "custom_schema"
  }
}</code>
</code></pre><p><strong>Note:</strong> <em>The <code>none</code> storage is not recommended as a migration storage. If you decide to use it, be aware of the implications of having no record of what migrations did or didn't run.</em></p><h4>Seed Storage</h4><p>By default the CLI will not save any seed that is executed. If you choose to change this behavior (!), you can use <code>seederStorage</code> in the configuration file to change the storage type. If you choose <code>json</code>, you can specify the path of the file using <code>seederStoragePath</code> or the CLI will write to the file <code>sequelize-data.json</code>. If you want to keep the information in the database, using <code>sequelize</code>, you can specify the table name using <code>seederStorageTableName</code>, or it will default to <code>SequelizeData</code>.</p><pre><code class="lang-json"><code class="source-code prettyprint">{
  "development": {
    "username": "root",
    "password": null,
    "database": "database_development",
    "host": "127.0.0.1",
    "dialect": "mysql",
    // Use a different storage. Default: none
    "seederStorage": "json",
    // Use a different file name. Default: sequelize-data.json
    "seederStoragePath": "sequelizeData.json",
    // Use a different table name. Default: SequelizeData
    "seederStorageTableName": "sequelize_data"
  }
}</code>
</code></pre><h3>Configuration Connection String</h3><p>As an alternative to the <code>--config</code> option with configuration files defining your database, you can use the <code>--url</code> option to pass in a connection string. For example:</p><pre><code class="lang-text"><code class="source-code prettyprint">npx sequelize-cli db:migrate --url 'mysql://root:password@mysql_host.com/database_name'</code>
</code></pre><h3>Programmatic usage</h3><p>Sequelize has a sister library called <a href="https://github.com/sequelize/umzug">umzug</a> for programmatically handling execution and logging of migration tasks.</p></div>
        <a data-ice="link" href="manual/migrations.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>TypeScript</h1><p>Sequelize provides its own TypeScript definitions.</p><p>Please note that only <strong>TypeScript &gt;= 4.1</strong> is supported.
Our TypeScript support does not follow SemVer. We will support TypeScript releases for at least one year, after which they may be dropped in a SemVer MINOR release.</p><p>As Sequelize heavily relies on runtime property assignments, TypeScript won't be very useful out of the box.
A decent amount of manual type declarations are needed to make models workable.</p><h2>Installation</h2><p>In order to avoid clashes with different Node versions, the typings for Node are not included. You must install <code>@types/node</code> manually.</p><h2>Usage</h2><p><strong>Important</strong>: You must use <code>declare</code> on your class properties typings to ensure TypeScript does not emit those class properties.
See <a href="./manual/./model-basics.html#caveat-with-public-class-fields">Caveat with Public Class Fields</a></p><p>Sequelize Models accept two generic types to define what the model's Attributes &amp; Creation Attributes are like:</p><pre><code class="lang-typescript"><code class="source-code prettyprint">import { Model, Optional } from 'sequelize';

// We don't recommend doing this. Read on for the new way of declaring Model typings.

type UserAttributes = {
  id: number,
  name: string,
  // other attributes...
};

// we're telling the Model that 'id' is optional
// when creating an instance of the model (such as using Model.create()).
type UserCreationAttributes = Optional&lt;UserAttributes, 'id'&gt;;

class User extends Model&lt;UserAttributes, UserCreationAttributes&gt; {
  declare id: number;
  declare string: number;
  // other attributes...
}</code>
</code></pre><p>This solution is verbose. Sequelize &gt;=6.14.0 provides new utility types that will drastically reduce the amount
of boilerplate necessary: <code>InferAttributes</code>, and <code>InferCreationAttributes</code>. They will extract Attribute typings
directly from the Model:</p><pre><code class="lang-typescript"><code class="source-code prettyprint">import { Model, InferAttributes, InferCreationAttributes, CreationOptional } from 'sequelize';

// order of InferAttributes &amp; InferCreationAttributes is important.
class User extends Model&lt;InferAttributes&lt;User&gt;, InferCreationAttributes&lt;User&gt;&gt; {
  // 'CreationOptional' is a special type that marks the field as optional
  // when creating an instance of the model (such as using Model.create()).
  declare id: CreationOptional&lt;number&gt;;
  declare string: number;
  // other attributes...
}</code>
</code></pre><p>Important things to know about <code>InferAttributes</code> &amp; <code>InferCreationAttributes</code> work: They will select all declared properties of the class except:</p><ul>
<li>Static fields and methods.</li>
<li>Methods (anything whose type is a function).</li>
<li>Those whose type uses the branded type <code>NonAttribute</code>.</li>
<li>Those excluded by using AttributesOf like this: <code>InferAttributes&lt;User, { omit: 'properties' | 'to' | 'omit' }&gt;</code>.</li>
<li>Those declared by the Model superclass (but not intermediary classes!).
If one of your attributes shares the same name as one of the properties of <code>Model</code>, change its name.
Doing this is likely to cause issues anyway.</li>
<li>Getter &amp; setters are not automatically excluded. Set their return / parameter type to <code>NonAttribute</code>,
or add them to <code>omit</code> to exclude them.</li>
</ul><p><code>InferCreationAttributes</code> works the same way as <code>AttributesOf</code> with one exception: Properties typed using the <code>CreationOptional</code> type
will be marked as optional.
Note that attributes that accept <code>null</code>, or <code>undefined</code> do not need to use <code>CreationOptional</code>:</p><pre><code class="lang-typescript"><code class="source-code prettyprint">class User extends Model&lt;InferAttributes&lt;User&gt;, InferCreationAttributes&lt;User&gt;&gt; {
  declare firstName: string;

  // there is no need to use CreationOptional on firstName because nullable attributes
  // are always optional in User.create()
  declare lastName: string | null;
}

// ...

await User.create({
  firstName: 'Zoé',
  // last name omitted, but this is still valid!
});</code>
</code></pre><p>You only need to use <code>CreationOptional</code> &amp; <code>NonAttribute</code> on class instance fields or getters.</p><p>Example of a minimal TypeScript project with strict type-checking for attributes:</p><pre><code class="lang-typescript"><code class="source-code prettyprint">import {
  Association, DataTypes, HasManyAddAssociationMixin, HasManyCountAssociationsMixin,
  HasManyCreateAssociationMixin, HasManyGetAssociationsMixin, HasManyHasAssociationMixin,
  HasManySetAssociationsMixin, HasManyAddAssociationsMixin, HasManyHasAssociationsMixin,
  HasManyRemoveAssociationMixin, HasManyRemoveAssociationsMixin, Model, ModelDefined, Optional,
  Sequelize, InferAttributes, InferCreationAttributes, CreationOptional, NonAttribute
} from 'sequelize';

const sequelize = new Sequelize('mysql://root:asd123@localhost:3306/mydb');

// 'projects' is excluded as it's not an attribute, it's an association.
class User extends Model&lt;InferAttributes&lt;User, { omit: 'projects' }&gt;, InferCreationAttributes&lt;User, { omit: 'projects' }&gt;&gt; {
  // id can be undefined during creation when using `autoIncrement`
  declare id: CreationOptional&lt;number&gt;;
  declare name: string;
  declare preferredName: string | null; // for nullable fields

  // timestamps!
  // createdAt can be undefined during creation
  declare createdAt: CreationOptional&lt;Date&gt;;
  // updatedAt can be undefined during creation
  declare updatedAt: CreationOptional&lt;Date&gt;;

  // Since TS cannot determine model association at compile time
  // we have to declare them here purely virtually
  // these will not exist until `Model.init` was called.
  declare getProjects: HasManyGetAssociationsMixin&lt;Project&gt;;
  declare addProject: HasManyAddAssociationMixin&lt;Project, number&gt;;
  declare addProjects: HasManyAddAssociationsMixin&lt;Project, number&gt;;
  declare setProjects: HasManySetAssociationsMixin&lt;Project, number&gt;;
  declare removeProject: HasManyRemoveAssociationMixin&lt;Project, number&gt;;
  declare removeProjects: HasManyRemoveAssociationsMixin&lt;Project, number&gt;;
  declare hasProject: HasManyHasAssociationMixin&lt;Project, number&gt;;
  declare hasProjects: HasManyHasAssociationsMixin&lt;Project, number&gt;;
  declare countProjects: HasManyCountAssociationsMixin;
  declare createProject: HasManyCreateAssociationMixin&lt;Project, 'ownerId'&gt;;

  // You can also pre-declare possible inclusions, these will only be populated if you
  // actively include a relation.
  declare projects?: NonAttribute&lt;Project[]&gt;; // Note this is optional since it's only populated when explicitly requested in code

  // getters that are not attributes should be tagged using NonAttribute
  // to remove them from the model's Attribute Typings.
  get fullName(): NonAttribute&lt;string&gt; {
    return this.name;
  }

  declare static associations: {
    projects: Association&lt;User, Project&gt;;
  };
}

class Project extends Model&lt;
  InferAttributes&lt;Project&gt;,
  InferCreationAttributes&lt;Project&gt;
&gt; {
  // id can be undefined during creation when using `autoIncrement`
  declare id: CreationOptional&lt;number&gt;;
  declare ownerId: number;
  declare name: string;

  // `owner` is an eagerly-loaded association.
  // We tag it as `NonAttribute`
  declare owner?: NonAttribute&lt;User&gt;;

  // createdAt can be undefined during creation
  declare createdAt: CreationOptional&lt;Date&gt;;
  // updatedAt can be undefined during creation
  declare updatedAt: CreationOptional&lt;Date&gt;;
}

class Address extends Model&lt;
  InferAttributes&lt;Address&gt;,
  InferCreationAttributes&lt;Address&gt;
&gt; {
  declare userId: number;
  declare address: string;

  // createdAt can be undefined during creation
  declare createdAt: CreationOptional&lt;Date&gt;;
  // updatedAt can be undefined during creation
  declare updatedAt: CreationOptional&lt;Date&gt;;
}

Project.init(
  {
    id: {
      type: DataTypes.INTEGER.UNSIGNED,
      autoIncrement: true,
      primaryKey: true
    },
    ownerId: {
      type: DataTypes.INTEGER.UNSIGNED,
      allowNull: false
    },
    name: {
      type: new DataTypes.STRING(128),
      allowNull: false
    },
    createdAt: DataTypes.DATE,
    updatedAt: DataTypes.DATE,
  },
  {
    sequelize,
    tableName: 'projects'
  }
);

User.init(
  {
    id: {
      type: DataTypes.INTEGER.UNSIGNED,
      autoIncrement: true,
      primaryKey: true
    },
    name: {
      type: new DataTypes.STRING(128),
      allowNull: false
    },
    preferredName: {
      type: new DataTypes.STRING(128),
      allowNull: true
    },
    createdAt: DataTypes.DATE,
    updatedAt: DataTypes.DATE,
  },
  {
    tableName: 'users',
    sequelize // passing the `sequelize` instance is required
  }
);

Address.init(
  {
    userId: {
      type: DataTypes.INTEGER.UNSIGNED
    },
    address: {
      type: new DataTypes.STRING(128),
      allowNull: false
    },
    createdAt: DataTypes.DATE,
    updatedAt: DataTypes.DATE,
  },
  {
    tableName: 'address',
    sequelize // passing the `sequelize` instance is required
  }
);

// You can also define modules in a functional way
interface NoteAttributes {
  id: number;
  title: string;
  content: string;
}

// You can also set multiple attributes optional at once
type NoteCreationAttributes = Optional&lt;NoteAttributes, 'id' | 'title'&gt;;

// And with a functional approach defining a module looks like this
const Note: ModelDefined&lt;
  NoteAttributes,
  NoteCreationAttributes
&gt; = sequelize.define(
  'Note',
  {
    id: {
      type: DataTypes.INTEGER.UNSIGNED,
      autoIncrement: true,
      primaryKey: true
    },
    title: {
      type: new DataTypes.STRING(64),
      defaultValue: 'Unnamed Note'
    },
    content: {
      type: new DataTypes.STRING(4096),
      allowNull: false
    }
  },
  {
    tableName: 'notes'
  }
);

// Here we associate which actually populates out pre-declared `association` static and other methods.
User.hasMany(Project, {
  sourceKey: 'id',
  foreignKey: 'ownerId',
  as: 'projects' // this determines the name in `associations`!
});

Address.belongsTo(User, { targetKey: 'id' });
User.hasOne(Address, { sourceKey: 'id' });

async function doStuffWithUser() {
  const newUser = await User.create({
    name: 'Johnny',
    preferredName: 'John',
  });
  console.log(newUser.id, newUser.name, newUser.preferredName);

  const project = await newUser.createProject({
    name: 'first!'
  });

  const ourUser = await User.findByPk(1, {
    include: [User.associations.projects],
    rejectOnEmpty: true // Specifying true here removes `null` from the return type!
  });

  // Note the `!` null assertion since TS can't know if we included
  // the model or not
  console.log(ourUser.projects![0].name);
}

(async () =&gt; {
  await sequelize.sync();
  await doStuffWithUser();
})();</code>
</code></pre><h3>Usage without strict types for attributes</h3><p>The typings for Sequelize v5 allowed you to define models without specifying types for the attributes. This is still possible for backwards compatibility and for cases where you feel strict typing for attributes isn't worth it.</p><pre><code class="lang-ts"><code class="source-code prettyprint">import { Sequelize, Model, DataTypes } from "sequelize";

const sequelize = new Sequelize("mysql://root:asd123@localhost:3306/mydb");

class User extends Model {
  declare id: number;
  declare name: string;
  declare preferredName: string | null;
}

User.init(
  {
    id: {
      type: DataTypes.INTEGER.UNSIGNED,
      autoIncrement: true,
      primaryKey: true,
    },
    name: {
      type: new DataTypes.STRING(128),
      allowNull: false,
    },
    preferredName: {
      type: new DataTypes.STRING(128),
      allowNull: true,
    },
  },
  {
    tableName: "users",
    sequelize, // passing the `sequelize` instance is required
  }
);

async function doStuffWithUserModel() {
  const newUser = await User.create({
    name: "Johnny",
    preferredName: "John",
  });
  console.log(newUser.id, newUser.name, newUser.preferredName);

  const foundUser = await User.findOne({ where: { name: "Johnny" } });
  if (foundUser === null) return;
  console.log(foundUser.name);
}</code>
</code></pre><h2>Usage of <code>sequelize.define</code></h2><p>In Sequelize versions before v5, the default way of defining a model involved using <code>sequelize.define</code>. It's still possible to define models with that, and you can also add typings to these models using interfaces.</p><pre><code class="lang-ts"><code class="source-code prettyprint">import { Sequelize, Model, DataTypes, Optional } from "sequelize";

const sequelize = new Sequelize("mysql://root:asd123@localhost:3306/mydb");

// We recommend you declare an interface for the attributes, for stricter typechecking
interface UserAttributes {
  id: number;
  name: string;
}

// Some fields are optional when calling UserModel.create() or UserModel.build()
interface UserCreationAttributes extends Optional&lt;UserAttributes, "id"&gt; {}

// We need to declare an interface for our model that is basically what our class would be
interface UserInstance
  extends Model&lt;UserAttributes, UserCreationAttributes&gt;,
    UserAttributes {}

const UserModel = sequelize.define&lt;UserInstance&gt;("User", {
  id: {
    primaryKey: true,
    type: DataTypes.INTEGER.UNSIGNED,
  },
  name: {
    type: DataTypes.STRING,
  },
});

async function doStuff() {
  const instance = await UserModel.findByPk(1, {
    rejectOnEmpty: true,
  });
  console.log(instance.id);
}</code>
</code></pre><p>If you're comfortable with somewhat less strict typing for the attributes on a model, you can save some code by defining the Instance to just extend <code>Model</code> without any attributes in the generic types.</p><pre><code class="lang-ts"><code class="source-code prettyprint">import { Sequelize, Model, DataTypes } from "sequelize";

const sequelize = new Sequelize("mysql://root:asd123@localhost:3306/mydb");

// We need to declare an interface for our model that is basically what our class would be
interface UserInstance extends Model {
  id: number;
  name: string;
}

const UserModel = sequelize.define&lt;UserInstance&gt;("User", {
  id: {
    primaryKey: true,
    type: DataTypes.INTEGER.UNSIGNED,
  },
  name: {
    type: DataTypes.STRING,
  },
});

async function doStuff() {
  const instance = await UserModel.findByPk(1, {
    rejectOnEmpty: true,
  });
  console.log(instance.id);
}</code>
</code></pre><h2>Utility Types</h2><h3>Requesting a Model Class</h3><p><code>ModelStatic</code> is designed to be used to type a Model <em>class</em>.</p><p>Here is an example of a utility method that requests a Model Class, and returns the list of primary keys defined in that class:</p><pre><code class="lang-typescript"><code class="source-code prettyprint">import { ModelStatic, ModelAttributeColumnOptions, Model, InferAttributes, InferCreationAttributes, CreationOptional } from 'sequelize';

/**
 * Returns the list of attributes that are part of the model's primary key.
 */
export function getPrimaryKeyAttributes(model: ModelStatic&lt;any&gt;): ModelAttributeColumnOptions[] {
  const attributes: ModelAttributeColumnOptions[] = [];

  for (const attribute of Object.values(model.rawAttributes)) {
    if (attribute.primaryKey) {
      attributes.push(attribute);
    }
  }

  return attributes;
}

class User extends Model&lt;InferAttributes&lt;User&gt;, InferCreationAttributes&lt;User&gt;&gt; {
  id: CreationOptional&lt;number&gt;;
}

User.init({
  id: {
    type: DataTypes.INTEGER.UNSIGNED,
    autoIncrement: true,
    primaryKey: true
  },
}, { sequelize });

const primaryAttributes = getPrimaryKeyAttributes(User);</code>
</code></pre><h3>Getting a Model's attributes</h3><p>If you need to access the list of attributes of a given model, <code>Attributes&lt;Model&gt;</code> and <code>CreationAttributes&lt;Model&gt;</code>
are what you need to use.</p><p>They will return the Attributes (and Creation Attributes) of the Model passed as a parameter.</p><p>Don't confuse them with <code>InferAttributes</code> and <code>InferCreationAttributes</code>. These two utility types should only every be used
in the definition of a Model to automatically create the list of attributes from the model's public class fields. They only work
with class-based model definitions (When using <code>Model.init</code>).</p><p><code>Attributes&lt;Model&gt;</code> and <code>CreationAttributes&lt;Model&gt;</code> will return the list of attributes of any model, no matter how they were created (be it <code>Model.init</code> or <code>Sequelize#define</code>).</p><p>Here is an example of a utility function that requests a Model Class, and the name of an attribute ; and returns the corresponding attribute metadata.</p><pre><code class="lang-typescript"><code class="source-code prettyprint">import {
  ModelStatic,
  ModelAttributeColumnOptions,
  Model,
  InferAttributes,
  InferCreationAttributes,
  CreationOptional,
  Attributes
} from 'sequelize';

export function getAttributeMetadata&lt;M extends Model&gt;(model: ModelStatic&lt;M&gt;, attributeName: keyof Attributes&lt;M&gt;): ModelAttributeColumnOptions {
  const attribute = model.rawAttributes[attributeName];
  if (attribute == null) {
    throw new Error(`Attribute ${attributeName} does not exist on model ${model.name}`);
  }

  return attribute;
}

class User extends Model&lt;InferAttributes&lt;User&gt;, InferCreationAttributes&lt;User&gt;&gt; {
  id: CreationOptional&lt;number&gt;;
}

User.init({
  id: {
    type: DataTypes.INTEGER.UNSIGNED,
    autoIncrement: true,
    primaryKey: true
  },
}, { sequelize });

const idAttributeMeta = getAttributeMetadata(User, 'id'); // works!

// @ts-expect-error
const nameAttributeMeta = getAttributeMetadata(User, 'name'); // fails because 'name' is not an attribute of User</code>
</code></pre></div>
        <a data-ice="link" href="manual/typescript.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Resources</h1><h2>Addons &amp; Plugins</h2><h3>ACL</h3><ul>
<li><a href="https://github.com/pumpupapp/ssacl">ssacl</a></li>
<li><a href="https://github.com/mickhansen/ssacl-attribute-roles">ssacl-attribute-roles</a></li>
<li><a href="https://github.com/lotivo/sequelize-acl">SequelizeGuard</a> - Role, Permission based Authorization for Sequelize.</li>
</ul><h3>Auto Code Generation &amp; Scaffolding</h3><ul>
<li><a href="https://www.datensen.com/">meteor modeler</a> - Desktop tool for visual definition of Sequelize models and asssociations.</li>
<li><a href="https://github.com/tomjschuster/sequelize-ui">sequelize-ui</a> - Online tool for building models, relations and more.</li>
<li><a href="https://github.com/andyforever/sequelizer">sequelizer</a> - A GUI Desktop App for generating Sequelize models. Support for Mysql, Mariadb, Postgres, Sqlite, Mssql.</li>
<li><a href="https://github.com/sequelize/sequelize-auto">sequelize-auto</a> Generating models for SequelizeJS via the command line is another choice.</li>
<li><a href="http://www.pg-generator.com/builtin-templates/sequelize/">pg-generator</a> - Auto generate/scaffold Sequelize models for PostgreSQL database.</li>
<li><a href="https://www.npmjs.com/package/sequelizejs-decorators">sequelizejs-decorators</a> decorators for composing sequelize models</li>
</ul><h3>Autoloader</h3><ul>
<li><a href="https://github.com/boxsnake-nodejs/sequelize-autoload">sequelize-autoload</a> - An autoloader for Sequelize, inspired by <a href="https://www.php-fig.org/psr/psr-0/">PSR-0</a> and <a href="https://www.php-fig.org/psr/psr-4/">PSR-4</a>.</li>
</ul><h3>Bcrypt</h3><ul>
<li><a href="https://github.com/mattiamalonni/sequelize-bcrypt">sequelize-bcrypt</a> - Utility to integrate bcrypt into sequelize models</li>
</ul><h3>Caching</h3><ul>
<li><a href="https://github.com/DanielHreben/sequelize-transparent-cache">sequelize-transparent-cache</a></li>
</ul><h3>Filters</h3><ul>
<li><a href="https://www.npmjs.com/package/sequelize-transforms">sequelize-transforms</a> - Add configurable attribute transforms.</li>
</ul><h3>Fixtures / mock data</h3><ul>
<li><a href="https://github.com/olalonde/fixer">Fixer</a></li>
<li><a href="https://github.com/domasx2/sequelize-fixtures">Sequelize-fixtures</a></li>
<li><a href="https://github.com/xudejian/sequelize-fixture">Sequelize-fixture</a></li>
</ul><h3>Hierarchies</h3><ul>
<li><a href="https://www.npmjs.com/package/sequelize-hierarchy">sequelize-hierarchy</a> - Nested hierarchies for Sequelize.</li>
</ul><h3>Historical records / Time travel</h3><ul>
<li><a href="https://github.com/bonaval/sequelize-temporal">sequelize-temporal</a> - Temporal tables (aka historical records)</li>
</ul><h3>Joi</h3><ul>
<li><a href="https://github.com/mattiamalonni/sequelize-joi">sequelize-joi</a> - Allows specifying <a href="https://github.com/sideway/joi">Joi</a> validation schema for model attributes in Sequelize.</li>
</ul><h3>Migrations</h3><ul>
<li><a href="https://github.com/sequelize/umzug">umzug</a></li>
</ul><h3>Slugification</h3><ul>
<li><a href="https://www.npmjs.com/package/sequelize-slugify">sequelize-slugify</a> - Add slugs to sequelize models</li>
</ul><h3>Tokens</h3><ul>
<li><a href="https://github.com/pipll/sequelize-tokenify">sequelize-tokenify</a> - Add unique tokens to sequelize models</li>
</ul><h3>Miscellaneous</h3><ul>
<li><a href="https://www.npmjs.com/package/sequelize-deep-update">sequelize-deep-update</a> - Update a sequelize instance and its included associated instances with new properties.</li>
<li><a href="https://www.npmjs.com/package/sequelize-noupdate-attributes">sequelize-noupdate-attributes</a> - Adds no update/readonly attributes support to models.</li>
<li><a href="https://github.com/google/sqlcommenter/tree/master/nodejs/sqlcommenter-nodejs/packages/sqlcommenter-sequelize">sqlcommenter-sequelize</a> A <a href="https://google.github.io/sqlcommenter/">sqlcommenter</a> plugin with <a href="https://google.github.io/sqlcommenter/node/sequelize/">support for Sequelize</a> to augment SQL statements with comments that can be used later to correlate application code with SQL statements.</li>
</ul></div>
        <a data-ice="link" href="manual/resources.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Upgrade to v6</h1><p>Sequelize v6 is the next major release after v5. Below is a list of breaking changes to help you upgrade.</p><h2>Breaking Changes</h2><h3>Support for Node 10 and up</h3><p>Sequelize v6 will only support Node 10 and up <a href="https://github.com/sequelize/sequelize/issues/10821">#10821</a>.</p><h3>CLS</h3><p>You should now use <a href="https://github.com/Jeff-Lewis/cls-hooked">cls-hooked</a> package for CLS support.</p><pre><code class="lang-js"><code class="source-code prettyprint">const cls = require("cls-hooked");
const namespace = cls.createNamespace("....");
const Sequelize = require("sequelize");

Sequelize.useCLS(namespace);</code>
</code></pre><h3>Database Engine Support</h3><p>We have updated our minimum supported database engine versions. Using older database engine will show <code>SEQUELIZE0006</code> deprecation warning. Please check <a href="https://github.com/sequelize/sequelize/blob/main/ENGINE.md">ENGINE.md</a> for version table.</p><h3>Sequelize</h3><ul>
<li>Bluebird has been removed. Internally all methods are now using async/await. Public API now returns native promises. Thanks to <a href="https://github.com/jedwards1211">Andy Edwards</a> for this refactor work.</li>
<li><code>Sequelize.Promise</code> is no longer available.</li>
<li><code>sequelize.import</code> method has been removed. CLI users should update to <code>sequelize-cli@6</code>.</li>
<li>All instances of QueryInterface and QueryGenerator have been renamed to their lowerCamelCase variants eg. queryInterface and queryGenerator when used as property names on Model and Dialect, the class names remain the same.</li>
</ul><h3>Model</h3><h4><code>options.returning</code></h4><p>Option <code>returning: true</code> will no longer return attributes that are not defined in the model. Old behavior can be achieved by using <code>returning: ['*']</code> instead.</p><h4><code>Model.changed()</code></h4><p>This method now tests for equality with <a href="https://lodash.com/docs/4.17.15#isEqual"><code>_.isEqual</code></a> and is now deep aware for JSON objects. Modifying a nested value for a JSON object won't mark it as changed (since it is still the same object).</p><pre><code class="lang-js"><code class="source-code prettyprint">const instance = await MyModel.findOne();

instance.myJsonField.someProperty = 12345; // Changed from something else to 12345
console.log(instance.changed()); // false

await instance.save(); // this will not save anything

instance.changed("myJsonField", true);
console.log(instance.changed()); // ['myJsonField']

await instance.save(); // will save</code>
</code></pre><h4><code>Model.bulkCreate()</code></h4><p>This method now throws <code>Sequelize.AggregateError</code> instead of <code>Bluebird.AggregateError</code>. All errors are now exposed as <code>errors</code> key.</p><h4><code>Model.upsert()</code></h4><p>Native upsert is now supported for all dialects.</p><pre><code class="lang-js"><code class="source-code prettyprint">const [instance, created] = await MyModel.upsert({});</code>
</code></pre><p>Signature for this method has been changed to <code>Promise&lt;Model,boolean | null&gt;</code>. First index contains upserted <code>instance</code>, second index contains a boolean (or <code>null</code>) indicating if record was created or updated. For SQLite/Postgres, <code>created</code> value will always be <code>null</code>.</p><ul>
<li>MySQL - Implemented with ON DUPLICATE KEY UPDATE</li>
<li>PostgreSQL - Implemented with ON CONFLICT DO UPDATE</li>
<li>SQLite - Implemented with ON CONFLICT DO UPDATE</li>
<li>MSSQL - Implemented with MERGE statement</li>
</ul><p><em>&lt;ins&gt;Note for Postgres users:&lt;/ins&gt;</em> If upsert payload contains PK field, then PK will be used as the conflict target. Otherwise first unique constraint will be selected as the conflict key.</p><h3>QueryInterface</h3><h4><code>addConstraint</code></h4><p>This method now only takes 2 parameters, <code>tableName</code> and <code>options</code>. Previously the second parameter could be a list of column names to apply the constraint to, this list must now be passed as <code>options.fields</code> property.</p><h2>Changelog</h2><h3>6.0.0-beta.7</h3><ul>
<li>docs(associations): belongs to many create with through table</li>
<li>docs(query-interface): fix broken links <a href="https://github.com/sequelize/sequelize/pull/12272">#12272</a></li>
<li>docs(sequelize): omitNull only works for CREATE/UPDATE queries</li>
<li>docs: asyncify <a href="https://github.com/sequelize/sequelize/pull/12297">#12297</a></li>
<li>docs: responsive <a href="https://github.com/sequelize/sequelize/pull/12308">#12308</a></li>
<li>docs: update feature request template</li>
<li>feat(postgres): native upsert <a href="https://github.com/sequelize/sequelize/pull/12301">#12301</a></li>
<li>feat(sequelize): allow passing dialectOptions.options from url <a href="https://github.com/sequelize/sequelize/pull/12404">#12404</a></li>
<li>fix(include): check if attributes specified for included through model <a href="https://github.com/sequelize/sequelize/pull/12316">#12316</a></li>
<li>fix(model.destroy): return 0 with truncate <a href="https://github.com/sequelize/sequelize/pull/12281">#12281</a></li>
<li>fix(mssql): empty order array generates invalid FETCH statement <a href="https://github.com/sequelize/sequelize/pull/12261">#12261</a></li>
<li>fix(postgres): parse enums correctly when describing a table <a href="https://github.com/sequelize/sequelize/pull/12409">#12409</a></li>
<li>fix(query): ensure correct return signature for QueryTypes.RAW <a href="https://github.com/sequelize/sequelize/pull/12305">#12305</a></li>
<li>fix(query): preserve cls context for logger <a href="https://github.com/sequelize/sequelize/pull/12328">#12328</a></li>
<li>fix(query-generator): do not generate GROUP BY clause if options.group is empty <a href="https://github.com/sequelize/sequelize/pull/12343">#12343</a></li>
<li>fix(reload): include default scope <a href="https://github.com/sequelize/sequelize/pull/12399">#12399</a></li>
<li>fix(types): add Association into OrderItem type <a href="https://github.com/sequelize/sequelize/pull/12332">#12332</a></li>
<li>fix(types): add clientMinMessages to Options interface <a href="https://github.com/sequelize/sequelize/pull/12375">#12375</a></li>
<li>fix(types): transactionType in Options <a href="https://github.com/sequelize/sequelize/pull/12377">#12377</a></li>
<li>fix(types): add support for optional values in "where" clauses <a href="https://github.com/sequelize/sequelize/pull/12337">#12337</a></li>
<li>fix(types): add missing fields to 'FindOrCreateType' <a href="https://github.com/sequelize/sequelize/pull/12338">#12338</a></li>
<li>fix: add missing sql and parameters properties to some query errors <a href="https://github.com/sequelize/sequelize/pull/12299">#12299</a></li>
<li>fix: remove custom inspect <a href="https://github.com/sequelize/sequelize/pull/12262">#12262</a></li>
<li>refactor: cleanup query generators <a href="https://github.com/sequelize/sequelize/pull/12304">#12304</a></li>
</ul><h3>6.0.0-beta.6</h3><ul>
<li>docs(add-constraint): options.fields support</li>
<li>docs(association): document uniqueKey for belongs to many <a href="https://github.com/sequelize/sequelize/pull/12166">#12166</a></li>
<li>docs(association): options.through.where support</li>
<li>docs(association): use and instead of 'a nd' <a href="https://github.com/sequelize/sequelize/pull/12191">#12191</a></li>
<li>docs(association): use correct scope name <a href="https://github.com/sequelize/sequelize/pull/12204">#12204</a></li>
<li>docs(manuals): avoid duplicate header ids <a href="https://github.com/sequelize/sequelize/pull/12201">#12201</a></li>
<li>docs(model): correct syntax error in example code <a href="https://github.com/sequelize/sequelize/pull/12137">#12137</a></li>
<li>docs(query-interface): removeIndex indexNameOrAttributes <a href="https://github.com/sequelize/sequelize/pull/11947">#11947</a></li>
<li>docs(resources): add sequelize-guard library <a href="https://github.com/sequelize/sequelize/pull/12235">#12235</a></li>
<li>docs(typescript): fix confusing comments <a href="https://github.com/sequelize/sequelize/pull/12226">#12226</a></li>
<li>docs(v6-guide): bluebird removal API changes</li>
<li>docs: database version support info <a href="https://github.com/sequelize/sequelize/pull/12168">#12168</a></li>
<li>docs: remove remaining bluebird references <a href="https://github.com/sequelize/sequelize/pull/12167">#12167</a></li>
<li>feat(belongs-to-many): allow creation of paranoid join tables <a href="https://github.com/sequelize/sequelize/pull/12088">#12088</a></li>
<li>feat(belongs-to-many): get/has/count for paranoid join table <a href="https://github.com/sequelize/sequelize/pull/12256">#12256</a></li>
<li>feat(pool): expose maxUses pool config option <a href="https://github.com/sequelize/sequelize/pull/12101">#12101</a></li>
<li>feat(postgres): minify include aliases over limit <a href="https://github.com/sequelize/sequelize/pull/11940">#11940</a></li>
<li>feat(sequelize): handle query string host value <a href="https://github.com/sequelize/sequelize/pull/12041">#12041</a></li>
<li>fix(associations): ensure correct schema on all generated attributes <a href="https://github.com/sequelize/sequelize/pull/12258">#12258</a></li>
<li>fix(docs/instances): use correct variable for increment <a href="https://github.com/sequelize/sequelize/pull/12087">#12087</a></li>
<li>fix(include): separate queries are not sub-queries <a href="https://github.com/sequelize/sequelize/pull/12144">#12144</a></li>
<li>fix(model): fix unchained promise in association logic in bulkCreate <a href="https://github.com/sequelize/sequelize/pull/12163">#12163</a></li>
<li>fix(model): updateOnDuplicate handles composite keys <a href="https://github.com/sequelize/sequelize/pull/11984">#11984</a></li>
<li>fix(model.count): distinct without any column generates invalid SQL <a href="https://github.com/sequelize/sequelize/pull/11946">#11946</a></li>
<li>fix(model.reload): ignore options.where and always use this.where() <a href="https://github.com/sequelize/sequelize/pull/12211">#12211</a></li>
<li>fix(mssql) insert record failure because of BOOLEAN column type <a href="https://github.com/sequelize/sequelize/pull/12090">#12090</a></li>
<li>fix(mssql): cast sql_variant in query generator <a href="https://github.com/sequelize/sequelize/pull/11994">#11994</a></li>
<li>fix(mssql): dont use OUTPUT INSERTED for update without returning <a href="https://github.com/sequelize/sequelize/pull/12260">#12260</a></li>
<li>fix(mssql): duplicate order in FETCH/NEXT queries <a href="https://github.com/sequelize/sequelize/pull/12257">#12257</a></li>
<li>fix(mssql): set correct scale for float <a href="https://github.com/sequelize/sequelize/pull/11962">#11962</a></li>
<li>fix(mssql): tedious v9 requires connect call <a href="https://github.com/sequelize/sequelize/pull/12182">#12182</a></li>
<li>fix(mssql): use uppercase for engine table and columns <a href="https://github.com/sequelize/sequelize/pull/12212">#12212</a></li>
<li>fix(pool): show deprecation when engine is not supported <a href="https://github.com/sequelize/sequelize/pull/12218">#12218</a></li>
<li>fix(postgres): addColumn support ARRAY(ENUM) <a href="https://github.com/sequelize/sequelize/pull/12259">#12259</a></li>
<li>fix(query): do not bind \$ used within a whole-word <a href="https://github.com/sequelize/sequelize/pull/12250">#12250</a></li>
<li>fix(query-generator): handle literal for substring based operators <a href="https://github.com/sequelize/sequelize/pull/12210">#12210</a></li>
<li>fix(query-interface): allow passing null for query interface insert <a href="https://github.com/sequelize/sequelize/pull/11931">#11931</a></li>
<li>fix(query-interface): allow sequelize.fn and sequelize.literal in fields of IndexesOptions <a href="https://github.com/sequelize/sequelize/pull/12224">#12224</a></li>
<li>fix(scope): don't modify original scope definition <a href="https://github.com/sequelize/sequelize/pull/12207">#12207</a></li>
<li>fix(sqlite): multiple primary keys results in syntax error <a href="https://github.com/sequelize/sequelize/pull/12237">#12237</a></li>
<li>fix(sync): pass options to all query methods <a href="https://github.com/sequelize/sequelize/pull/12208">#12208</a></li>
<li>fix(typings): add type_helpers to file list <a href="https://github.com/sequelize/sequelize/pull/12000">#12000</a></li>
<li>fix(typings): correct Model.init return type <a href="https://github.com/sequelize/sequelize/pull/12148">#12148</a></li>
<li>fix(typings): fn is assignable to where <a href="https://github.com/sequelize/sequelize/pull/12040">#12040</a></li>
<li>fix(typings): getForeignKeysForTables argument definition <a href="https://github.com/sequelize/sequelize/pull/12084">#12084</a></li>
<li>fix(typings): make between operator accept date ranges <a href="https://github.com/sequelize/sequelize/pull/12162">#12162</a></li>
<li>refactor(ci): improve database wait script <a href="https://github.com/sequelize/sequelize/pull/12132">#12132</a></li>
<li>refactor(tsd-test-setup): add &amp; setup dtslint <a href="https://github.com/sequelize/sequelize/pull/11879">#11879</a></li>
<li>refactor: move all dialect conditional logic into subclass <a href="https://github.com/sequelize/sequelize/pull/12217">#12217</a></li>
<li>refactor: remove sequelize.import helper <a href="https://github.com/sequelize/sequelize/pull/12175">#12175</a></li>
<li>refactor: use native versions <a href="https://github.com/sequelize/sequelize/pull/12159">#12159</a></li>
<li>refactor: use object spread instead of Object.assign <a href="https://github.com/sequelize/sequelize/pull/12213">#12213</a></li>
</ul><h3>6.0.0-beta.5</h3><ul>
<li>fix(find-all): throw on empty attributes <a href="https://github.com/sequelize/sequelize/pull/11867">#11867</a></li>
<li>fix(types): <code>queryInterface.addIndex</code> <a href="https://github.com/sequelize/sequelize/pull/11844">#11844</a></li>
<li>fix(types): <code>plain</code> option in <code>sequelize.query</code> <a href="https://github.com/sequelize/sequelize/pull/11596">#11596</a></li>
<li>fix(types): correct overloaded method order <a href="https://github.com/sequelize/sequelize/pull/11727">#11727</a></li>
<li>fix(types): <code>comparator</code> arg of <code>Sequelize.where</code> <a href="https://github.com/sequelize/sequelize/pull/11843">#11843</a></li>
<li>fix(types): fix BelongsToManyGetAssociationsMixinOptions <a href="https://github.com/sequelize/sequelize/pull/11818">#11818</a></li>
<li>fix(types): adds <code>hooks</code> to <code>CreateOptions</code> <a href="https://github.com/sequelize/sequelize/pull/11736">#11736</a></li>
<li>fix(increment): broken queries <a href="https://github.com/sequelize/sequelize/pull/11852">#11852</a></li>
<li>fix(associations): gets on many-to-many with non-primary target key <a href="https://github.com/sequelize/sequelize11778/pull/">#11778</a></li>
<li>fix: properly select SRID if present <a href="https://github.com/sequelize/sequelize/pull/11763">#11763</a></li>
<li>feat(sqlite): automatic path provision for <code>options.storage</code> <a href="https://github.com/sequelize/sequelize/pull/11853">#11853</a></li>
<li>feat(postgres): <code>idle_in_transaction_session_timeout</code> connection option <a href="https://github.com/sequelize/sequelize11775/pull/">#11775</a></li>
<li>feat(index): improve to support multiple fields with operator <a href="https://github.com/sequelize/sequelize/pull/11934">#11934</a></li>
<li>docs(transactions): fix addIndex example and grammar <a href="https://github.com/sequelize/sequelize/pull/11759">#11759</a></li>
<li>docs(raw-queries): remove outdated info <a href="https://github.com/sequelize/sequelize/pull/11833">#11833</a></li>
<li>docs(optimistic-locking): fix missing manual <a href="https://github.com/sequelize/sequelize/pull/11850">#11850</a></li>
<li>docs(model): findOne return value for empty result <a href="https://github.com/sequelize/sequelize/pull/11762">#11762</a></li>
<li>docs(model-querying-basics.md): add some commas <a href="https://github.com/sequelize/sequelize/pull/11891">#11891</a></li>
<li>docs(manuals): fix missing models-definition page <a href="https://github.com/sequelize/sequelize/pull/11838">#11838</a></li>
<li>docs(manuals): extensive rewrite <a href="https://github.com/sequelize/sequelize/pull/11825">#11825</a></li>
<li>docs(dialect-specific): add MSSQL domain auth example <a href="https://github.com/sequelize/sequelize/pull/11799">#11799</a></li>
<li>docs(associations): fix typos in assocs manual <a href="https://github.com/sequelize/sequelize/pull/11888">#11888</a></li>
<li>docs(associations): fix typo <a href="https://github.com/sequelize/sequelize/pull/11869">#11869</a></li>
</ul><h3>6.0.0-beta.4</h3><ul>
<li>feat(sync): allow to bypass drop statements when sync with alter enabled <a href="https://github.com/sequelize/sequelize/pull/11708">#11708</a></li>
<li>fix(model): injectDependentVirtualAttrs on included models <a href="https://github.com/sequelize/sequelize/pull/11713">#11713</a></li>
<li>fix(model): generate ON CONFLICT ... DO UPDATE correctly <a href="https://github.com/sequelize/sequelize/pull/11666">#11666</a></li>
<li>fix(mssql): optimize formatError RegEx <a href="https://github.com/sequelize/sequelize/pull/11725">#11725</a></li>
<li>fix(types): add getForeignKeyReferencesForTable type <a href="https://github.com/sequelize/sequelize/pull/11738">#11738</a></li>
<li>fix(types): add 'restore' hooks to types <a href="https://github.com/sequelize/sequelize/pull/11730">#11730</a></li>
<li>fix(types): added 'fieldMaps' to QueryOptions typings <a href="https://github.com/sequelize/sequelize/pull/11702">#11702</a></li>
<li>fix(types): add isSoftDeleted to Model <a href="https://github.com/sequelize/sequelize/pull/11628">#11628</a></li>
<li>fix(types): fix upsert typing <a href="https://github.com/sequelize/sequelize/pull/11674">#11674</a></li>
<li>fix(types): specified 'this' for getters and setters in fields <a href="https://github.com/sequelize/sequelize/pull/11648">#11648</a></li>
<li>fix(types): add paranoid to UpdateOptions interface <a href="https://github.com/sequelize/sequelize/pull/11647">#11647</a></li>
<li>fix(types): include 'as' in IncludeThroughOptions definition <a href="https://github.com/sequelize/sequelize/pull/11624">#11624</a></li>
<li>fix(types): add Includeable to IncludeOptions.include type <a href="https://github.com/sequelize/sequelize/pull/11622">#11622</a></li>
<li>fix(types): transaction lock <a href="https://github.com/sequelize/sequelize/pull/11620">#11620</a></li>
<li>fix(sequelize.fn): escape dollarsign (#11533) <a href="https://github.com/sequelize/sequelize/pull/11606">#11606</a></li>
<li>fix(types): add nested to Includeable <a href="https://github.com/sequelize/sequelize/pull/11354">#11354</a></li>
<li>fix(types): add date to where <a href="https://github.com/sequelize/sequelize/pull/11612">#11612</a></li>
<li>fix(types): add getDatabaseName (#11431) <a href="https://github.com/sequelize/sequelize/pull/11614">#11614</a></li>
<li>fix(types): beforeDestroy <a href="https://github.com/sequelize/sequelize/pull/11618">#11618</a></li>
<li>fix(types): query-interface table schema <a href="https://github.com/sequelize/sequelize/pull/11582">#11582</a></li>
<li>docs: README.md <a href="https://github.com/sequelize/sequelize/pull/11698">#11698</a></li>
<li>docs(sequelize): detail options.retry usage <a href="https://github.com/sequelize/sequelize/pull/11643">#11643</a></li>
<li>docs: clarify logging option in Sequelize constructor <a href="https://github.com/sequelize/sequelize/pull/11653">#11653</a></li>
<li>docs(migrations): fix syntax error in example <a href="https://github.com/sequelize/sequelize/pull/11626">#11626</a></li>
<li>docs: describe logging option <a href="https://github.com/sequelize/sequelize/pull/11654">#11654</a></li>
<li>docs(transaction): fix typo <a href="https://github.com/sequelize/sequelize/pull/11659">#11659</a></li>
<li>docs(hooks): add info about belongs-to-many <a href="https://github.com/sequelize/sequelize/pull/11601">#11601</a></li>
<li>docs(associations): fix typo <a href="https://github.com/sequelize/sequelize/pull/11592">#11592</a></li>
</ul><h3>6.0.0-beta.3</h3><ul>
<li>feat: support cls-hooked / tests <a href="https://github.com/sequelize/sequelize/pull/11584">#11584</a></li>
</ul><h3>6.0.0-beta.2</h3><ul>
<li>feat(postgres): change returning option to only return model attributes <a href="https://github.com/sequelize/sequelize/pull/11526">#11526</a></li>
<li>fix(associations): allow binary key for belongs-to-many <a href="https://github.com/sequelize/sequelize/pull/11578">#11578</a></li>
<li>fix(postgres): always replace returning statement for upsertQuery</li>
<li>fix(model): make .changed() deep aware <a href="https://github.com/sequelize/sequelize/pull/10851">#10851</a></li>
<li>change: use node 10 <a href="https://github.com/sequelize/sequelize/pull/11580">#11580</a></li>
</ul></div>
        <a data-ice="link" href="manual/upgrade-to-v6.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Who's using sequelize?</h1><p><a href="http://www.walmartlabs.com/"><img src="./manual/asset/walmart-labs-logo.png" alt="Walmart labs logo"></a></p><blockquote>
<p>... we are avid users of sequelize (and have been for the past 18 months) (Feb 2017)</p>
</blockquote><p></p><hr>

<p></p><p><a href="https://snaplytics.io"><img src="./manual/asset/logo-snaplytics-green.png" alt="Snaplytics logo"></a></p><blockquote>
<p>We've been using sequelize since we started in the beginning of 2015. We use it for our graphql servers (in connection with <a href="http://github.com/mickhansen/graphql-sequelize">graphql-sequelize</a>), and for all our background workers.</p>
</blockquote><p></p><hr>

<p></p><p><a href="https://connectedcars.io/"><img src="./manual/asset/connected-cars.png" alt="Connected Cars logo"></a></p><p></p><hr>

<p></p><p><a href="https://bitovi.com"><img src="./manual/asset/bitovi-logo.png" alt="Bitovi Logo"></a></p><blockquote>
<p>We have used Sequelize in enterprise projects for some of our Fortune 100 and Fortune 500 clients.  It is used in deployments that are depended on by hundreds of millions of devices every year.</p>
</blockquote><p></p><hr>

<p></p><p><a href="https://www.ermeshotels.com"><img src="./manual/asset/ermeshotels-logo.png" alt="ErmesHotels Logo"></a></p><blockquote>
<p>Using Sequelize in production for two different apps with 30k+ daily users by 2 years. I doubt there is something better at this moment in terms of productivity and features.</p>
</blockquote></div>
        <a data-ice="link" href="manual/whos-using.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Using sequelize in AWS Lambda</h1><p><a href="https://aws.amazon.com/lambda/">AWS Lambda</a> is a serverless computing service that allows customers
to run code without having to worry about the underlying servers. Using <code>sequelize</code> in AWS Lambda
can be tricky if certain concepts are not properly understood and an appropriate configuration is
not used. This guide seeks to clarify some of these concepts so users of the library can properly
configure <code>sequelize</code> for AWS Lambda and troubleshoot issues.</p><h2>TL;DR</h2><p>If you just want to learn how to properly configure <code>sequelize</code>
<a href="./manual/./connection-pool.html">connection pooling</a> for AWS Lambda, all you need to know is that
<code>sequelize</code> connection pooling does not get along well with AWS Lambda's Node.js runtime and it ends
up causing more problems than it solves. Therefore, the most appropriate configuration is to <strong>use
pooling within the same invocation</strong> and <strong>avoid pooling across invocations</strong> (i.e. close all
connections at the end):</p><pre><code class="lang-js"><code class="source-code prettyprint">const { Sequelize } = require("sequelize");

let sequelize = null;

async function loadSequelize() {
  const sequelize = new Sequelize(/* (...) */, {
    // (...)
    pool: {
      /*
       * Lambda functions process one request at a time but your code may issue multiple queries
       * concurrently. Be wary that `sequelize` has methods that issue 2 queries concurrently
       * (e.g. `Model.findAndCountAll()`). Using a value higher than 1 allows concurrent queries to
       * be executed in parallel rather than serialized. Careful with executing too many queries in
       * parallel per Lambda function execution since that can bring down your database with an
       * excessive number of connections.
       *
       * Ideally you want to choose a `max` number where this holds true:
       * max * EXPECTED_MAX_CONCURRENT_LAMBDA_INVOCATIONS &lt; MAX_ALLOWED_DATABASE_CONNECTIONS * 0.8
       */
      max: 2,
      /*
       * Set this value to 0 so connection pool eviction logic eventually cleans up all connections
       * in the event of a Lambda function timeout.
       */
      min: 0,
      /*
       * Set this value to 0 so connections are eligible for cleanup immediately after they're
       * returned to the pool.
       */
      idle: 0,
      // Choose a small enough value that fails fast if a connection takes too long to be established.
      acquire: 3000,
      /*
       * Ensures the connection pool attempts to be cleaned up automatically on the next Lambda
       * function invocation, if the previous invocation timed out.
       */
      evict: CURRENT_LAMBDA_FUNCTION_TIMEOUT
    }
  });

  // or `sequelize.sync()`
  await sequelize.authenticate();

  return sequelize;
}

module.exports.handler = async function (event, callback) {
  // re-use the sequelize instance across invocations to improve performance
  if (!sequelize) {
    sequelize = await loadSequelize();
  } else {
    // restart connection pool to ensure connections are not re-used across invocations
    sequelize.connectionManager.initPools();

    // restore `getConnection()` if it has been overwritten by `close()`
    if (sequelize.connectionManager.hasOwnProperty("getConnection")) {
      delete sequelize.connectionManager.getConnection;
    }
  }

  try {
    return await doSomethingWithSequelize(sequelize);
  } finally {
    // close any opened connections during the invocation
    // this will wait for any in-progress queries to finish before closing the connections
    await sequelize.connectionManager.close();
  }
};</code>
</code></pre><h3>Using AWS RDS Proxy</h3><p>If your are using <a href="https://aws.amazon.com/rds/">AWS RDS</a> and you are using
<a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/rds-proxy.html">Aurora</a> or a
<a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-proxy.html">supported database engine</a>,
then connect to your database using <a href="https://aws.amazon.com/rds/proxy/">AWS RDS Proxy</a>. This will
make sure that opening/closing connections on each invocation is not an expensive operation for
your underlying database server.</p><hr><p>If you want to understand why you must use sequelize this way in AWS Lambda, continue reading the
rest of this document:</p><h2>The Node.js event loop</h2><p>The <a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/">Node.js event loop</a> is:</p><blockquote>
<p>what allows Node.js to perform non-blocking I/O operations — despite the fact that JavaScript is
single-threaded —</p>
</blockquote><p>While the event loop implementation is in C++, here's a simplified JavaScript pseudo-implementation
that illustrates how Node.js would execute a script named <code>index.js</code>:</p><pre><code class="lang-js"><code class="source-code prettyprint">// see: https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/
// see: https://www.youtube.com/watch?v=P9csgxBgaZ8
// see: https://www.youtube.com/watch?v=PNa9OMajw9w
const process = require('process');

/*
 * counter of pending events
 *
 * reference counter is increased for every:
 *
 * 1. scheduled timer: `setTimeout()`, `setInterval()`, etc.
 * 2. scheduled immediate: `setImmediate()`.
 * 3. syscall of non-blocking IO: `require('net').Server.listen()`, etc.
 * 4. scheduled task to the thread pool: `require('fs').WriteStream.write()`, etc.
 *
 * reference counter is decreased for every:
 *
 * 1. elapsed timer
 * 2. executed immediate
 * 3. completed non-blocking IO
 * 4. completed thread pool task
 *
 * references can be explicitly decreased by invoking `.unref()` on some
 * objects like: `require('net').Socket.unref()`
 */
let refs = 0;

/*
 * a heap of timers, sorted by next ocurrence
 *
 * whenever `setTimeout()` or `setInterval()` is invoked, a timer gets added here
 */
const timersHeap = /* (...) */;

/*
 * a FIFO queue of immediates
 *
 * whenever `setImmediate()` is invoked, it gets added here
 */
const immediates = /* (...) */;

/*
 * a FIFO queue of next tick callbacks
 *
 * whenever `require('process').nextTick()` is invoked, the callback gets added here
 */
const nextTickCallbacks = [];

/*
 * a heap of Promise-related callbacks, sorted by promise constructors callbacks first,
 * and then resolved/rejected callbacks
 *
 * whenever a new Promise instance is created via `new Promise` or a promise resolves/rejects
 * the appropriate callback (if any) gets added here
 */
const promiseCallbacksHeap = /* ... */;

function execTicksAndPromises() {
  while (nextTickCallbacks.length || promiseCallbacksHeap.size()) {
    // execute all callbacks scheduled with `process.nextTick()`
    while (nextTickCallbacks.length) {
      const callback = nextTickCallbacks.shift();
      callback();
    }

    // execute all promise-related callbacks
    while (promiseCallbacksHeap.size()) {
      const callback = promiseCallbacksHeap.pop();
      callback();
    }
  }
}

try {
  // execute index.js
  require('./index');
  execTicksAndPromises();

  do {
    // timers phase: executes all elapsed timers
    getElapsedTimerCallbacks(timersHeap).forEach(callback =&gt; {
      callback();
      execTicksAndPromises();
    });

    // pending callbacks phase: executes some system operations (like `TCP errors`) that are not
    //                          executed in the poll phase
    getPendingCallbacks().forEach(callback =&gt; {
      callback();
      execTicksAndPromises();
    })

    // poll phase: gets completed non-blocking I/O events or thread pool tasks and invokes the
    //             corresponding callbacks; if there are none and there's no pending immediates,
    //             it blocks waiting for events/completed tasks for a maximum of `maxWait`
    const maxWait = computeWhenNextTimerElapses(timersHeap);
    pollForEventsFromKernelOrThreadPool(maxWait, immediates).forEach(callback =&gt; {
      callback();
      execTicksAndPromises();
    });

    // check phase: execute available immediates; if an immediate callback invokes `setImmediate()`
    //              it will be invoked on the next event loop iteration
    getImmediateCallbacks(immediates).forEach(callback =&gt; {
      callback();
      execTicksAndPromises();
    });

    // close callbacks phase: execute special `.on('close')` callbacks
    getCloseCallbacks().forEach(callback =&gt; {
      callback();
      execTicksAndPromises();
    });

    if (refs === 0) {
      // listeners of this event may execute code that increments `refs`
      process.emit('beforeExit');
    }
  } while (refs &gt; 0);
} catch (err) {
  if (!process.listenerCount('uncaughtException')) {
    // default behavior: print stack and exit with status code 1
    console.error(err.stack);
    process.exit(1);
  } else {
    // there are listeners: emit the event and exit using `process.exitCode || 0`
    process.emit('uncaughtException');
    process.exit();
  }
}</code>
</code></pre><h2>AWS Lambda function handler types in Node.js</h2><p>AWS Lambda handlers come in two flavors in Node.js:</p><p><a href="https://docs.aws.amazon.com/lambda/latest/dg/nodejs-handler.html#nodejs-handler-sync">Non-async handlers</a>
(i.e. <code>callback</code>):</p><pre><code class="lang-js"><code class="source-code prettyprint">module.exports.handler = function (event, context, callback) {
  try {
    doSomething();
    callback(null, "Hello World!"); // Lambda returns "Hello World!"
  } catch (err) {
    // try/catch is not required, uncaught exceptions invoke `callback(err)` implicitly
    callback(err); // Lambda fails with `err`
  }
};</code>
</code></pre><p><a href="https://docs.aws.amazon.com/lambda/latest/dg/nodejs-handler.html#nodejs-handler-async">Async handlers</a>
(i.e. use <code>async</code>/<code>await</code> or <code>Promise</code>s):</p><pre><code class="lang-js"><code class="source-code prettyprint">// async/await
module.exports.handler = async function (event, context) {
  try {
    await doSomethingAsync();
    return "Hello World!"; // equivalent of: callback(null, "Hello World!");
  } catch (err) {
    // try/cath is not required, async functions always return a Promise
    throw err; // equivalent of: callback(err);
  }
};

// Promise
module.exports.handler = function (event, context) {
  /*
   * must return a `Promise` to be considered an async handler
   *
   * an uncaught exception that prevents a `Promise` to be returned
   * by the handler will "downgrade" the handler to non-async
   */
  return Promise.resolve()
    .then(() =&gt; doSomethingAsync())
    .then(() =&gt; "Hello World!");
};</code>
</code></pre><p>While at first glance it seems like async VS non-async handlers are simply a code styling choice,
there is a fundamental difference between the two:</p><ul>
<li>In async handlers, a Lambda function execution finishes when the <code>Promise</code> returned by the handler
resolves or rejects, regardless of whether the event loop is empty or not.</li>
<li>In non-async handlers, a Lambda function execution finishes when one of the following conditions
occur:<ul>
<li>The event loop is empty
(<a href="https://nodejs.org/dist/latest-v12.x/docs/api/process.html#process_event_beforeexit">process <code>'beforeExit'</code> event</a>
is used to detect this).</li>
<li>The <code>callback</code> argument is invoked and
<a href="https://docs.aws.amazon.com/lambda/latest/dg/nodejs-context.html"><code>context.callbackWaitsForEmptyEventLoop</code></a>
is set to <code>false</code>.</li>
</ul>
</li>
</ul><p>This fundamental difference is very important to understand in order to rationalize how <code>sequelize</code>
may be affected by it. Here are a few examples to illustrate the difference:</p><pre><code class="lang-js"><code class="source-code prettyprint">// no callback invoked
module.exports.handler = function () {
  // Lambda finishes AFTER `doSomething()` is invoked
  setTimeout(() =&gt; doSomething(), 1000);
};

// callback invoked
module.exports.handler = function (event, context, callback) {
  // Lambda finishes AFTER `doSomething()` is invoked
  setTimeout(() =&gt; doSomething(), 1000);
  callback(null, "Hello World!");
};

// callback invoked, context.callbackWaitsForEmptyEventLoop = false
module.exports.handler = function (event, context, callback) {
  // Lambda finishes BEFORE `doSomething()` is invoked
  context.callbackWaitsForEmptyEventLoop = false;
  setTimeout(() =&gt; doSomething(), 2000);
  setTimeout(() =&gt; callback(null, "Hello World!"), 1000);
};

// async/await
module.exports.handler = async function () {
  // Lambda finishes BEFORE `doSomething()` is invoked
  setTimeout(() =&gt; doSomething(), 1000);
  return "Hello World!";
};

// Promise
module.exports.handler = function () {
  // Lambda finishes BEFORE `doSomething()` is invoked
  setTimeout(() =&gt; doSomething(), 1000);
  return Promise.resolve("Hello World!");
};</code>
</code></pre><h2>AWS Lambda execution environments (i.e. containers)</h2><p>AWS Lambda function handlers are invoked by built-in or custom
<a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html">runtimes</a> which run in
execution environments (i.e. containers) that
<a href="https://aws.amazon.com/blogs/compute/container-reuse-in-lambda/">may or may not be re-used</a>
across invocations. Containers can only process
<a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-concurrency.html">one request at a time</a>.
Concurrent invocations of a Lambda function means that a container instance will be created for each
concurrent request.</p><p>In practice, this means that Lambda functions should be designed to be stateless but developers can
use state for caching purposes:</p><pre><code class="lang-js"><code class="source-code prettyprint">let sequelize = null;

module.exports.handler = async function () {
  /*
   * sequelize will already be loaded if the container is re-used
   *
   * containers are never re-used when a Lambda function's code change
   *
   * while the time elapsed between Lambda invocations is used as a factor to determine whether
   * a container is re-used, no assumptions should be made of when a container is actually re-used
   *
   * AWS does not publicly document the rules of container re-use "by design" since containers
   * can be recycled in response to internal AWS Lambda events (e.g. a Lambda function container
   * may be recycled even if the function is constanly invoked)
   */
  if (!sequelize) {
    sequelize = await loadSequelize();
  }

  return await doSomethingWithSequelize(sequelize);
};</code>
</code></pre><p>When a Lambda function doesn't wait for the event loop to be empty and a container is re-used,
the event loop will be "paused" until the next invocation occurs. For example:</p><pre><code class="lang-js"><code class="source-code prettyprint">let counter = 0;

module.exports.handler = function (event, context, callback) {
  /*
   * The first invocation (i.e. container initialized) will:
   * - log:
   *   - Fast timeout invoked. Request id: 00000000-0000-0000-0000-000000000000 | Elapsed ms: 5XX
   * - return: 1
   *
   * Wait 3 seconds and invoke the Lambda again. The invocation (i.e. container re-used) will:
   * - log:
   *   - Slow timeout invoked. Request id: 00000000-0000-0000-0000-000000000000 | Elapsed ms: 3XXX
   *   - Fast timeout invoked. Request id: 11111111-1111-1111-1111-111111111111 | Elapsed ms: 5XX
   * - return: 3
   */
  const now = Date.now();

  context.callbackWaitsForEmptyEventLoop = false;

  setTimeout(() =&gt; {
    console.log(
      "Slow timeout invoked. Request id:",
      context.awsRequestId,
      "| Elapsed ms:",
      Date.now() - now
    );
    counter++;
  }, 1000);

  setTimeout(() =&gt; {
    console.log(
      "Fast timeout invoked. Request id:",
      context.awsRequestId,
      "| Elapsed ms:",
      Date.now() - now
    );
    counter++;
    callback(null, counter);
  }, 500);
};</code>
</code></pre><h2>Sequelize connection pooling in AWS Lambda</h2><p><code>sequelize</code> uses connection pooling for optimizing usage of database connections. The connection
pool used by <code>sequelize</code> is implemented using <code>setTimeout()</code> callbacks (which are processed by the
Node.js event loop).</p><p>Given the fact that AWS Lambda containers process one request at a time, one would be tempted to
configure <code>sequelize</code> as follows:</p><pre><code class="lang-js"><code class="source-code prettyprint">const { Sequelize } = require('sequelize');

const sequelize = new Sequelize(/* (...) */, {
  // (...)
  pool: { min: 1, max: 1 }
});</code>
</code></pre><p>This configuration prevents Lambda containers from overwhelming the database server with an
excessive number of connections (since each container takes at most 1 connection). It also makes
sure that the container's connection is not garbage collected when idle so the connection does not
need to be re-established when the Lambda container is re-used. Unfortunately, this configuration
presents a set of issues:</p><ol>
<li>Lambdas that wait for the event loop to be empty will always time out. <code>sequelize</code> connection
pools schedule a <code>setTimeout</code> every
<a href="./manual/../class/src/sequelize.js~Sequelize.html#instance-constructor-constructor"><code>options.pool.evict</code></a>
ms until <strong>all idle connections have been closed</strong>. However, since <code>min</code> is set to <code>1</code>, there
will always be at least one idle connection in the pool, resulting in an infinite event loop.</li>
<li>Some operations like
<a href="./manual/../class/src/model.js~Model.html#static-method-findAndCountAll"><code>Model.findAndCountAll()</code></a>
execute multiple queries asynchronously (e.g.
<a href="./manual/..class/src/model.js~Model.html#static-method-count"><code>Model.count()</code></a> and
<a href="./manual/../class/src/model.js~Model.html#static-method-findAll"><code>Model.findAll()</code></a>). Using a maximum of
one connection forces the queries to be exectued serially (rather than in parallel using two
connections). While this may be an acceptable performance compromise in order to
maintain a manageable number of database connections, long running queries may result in
<a href="./manual/../class/src/errors/connection/connection-acquire-timeout-error.js~ConnectionAcquireTimeoutError.html"><code>ConnectionAcquireTimeoutError</code></a>
if a query takes more than the default or configured
<a href="./manual/../class/src/sequelize.js~Sequelize.html#instance-constructor-constructor"><code>options.pool.acquire</code></a>
timeout to complete. This is because the serialized query will be stuck waiting on the pool until
the connection used by the other query is released.</li>
<li>If the AWS Lambda function times out (i.e. the configured AWS Lambda timeout is exceeded), the
Node.js event loop will be "paused" regardless of its state. This can cause race conditions that
result in connection errors. For example, you may encounter situations where a very expensive
query causes a Lambda function to time out, the event loop is "paused" before the expensive query
finishes and the connection is released back to the pool, and subsequent Lambda invocations fail
with a <code>ConnectionAcquireTimeoutError</code> if the container is re-used and the connection has not
been returned after <code>options.pool.acquire</code> ms.</li>
</ol><p>You can attempt to mitigate issue <strong>#2</strong> by using <code>{ min: 1, max: 2 }</code>. However, this will still
suffer from issues <strong>#1</strong> and <strong>#3</strong> whilst introducing additional ones:</p><ol>
<li>Race conditions may occur where the even loop "pauses" before a connection pool eviction callback
executes or more than <code>options.pool.evict</code> time elapses between Lambda invocations. This can
result in timeout errors, handshake errors, and other connection-related errors.</li>
<li>If you use an operation like <code>Model.findAndCountAll()</code> and either the underlying <code>Model.count()</code>
or <code>Model.findAll()</code> queries fail, you won't be able to ensure that the other query has finished
executing (and the connection is put back into the pool) before the Lambda function execution
finishes and the event loop is "paused". This can leave connections in a stale state which can
result in prematurely closed TCP connections and other connection-related errors.</li>
</ol><p>Using <code>{ min: 2, max: 2 }</code> mitigates additional issue <strong>#1</strong>. However, the configuration still
suffers from all the other issues (original <strong>#1</strong>, <strong>#3</strong>, and additional <strong>#2</strong>).</p><h3>Detailed race condition example</h3><p>In order to make sense of the example, you'll need a bit more context of how certain parts of
Lambda and <code>sequelize</code> are implemented.</p><p>The built-in AWS Lambda runtime for <code>nodejs.12x</code> is implemented in Node.js. You can access the
entire source code of the runtime by reading the contents of <code>/var/runtime/</code> inside a Node.js Lambda
function. The relevant subset of the code is as follows:</p><p><strong>runtime/Runtime.js</strong></p><pre><code class="lang-js"><code class="source-code prettyprint">class Runtime {
  // (...)

  // each iteration is executed in the event loop `check` phase
  scheduleIteration() {
    setImmediate(() =&gt; this.handleOnce().then(/* (...) */));
  }

  async handleOnce() {
    // get next invocation. see: https://docs.aws.amazon.com/lambda/latest/dg/runtimes-api.html#runtimes-api-next
    let { bodyJson, headers } = await this.client.nextInvocation();

    // prepare `context` handler parameter
    let invokeContext = new InvokeContext(headers);
    invokeContext.updateLoggingContext();

    // prepare `callback` handler parameter
    let [callback, callbackContext] = CallbackContext.build(
      this.client,
      invokeContext.invokeId,
      this.scheduleIteration.bind(this)
    );

    try {
      // this listener is subscribed to process.on('beforeExit')
      // so that when when `context.callbackWaitsForEmptyEventLoop === true`
      // the Lambda execution finishes after the event loop is empty
      this._setDefaultExitListener(invokeContext.invokeId);

      // execute handler
      const result = this.handler(
        JSON.parse(bodyJson),
        invokeContext.attachEnvironmentData(callbackContext),
        callback
      );

      // finish the execution if the handler is async
      if (_isPromise(result)) {
        result
          .then(callbackContext.succeed, callbackContext.fail)
          .catch(callbackContext.fail);
      }
    } catch (err) {
      callback(err);
    }
  }
}</code>
</code></pre><p>The runtime schedules an iteration at the end of the initialization code:</p><p><strong>runtime/index.js</strong></p><pre><code class="lang-js"><code class="source-code prettyprint">// (...)

new Runtime(client, handler, errorCallbacks).scheduleIteration();</code>
</code></pre><p>All SQL queries invoked by a Lambda handler using <code>sequelize</code> are ultimately executed using
<a href="./manual/../class/src/sequelize.js~Sequelize.html#instance-method-query">Sequelize.prototype.query()</a>.
This method is responsible for obtaining a connection from the pool, executing the query, and
releasing the connection back to the pool when the query completes. The following snippet shows
a simplification of the method's logic for queries without transactions:</p><p><strong>sequelize.js</strong></p><pre><code class="lang-js"><code class="source-code prettyprint">class Sequelize {
  // (...)

  query(sql, options) {
    // (...)

    const connection = await this.connectionManager.getConnection(options);
    const query = new this.dialect.Query(connection, this, options);

    try {
      return await query.run(sql, bindParameters);
    } finally {
      await this.connectionManager.releaseConnection(connection);
    }
  }
}</code>
</code></pre><p>The field <code>this.connectionManager</code> is an instance of a dialect-specific <code>ConnectionManager</code> class.
All dialect-specific managers inherit from an abstract <code>ConnectionManager</code> class which initializes
the connection pool and configures it to invoke the dialect-specific class' <code>connect()</code> method
everytime a new connection needs to be created. The following snippet shows a simplification of the
<code>mysql</code> dialect <code>connect()</code> method:</p><p><strong>mysql/connection-manager.js</strong></p><pre><code class="lang-js"><code class="source-code prettyprint">class ConnectionManager {
  // (...)

  async connect(config) {
    // (...)
    return await new Promise((resolve, reject) =&gt; {
      // uses mysql2's `new Connection()`
      const connection = this.lib.createConnection(connectionConfig);

      const errorHandler = (e) =&gt; {
        connection.removeListener("connect", connectHandler);
        connection.removeListener("error", connectHandler);
        reject(e);
      };

      const connectHandler = () =&gt; {
        connection.removeListener("error", errorHandler);
        resolve(connection);
      };

      connection.on("error", errorHandler);
      connection.once("connect", connectHandler);
    });
  }
}</code>
</code></pre><p>The field <code>this.lib</code> refers to <a href="https://www.npmjs.com/package/mysql2"><code>mysql2</code></a> and the function
<code>createConnection()</code> creates a connection by creating an instance of a <code>Connection</code> class. The
relevant subset of this class is as follows:</p><p><strong>mysql2/connection.js</strong></p><pre><code class="lang-js"><code class="source-code prettyprint">class Connection extends EventEmitter {
  constructor(opts) {
    // (...)

    // create Socket
    this.stream = /* (...) */;

    // when data is received, clear timeout
    this.stream.on('data', data =&gt; {
      if (this.connectTimeout) {
        Timers.clearTimeout(this.connectTimeout);
        this.connectTimeout = null;
      }
      this.packetParser.execute(data);
    });

    // (...)

    // when handshake is completed, emit the 'connect' event
    handshakeCommand.on('end', () =&gt; {
      this.emit('connect', handshakeCommand.handshake);
    });

    // set a timeout to trigger if no data is received on the socket
    if (this.config.connectTimeout) {
      const timeoutHandler = this._handleTimeoutError.bind(this);
      this.connectTimeout = Timers.setTimeout(
        timeoutHandler,
        this.config.connectTimeout
      );
    }
  }

  // (...)

  _handleTimeoutError() {
    if (this.connectTimeout) {
      Timers.clearTimeout(this.connectTimeout);
      this.connectTimeout = null;
    }
    this.stream.destroy &amp;&amp; this.stream.destroy();
    const err = new Error('connect ETIMEDOUT');
    err.errorno = 'ETIMEDOUT';
    err.code = 'ETIMEDOUT';
    err.syscall = 'connect';

    // this will emit the 'error' event
    this._handleNetworkError(err);
  }
}</code>
</code></pre><p>Based on the previous code, the following sequence of events shows how a connection pooling
race condition with <code>{ min: 1, max: 1 }</code> can result with in a <code>ETIMEDOUT</code> error:</p><ol>
<li>A Lambda invocation is received (new container):<ol>
<li>The event loop enters the <code>check</code> phase and <code>runtime/Runtime.js</code>'s <code>handleOnce()</code> method is
invoked.<ol>
<li>The <code>handleOnce()</code> method invokes <code>await this.client.nextInvocation()</code> and waits.</li>
</ol>
</li>
<li>The event loop skips the <code>timers</code> phase since there no pending timers.</li>
<li>The event loop enters the <code>poll</code> phase and the <code>handleOnce()</code> method continues.</li>
<li>The Lambda handler is invoked.</li>
<li>The Lambda handler invokes <code>Model.count()</code> which invokes <code>sequelize.js</code>'s <code>query()</code> which
invokes <code>connectionManager.getConnection()</code>.</li>
<li>The connection pool initializes a <code>setTimeout(..., config.pool.acquire)</code> for <code>Model.count()</code>
and invokes <code>mysql/connection-manager.js</code>'s <code>connect()</code> to create a new connection.</li>
<li><code>mysql2/connection.js</code> creates the TCP socket and initializes a <code>setTimeout()</code> for failing
the connection with <code>ETIMEDOUT</code>.</li>
<li>The promise returned by the handler rejects (for reasons not detailed here) so the Lambda
function execution finishes and the Node.js event loop is "paused".</li>
</ol>
</li>
<li>Enough time elapses beween invocations so that:<ol>
<li><code>config.pool.acquire</code> timer elapses.</li>
<li><code>mysql2</code> connection timer has not elapsed yet but has almost elapsed (i.e. race condition).</li>
</ol>
</li>
<li>A second Lambda invocation is received (container re-used):<ol>
<li>The event loop is "resumed".</li>
<li>The event loop enters the <code>check</code> phase and <code>runtime/Runtime.js</code>'s <code>handleOnce()</code> method is
invoked.</li>
<li>The event loop enters the <code>timers</code> phase and the <code>config.pool.acquire</code> timer elapses, causing
the previous invocation's <code>Model.count()</code> promise to reject with
<code>ConnectionAcquireTimeoutError</code>.</li>
<li>The event loop enters the <code>poll</code> phase and the <code>handleOnce()</code> method continues.</li>
<li>The Lambda handler is invoked.</li>
<li>The Lambda handler invokes <code>Model.count()</code> which invokes <code>sequelize.js</code>'s <code>query()</code> which
invokes <code>connectionManager.getConnection()</code>.</li>
<li>The connection pool initializes a <code>setTimeout(..., config.pool.acquire)</code> for <code>Model.count()</code>
and since <code>{ max : 1 }</code> it waits for the pending <code>connect()</code> promise to complete.</li>
<li>The event loop skips the <code>check</code> phase since there are no pending immediates.</li>
<li><strong>Race condition:</strong> The event loop enters the <code>timers</code> phase and the <code>mysql2</code> connection
timeout elapses, resulting in a <code>ETIMEDOUT</code> error that is emitted using
<code>connection.emit('error')</code>.</li>
<li>The emitted event rejects the promise in <code>mysql/connection-manager.js</code>'s <code>connect()</code> which
in turn forwards the rejected promise to the <code>Model.count()</code> query's promise.</li>
<li>The lambda function fails with an <code>ETIMEDOUT</code> error.</li>
</ol>
</li>
</ol></div>
        <a data-ice="link" href="manual/aws-lambda.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Legal Notice</h1><h2>License</h2><p>Sequelize library is distributed with MIT license. You can find original license <a href="https://github.com/sequelize/sequelize/blob/main/LICENSE">here.</a></p><pre><code class="lang-text"><code class="source-code prettyprint">MIT License

Copyright (c) 2014-present Sequelize contributors

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.</code>
</code></pre><h2>AUTHOR(S)</h2><pre><code class="lang-text"><code class="source-code prettyprint">Main author:

Sascha Depold
Uhlandstr. 160
10719 Berlin
sascha [at] depold [dot] com
[plus] 49 152 [slash] 03878582
</code>
</code></pre><h2>INHALTLICHE VERANTWORTUNG</h2><pre><code class="lang-text"><code class="source-code prettyprint">Ich übernehme keine Haftung für ausgehende Links.
Daher musst du dich bei Problemen an deren Betreiber wenden!</code>
</code></pre></div>
        <a data-ice="link" href="manual/legal.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>[MOVED] Associations</h1><p>The contents of this page were moved to other specialized guides.</p><p>If you're here, you might be looking for these topics:</p><ul>
<li><strong>Core Concepts</strong><ul>
<li><a href="./manual/assocs.html">Associations</a></li>
</ul>
</li>
<li><strong>Advanced Association Concepts</strong><ul>
<li><a href="./manual/eager-loading.html">Eager Loading</a></li>
<li><a href="./manual/creating-with-associations.html">Creating with Associations</a></li>
<li><a href="./manual/advanced-many-to-many.html">Advanced M:N Associations</a></li>
<li><a href="./manual/polymorphism-and-scopes.html">Polymorphism &amp; Scopes</a></li>
</ul>
</li>
<li><strong>Other Topics</strong><ul>
<li><a href="./manual/naming-strategies.html">Naming Strategies</a></li>
<li><a href="./manual/constraints-and-circularities.html">Constraints &amp; Circularities</a></li>
</ul>
</li>
</ul></div>
        <a data-ice="link" href="manual/associations.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>[MOVED] Data Types</h1><p>The contents of this page were moved to other specialized guides.</p><p>If you're here, you might be looking for these topics:</p><ul>
<li><strong>Core Concepts</strong><ul>
<li><a href="./manual/model-basics.html#data-types">Model Basics: Data Types</a></li>
</ul>
</li>
<li><strong>Other Topics</strong><ul>
<li><a href="./manual/other-data-types.html">Other Data Types</a></li>
<li><a href="./manual/extending-data-types.html">Extending Data Types</a></li>
<li><a href="./manual/dialect-specific-things.html">Dialect-Specific Things</a></li>
</ul>
</li>
</ul></div>
        <a data-ice="link" href="manual/data-types.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>[MOVED] Models Definition</h1><p>The contents of this page were moved to <a href="./manual/model-basics.html">Model Basics</a>.</p><p>The only exception is the guide on <code>sequelize.import</code>, which is deprecated and was removed from the docs. However, if you really need it, it was kept here.</p><hr><h2>Deprecated: <code>sequelize.import</code></h2><blockquote>
<p>_<strong>Note:</strong> You should not use <code>sequelize.import</code>. Please just use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import"><code>import</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#dynamic_imports"><code>import()</code></a>, or <a href="https://nodejs.org/api/modules.html#requireid"><code>require</code></a> instead._</p>
<p><em>This documentation has been kept just in case you really need to maintain old code that uses it.</em></p>
</blockquote><p><code>sequelize.import</code> can only load <a href="https://nodejs.org/api/modules.html">CommonJS</a> files, and is not capable of loading <a href="https://nodejs.org/api/esm.html"><code>ecmascript modules</code></a>. Use native <code>import</code> if you need to load ecmascript modules.</p><p>You can store your model definitions in a single file using the <code>sequelize.import</code> method. The returned object is exactly the same as defined in the imported file's function. The import is cached, just like <code>require</code>, so you won't run into trouble if importing a file more than once.</p><pre><code class="lang-js"><code class="source-code prettyprint">// in your server file - e.g. app.js
const Project = sequelize.import(__dirname + "/path/to/models/project");

// The model definition is done in /path/to/models/project.js
module.exports = (sequelize, DataTypes) =&gt; {
  return sequelize.define('project', {
    name: DataTypes.STRING,
    description: DataTypes.TEXT
  });
};</code>
</code></pre><p>The <code>import</code> method can also accept a callback as an argument.</p><pre><code class="lang-js"><code class="source-code prettyprint">sequelize.import('project', (sequelize, DataTypes) =&gt; {
  return sequelize.define('project', {
    name: DataTypes.STRING,
    description: DataTypes.TEXT
  });
});</code>
</code></pre><p>This extra capability is useful when, for example, <code>Error: Cannot find module</code> is thrown even though <code>/path/to/models/project</code> seems to be correct. Some frameworks, such as Meteor, overload <code>require</code>, and might raise an error such as:</p><pre><code class="lang-text"><code class="source-code prettyprint">Error: Cannot find module '/home/you/meteorApp/.meteor/local/build/programs/server/app/path/to/models/project.js'</code>
</code></pre><p>This can be worked around by passing in Meteor's version of <code>require</code>:</p><pre><code class="lang-js"><code class="source-code prettyprint">// If this fails...
const AuthorModel = db.import('./path/to/models/project');

// Try this instead!
const AuthorModel = db.import('project', require('./path/to/models/project'));</code>
</code></pre></div>
        <a data-ice="link" href="manual/models-definition.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>[MOVED] Models Usage</h1><p>The contents of this page were moved to other specialized guides.</p><p>If you're here, you might be looking for these topics:</p><ul>
<li><strong>Core Concepts</strong><ul>
<li><a href="./manual/model-querying-basics.html">Model Querying - Basics</a></li>
<li><a href="./manual/model-querying-finders.html">Model Querying - Finders</a></li>
<li><a href="./manual/raw-queries.html">Raw Queries</a></li>
</ul>
</li>
<li><strong>Advanced Association Concepts</strong><ul>
<li><a href="./manual/eager-loading.html">Eager Loading</a></li>
</ul>
</li>
</ul></div>
        <a data-ice="link" href="manual/models-usage.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>[MOVED] Querying</h1><p>The contents of this page were moved to other specialized guides.</p><p>If you're here, you might be looking for these topics:</p><ul>
<li><strong>Core Concepts</strong><ul>
<li><a href="./manual/model-querying-basics.html">Model Querying - Basics</a></li>
<li><a href="./manual/model-querying-finders.html">Model Querying - Finders</a></li>
<li><a href="./manual/raw-queries.html">Raw Queries</a></li>
<li><a href="./manual/assocs.html">Associations</a></li>
</ul>
</li>
<li><strong>Other Topics</strong><ul>
<li><a href="./manual/dialect-specific-things.html">Dialect-Specific Things</a></li>
</ul>
</li>
</ul></div>
        <a data-ice="link" href="manual/querying.html"></a>
      </div>
    </div>
</div>
</div>
</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>


<script>'use strict';

(() => {
  function toggleNavigationBar() {
    const navigationElements = document.getElementsByClassName('navigation');
    for (let i = 0; i < navigationElements.length; ++i) {
      const navigationElement = navigationElements[i];
      navigationElement.classList.toggle('open');
    }
  }

  // Hamburger button - toggles the navigation bar
  const hamburger = document.getElementById('navigationHamburger');
  hamburger.addEventListener('click', () => {
    toggleNavigationBar();
  });

  // Each link in the navigation bar - closes the navigation bar
  const navigationLinks = document.querySelectorAll('.navigation a');
  for (let i = 0; i < navigationLinks.length; ++i) {
    const linkElement = navigationLinks[i];
    linkElement.addEventListener('click', () => {
      toggleNavigationBar();
    });
  }
})();
</script></body></html>