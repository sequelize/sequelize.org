<!DOCTYPE html><html><head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../">
  <title data-ice="title">lib/dialects/mssql/query-generator.js | Sequelize</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<link rel="stylesheet" href="./inject/css/0-style.css"><link rel="stylesheet" href="./inject/css/0-theme.css"><meta name="description" content="An easy-to-use multi SQL dialect ORM for Node.js"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="Sequelize"><meta property="twitter:description" content="An easy-to-use multi SQL dialect ORM for Node.js"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./" style="display: flex; align-items: center;"><img src="./image/brand_logo.png" style="width:34px;"></a>
  
  <a href="identifiers.html" class="api-reference-link">API Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style href="https://github.com/sequelize/sequelize"><img width="30px" src="./image/github.png" style="width: 30px;"></a>
      <a href="http://sequelize-slack.herokuapp.com/">
        <img src="manual/asset/slack.svg" style="width: 60px; margin-left: -15px;">
      </a>
    </header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  


































<li data-ice="doc" style="margin-top: 15px;"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/model.js~Model.html">Model</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/query-interface.js~QueryInterface.html">QueryInterface</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/sequelize.js~Sequelize.html">Sequelize</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/transaction.js~Transaction.html">Transaction</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-DataTypes">DataTypes</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Deferrable">Deferrable</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-IndexHints">IndexHints</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Op">Op</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-QueryTypes">QueryTypes</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-TableHints">TableHints</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#associations">associations</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/associations/base.js~Association.html">Association</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/associations/belongs-to-many.js~BelongsToMany.html">BelongsToMany</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/associations/belongs-to.js~BelongsTo.html">BelongsTo</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/associations/has-many.js~HasMany.html">HasMany</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/associations/has-one.js~HasOne.html">HasOne</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#dialects-sqlite">dialects/sqlite</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-describeTable">describeTable</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#errors">errors</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/errors/association-error.js~AssociationError.html">AssociationError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/errors/base-error.js~BaseError.html">BaseError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/errors/bulk-record-error.js~BulkRecordError.html">BulkRecordError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/errors/connection-error.js~ConnectionError.html">ConnectionError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/errors/database-error.js~DatabaseError.html">DatabaseError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/errors/eager-loading-error.js~EagerLoadingError.html">EagerLoadingError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/errors/empty-result-error.js~EmptyResultError.html">EmptyResultError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/errors/instance-error.js~InstanceError.html">InstanceError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/errors/optimistic-lock-error.js~OptimisticLockError.html">OptimisticLockError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/errors/query-error.js~QueryError.html">QueryError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/errors/sequelize-scope-error.js~SequelizeScopeError.html">SequelizeScopeError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/errors/validation-error.js~ValidationError.html">ValidationError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/errors/validation-error.js~ValidationErrorItem.html">ValidationErrorItem</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#errors-connection">errors/connection</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/errors/connection/access-denied-error.js~AccessDeniedError.html">AccessDeniedError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/errors/connection/connection-acquire-timeout-error.js~ConnectionAcquireTimeoutError.html">ConnectionAcquireTimeoutError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/errors/connection/connection-refused-error.js~ConnectionRefusedError.html">ConnectionRefusedError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/errors/connection/connection-timed-out-error.js~ConnectionTimedOutError.html">ConnectionTimedOutError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/errors/connection/host-not-found-error.js~HostNotFoundError.html">HostNotFoundError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/errors/connection/host-not-reachable-error.js~HostNotReachableError.html">HostNotReachableError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/errors/connection/invalid-connection-error.js~InvalidConnectionError.html">InvalidConnectionError</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#errors-database">errors/database</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/errors/database/exclusion-constraint-error.js~ExclusionConstraintError.html">ExclusionConstraintError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/errors/database/foreign-key-constraint-error.js~ForeignKeyConstraintError.html">ForeignKeyConstraintError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/errors/database/timeout-error.js~TimeoutError.html">TimeoutError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/errors/database/unknown-constraint-error.js~UnknownConstraintError.html">UnknownConstraintError</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#errors-validation">errors/validation</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/errors/validation/unique-constraint-error.js~UniqueConstraintError.html">UniqueConstraintError</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="variable/index.html#static-variable-DataTypes">datatypes</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~ARRAY.html">ARRAY</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~VIRTUAL.html">VIRTUAL</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~UUIDV4.html">UUIDV4</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~UUIDV1.html">UUIDV1</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~UUID.html">UUID</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~TINYINT.html">TINYINT</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~TIME.html">TIME</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~TEXT.html">TEXT</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~STRING.html">STRING</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~SMALLINT.html">SMALLINT</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~REAL.html">REAL</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~RANGE.html">RANGE</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~NUMBER.html">NUMBER</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~NOW.html">NOW</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~MEDIUMINT.html">MEDIUMINT</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~MACADDR.html">MACADDR</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~JSONTYPE.html">JSONTYPE</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~JSONB.html">JSONB</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~INTEGER.html">INTEGER</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~INET.html">INET</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~HSTORE.html">HSTORE</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~GEOMETRY.html">GEOMETRY</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~GEOGRAPHY.html">GEOGRAPHY</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~FLOAT.html">FLOAT</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~ENUM.html">ENUM</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~DOUBLE.html">DOUBLE</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~DECIMAL.html">DECIMAL</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~DATEONLY.html">DATEONLY</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~DATE.html">DATE</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~CITEXT.html">CITEXT</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~CIDR.html">CIDR</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~CHAR.html">CHAR</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~BOOLEAN.html">BOOLEAN</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~BLOB.html">BLOB</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~BIGINT.html">BIGINT</a></span></span></li></ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">lib/dialects/mssql/query-generator.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&apos;use strict&apos;;

const _ = require(&apos;lodash&apos;);
const Utils = require(&apos;../../utils&apos;);
const DataTypes = require(&apos;../../data-types&apos;);
const TableHints = require(&apos;../../table-hints&apos;);
const AbstractQueryGenerator = require(&apos;../abstract/query-generator&apos;);
const randomBytes = require(&apos;crypto&apos;).randomBytes;
const semver = require(&apos;semver&apos;);
const Op = require(&apos;../../operators&apos;);

/* istanbul ignore next */
const throwMethodUndefined = function(methodName) {
  throw new Error(`The method &quot;${methodName}&quot; is not defined! Please add it to your sql dialect.`);
};

class MSSQLQueryGenerator extends AbstractQueryGenerator {
  createDatabaseQuery(databaseName, options) {
    options = Object.assign({
      collate: null
    }, options || {});

    const collation = options.collate ? `COLLATE ${this.escape(options.collate)}` : &apos;&apos;;

    return [
      &apos;IF NOT EXISTS (SELECT * FROM sys.databases WHERE name =&apos;, wrapSingleQuote(databaseName), &apos;)&apos;,
      &apos;BEGIN&apos;,
      &apos;CREATE DATABASE&apos;, this.quoteIdentifier(databaseName),
      `${collation};`,
      &apos;END;&apos;
    ].join(&apos; &apos;);
  }

  dropDatabaseQuery(databaseName) {
    return [
      &apos;IF EXISTS (SELECT * FROM sys.databases WHERE name =&apos;, wrapSingleQuote(databaseName), &apos;)&apos;,
      &apos;BEGIN&apos;,
      &apos;DROP DATABASE&apos;, this.quoteIdentifier(databaseName), &apos;;&apos;,
      &apos;END;&apos;
    ].join(&apos; &apos;);
  }

  createSchema(schema) {
    return [
      &apos;IF NOT EXISTS (SELECT schema_name&apos;,
      &apos;FROM information_schema.schemata&apos;,
      &apos;WHERE schema_name =&apos;, wrapSingleQuote(schema), &apos;)&apos;,
      &apos;BEGIN&apos;,
      &quot;EXEC sp_executesql N&apos;CREATE SCHEMA&quot;,
      this.quoteIdentifier(schema),
      &quot;;&apos;&quot;,
      &apos;END;&apos;
    ].join(&apos; &apos;);
  }

  dropSchema(schema) {
    // Mimics Postgres CASCADE, will drop objects belonging to the schema
    const quotedSchema = wrapSingleQuote(schema);
    return [
      &apos;IF EXISTS (SELECT schema_name&apos;,
      &apos;FROM information_schema.schemata&apos;,
      &apos;WHERE schema_name =&apos;, quotedSchema, &apos;)&apos;,
      &apos;BEGIN&apos;,
      &apos;DECLARE @id INT, @ms_sql NVARCHAR(2000);&apos;,
      &apos;DECLARE @cascade TABLE (&apos;,
      &apos;id INT NOT NULL IDENTITY PRIMARY KEY,&apos;,
      &apos;ms_sql NVARCHAR(2000) NOT NULL );&apos;,
      &apos;INSERT INTO @cascade ( ms_sql )&apos;,
      &quot;SELECT CASE WHEN o.type IN (&apos;F&apos;,&apos;PK&apos;)&quot;,
      &quot;THEN N&apos;ALTER TABLE [&apos;+ s.name + N&apos;].[&apos; + p.name + N&apos;] DROP CONSTRAINT [&apos; + o.name + N&apos;]&apos;&quot;,
      &quot;ELSE N&apos;DROP TABLE [&apos;+ s.name + N&apos;].[&apos; + o.name + N&apos;]&apos; END&quot;,
      &apos;FROM sys.objects o&apos;,
      &apos;JOIN sys.schemas s on o.schema_id = s.schema_id&apos;,
      &apos;LEFT OUTER JOIN sys.objects p on o.parent_object_id = p.object_id&apos;,
      &quot;WHERE o.type IN (&apos;F&apos;, &apos;PK&apos;, &apos;U&apos;) AND s.name = &quot;, quotedSchema,
      &apos;ORDER BY o.type ASC;&apos;,
      &apos;SELECT TOP 1 @id = id, @ms_sql = ms_sql FROM @cascade ORDER BY id;&apos;,
      &apos;WHILE @id IS NOT NULL&apos;,
      &apos;BEGIN&apos;,
      &apos;BEGIN TRY EXEC sp_executesql @ms_sql; END TRY&apos;,
      &apos;BEGIN CATCH BREAK; THROW; END CATCH;&apos;,
      &apos;DELETE FROM @cascade WHERE id = @id;&apos;,
      &apos;SELECT @id = NULL, @ms_sql = NULL;&apos;,
      &apos;SELECT TOP 1 @id = id, @ms_sql = ms_sql FROM @cascade ORDER BY id;&apos;,
      &apos;END&apos;,
      &quot;EXEC sp_executesql N&apos;DROP SCHEMA&quot;, this.quoteIdentifier(schema), &quot;;&apos;&quot;,
      &apos;END;&apos;
    ].join(&apos; &apos;);
  }

  showSchemasQuery() {
    return [
      &apos;SELECT &quot;name&quot; as &quot;schema_name&quot; FROM sys.schemas as s&apos;,
      &apos;WHERE &quot;s&quot;.&quot;name&quot; NOT IN (&apos;,
      &quot;&apos;INFORMATION_SCHEMA&apos;, &apos;dbo&apos;, &apos;guest&apos;, &apos;sys&apos;, &apos;archive&apos;&quot;,
      &apos;)&apos;, &apos;AND&apos;, &apos;&quot;s&quot;.&quot;name&quot; NOT LIKE&apos;, &quot;&apos;db_%&apos;&quot;
    ].join(&apos; &apos;);
  }

  versionQuery() {
    // Uses string manipulation to convert the MS Maj.Min.Patch.Build to semver Maj.Min.Patch
    return [
      &apos;DECLARE @ms_ver NVARCHAR(20);&apos;,
      &quot;SET @ms_ver = REVERSE(CONVERT(NVARCHAR(20), SERVERPROPERTY(&apos;ProductVersion&apos;)));&quot;,
      &quot;SELECT REVERSE(SUBSTRING(@ms_ver, CHARINDEX(&apos;.&apos;, @ms_ver)+1, 20)) AS &apos;version&apos;&quot;
    ].join(&apos; &apos;);
  }

  createTableQuery(tableName, attributes, options) {
    const query = (table, attrs) =&gt; `IF OBJECT_ID(&apos;${table}&apos;, &apos;U&apos;) IS NULL CREATE TABLE ${table} (${attrs})`,
      primaryKeys = [],
      foreignKeys = {},
      attrStr = [];

    let commentStr = &apos;&apos;;

    for (const attr in attributes) {
      if (Object.prototype.hasOwnProperty.call(attributes, attr)) {
        let dataType = attributes[attr];
        let match;

        if (dataType.includes(&apos;COMMENT &apos;)) {
          const commentMatch = dataType.match(/^(.+) (COMMENT.*)$/);
          const commentText = commentMatch[2].replace(&apos;COMMENT&apos;, &apos;&apos;).trim();
          commentStr += this.commentTemplate(commentText, tableName, attr);
          // remove comment related substring from dataType
          dataType = commentMatch[1];
        }

        if (dataType.includes(&apos;PRIMARY KEY&apos;)) {
          primaryKeys.push(attr);

          if (dataType.includes(&apos;REFERENCES&apos;)) {
            // MSSQL doesn&apos;t support inline REFERENCES declarations: move to the end
            match = dataType.match(/^(.+) (REFERENCES.*)$/);
            attrStr.push(`${this.quoteIdentifier(attr)} ${match[1].replace(&apos;PRIMARY KEY&apos;, &apos;&apos;)}`);
            foreignKeys[attr] = match[2];
          } else {
            attrStr.push(`${this.quoteIdentifier(attr)} ${dataType.replace(&apos;PRIMARY KEY&apos;, &apos;&apos;)}`);
          }
        } else if (dataType.includes(&apos;REFERENCES&apos;)) {
          // MSSQL doesn&apos;t support inline REFERENCES declarations: move to the end
          match = dataType.match(/^(.+) (REFERENCES.*)$/);
          attrStr.push(`${this.quoteIdentifier(attr)} ${match[1]}`);
          foreignKeys[attr] = match[2];
        } else {
          attrStr.push(`${this.quoteIdentifier(attr)} ${dataType}`);
        }
      }
    }


    let attributesClause = attrStr.join(&apos;, &apos;);
    const pkString = primaryKeys.map(pk =&gt; this.quoteIdentifier(pk)).join(&apos;, &apos;);

    if (options.uniqueKeys) {
      _.each(options.uniqueKeys, (columns, indexName) =&gt; {
        if (columns.customIndex) {
          if (typeof indexName !== &apos;string&apos;) {
            indexName = `uniq_${tableName}_${columns.fields.join(&apos;_&apos;)}`;
          }
          attributesClause += `, CONSTRAINT ${this.quoteIdentifier(indexName)} UNIQUE (${columns.fields.map(field =&gt; this.quoteIdentifier(field)).join(&apos;, &apos;)})`;
        }
      });
    }

    if (pkString.length &gt; 0) {
      attributesClause += `, PRIMARY KEY (${pkString})`;
    }

    for (const fkey in foreignKeys) {
      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {
        attributesClause += `, FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;
      }
    }

    return `${query(this.quoteTable(tableName), attributesClause)};${commentStr}`;
  }

  describeTableQuery(tableName, schema) {
    let sql = [
      &apos;SELECT&apos;,
      &quot;c.COLUMN_NAME AS &apos;Name&apos;,&quot;,
      &quot;c.DATA_TYPE AS &apos;Type&apos;,&quot;,
      &quot;c.CHARACTER_MAXIMUM_LENGTH AS &apos;Length&apos;,&quot;,
      &quot;c.IS_NULLABLE as &apos;IsNull&apos;,&quot;,
      &quot;COLUMN_DEFAULT AS &apos;Default&apos;,&quot;,
      &quot;pk.CONSTRAINT_TYPE AS &apos;Constraint&apos;,&quot;,
      &quot;COLUMNPROPERTY(OBJECT_ID(c.TABLE_SCHEMA+&apos;.&apos;+c.TABLE_NAME), c.COLUMN_NAME, &apos;IsIdentity&apos;) as &apos;IsIdentity&apos;,&quot;,
      &quot;prop.value AS &apos;Comment&apos;&quot;,
      &apos;FROM&apos;,
      &apos;INFORMATION_SCHEMA.TABLES t&apos;,
      &apos;INNER JOIN&apos;,
      &apos;INFORMATION_SCHEMA.COLUMNS c ON t.TABLE_NAME = c.TABLE_NAME AND t.TABLE_SCHEMA = c.TABLE_SCHEMA&apos;,
      &apos;LEFT JOIN (SELECT tc.table_schema, tc.table_name, &apos;,
      &apos;cu.column_name, tc.CONSTRAINT_TYPE &apos;,
      &apos;FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc &apos;,
      &apos;JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE  cu &apos;,
      &apos;ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name &apos;,
      &apos;and tc.constraint_name=cu.constraint_name &apos;,
      &apos;and tc.CONSTRAINT_TYPE=\&apos;PRIMARY KEY\&apos;) pk &apos;,
      &apos;ON pk.table_schema=c.table_schema &apos;,
      &apos;AND pk.table_name=c.table_name &apos;,
      &apos;AND pk.column_name=c.column_name &apos;,
      &apos;INNER JOIN sys.columns AS sc&apos;,
      &quot;ON sc.object_id = object_id(t.table_schema + &apos;.&apos; + t.table_name) AND sc.name = c.column_name&quot;,
      &apos;LEFT JOIN sys.extended_properties prop ON prop.major_id = sc.object_id&apos;,
      &apos;AND prop.minor_id = sc.column_id&apos;,
      &quot;AND prop.name = &apos;MS_Description&apos;&quot;,
      &apos;WHERE t.TABLE_NAME =&apos;, wrapSingleQuote(tableName)
    ].join(&apos; &apos;);

    if (schema) {
      sql += `AND t.TABLE_SCHEMA =${wrapSingleQuote(schema)}`;
    }

    return sql;
  }

  renameTableQuery(before, after) {
    return `EXEC sp_rename ${this.quoteTable(before)}, ${this.quoteTable(after)};`;
  }

  showTablesQuery() {
    return &quot;SELECT TABLE_NAME, TABLE_SCHEMA FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = &apos;BASE TABLE&apos;;&quot;;
  }

  dropTableQuery(tableName) {
    const qouteTbl = this.quoteTable(tableName);
    return `IF OBJECT_ID(&apos;${qouteTbl}&apos;, &apos;U&apos;) IS NOT NULL DROP TABLE ${qouteTbl};`;
  }

  addColumnQuery(table, key, dataType) {
    // FIXME: attributeToSQL SHOULD be using attributes in addColumnQuery
    //        but instead we need to pass the key along as the field here
    dataType.field = key;
    let commentStr = &apos;&apos;;

    if (dataType.comment &amp;&amp; _.isString(dataType.comment)) {
      commentStr = this.commentTemplate(dataType.comment, table, key);
      // attributeToSQL will try to include `COMMENT &apos;Comment Text&apos;` when it returns if the comment key
      // is present. This is needed for createTable statement where that part is extracted with regex.
      // Here we can intercept the object and remove comment property since we have the original object.
      delete dataType[&apos;comment&apos;];
    }

    const def = this.attributeToSQL(dataType, {
      context: &apos;addColumn&apos;
    });
    return `ALTER TABLE ${this.quoteTable(table)} ADD ${this.quoteIdentifier(key)} ${def};${commentStr}`;
  }

  commentTemplate(comment, table, column) {
    return &apos; EXEC sp_addextendedproperty &apos; +
        `@name = N&apos;MS_Description&apos;, @value = ${this.escape(comment)}, ` +
        &apos;@level0type = N\&apos;Schema\&apos;, @level0name = \&apos;dbo\&apos;, &apos; +
        `@level1type = N&apos;Table&apos;, @level1name = ${this.quoteIdentifier(table)}, ` +
        `@level2type = N&apos;Column&apos;, @level2name = ${this.quoteIdentifier(column)};`;
  }

  removeColumnQuery(tableName, attributeName) {
    return `ALTER TABLE ${this.quoteTable(tableName)} DROP COLUMN ${this.quoteIdentifier(attributeName)};`;
  }

  changeColumnQuery(tableName, attributes) {
    const attrString = [],
      constraintString = [];
    let commentString = &apos;&apos;;

    for (const attributeName in attributes) {
      const quotedAttrName = this.quoteIdentifier(attributeName);
      let definition = attributes[attributeName];
      if (definition.includes(&apos;COMMENT &apos;)) {
        const commentMatch = definition.match(/^(.+) (COMMENT.*)$/);
        const commentText = commentMatch[2].replace(&apos;COMMENT&apos;, &apos;&apos;).trim();
        commentString += this.commentTemplate(commentText, tableName, attributeName);
        // remove comment related substring from dataType
        definition = commentMatch[1];
      }
      if (definition.includes(&apos;REFERENCES&apos;)) {
        constraintString.push(`FOREIGN KEY (${quotedAttrName}) ${definition.replace(/.+?(?=REFERENCES)/, &apos;&apos;)}`);
      } else {
        attrString.push(`${quotedAttrName} ${definition}`);
      }
    }

    let finalQuery = &apos;&apos;;
    if (attrString.length) {
      finalQuery += `ALTER COLUMN ${attrString.join(&apos;, &apos;)}`;
      finalQuery += constraintString.length ? &apos; &apos; : &apos;&apos;;
    }
    if (constraintString.length) {
      finalQuery += `ADD ${constraintString.join(&apos;, &apos;)}`;
    }

    return `ALTER TABLE ${this.quoteTable(tableName)} ${finalQuery};${commentString}`;
  }

  renameColumnQuery(tableName, attrBefore, attributes) {
    const newName = Object.keys(attributes)[0];
    return `EXEC sp_rename &apos;${this.quoteTable(tableName)}.${attrBefore}&apos;, &apos;${newName}&apos;, &apos;COLUMN&apos;;`;
  }

  bulkInsertQuery(tableName, attrValueHashes, options, attributes) {
    const quotedTable = this.quoteTable(tableName);
    options = options || {};
    attributes = attributes || {};

    const tuples = [];
    const allAttributes = [];
    const allQueries = [];



    let needIdentityInsertWrapper = false,
      outputFragment = &apos;&apos;;

    if (options.returning) {
      outputFragment = &apos; OUTPUT INSERTED.*&apos;;
    }

    const emptyQuery = `INSERT INTO ${quotedTable}${outputFragment} DEFAULT VALUES`;

    attrValueHashes.forEach(attrValueHash =&gt; {
      // special case for empty objects with primary keys
      const fields = Object.keys(attrValueHash);
      const firstAttr = attributes[fields[0]];
      if (fields.length === 1 &amp;&amp; firstAttr &amp;&amp; firstAttr.autoIncrement &amp;&amp; attrValueHash[fields[0]] === null) {
        allQueries.push(emptyQuery);
        return;
      }

      // normal case
      _.forOwn(attrValueHash, (value, key) =&gt; {
        if (value !== null &amp;&amp; attributes[key] &amp;&amp; attributes[key].autoIncrement) {
          needIdentityInsertWrapper = true;
        }

        if (!allAttributes.includes(key)) {
          if (value === null &amp;&amp; attributes[key] &amp;&amp; attributes[key].autoIncrement)
            return;

          allAttributes.push(key);
        }
      });
    });

    if (allAttributes.length &gt; 0) {
      attrValueHashes.forEach(attrValueHash =&gt; {
        tuples.push(`(${
          allAttributes.map(key =&gt;
            this.escape(attrValueHash[key])).join(&apos;,&apos;)
        })`);
      });

      const quotedAttributes = allAttributes.map(attr =&gt; this.quoteIdentifier(attr)).join(&apos;,&apos;);
      allQueries.push(tupleStr =&gt; `INSERT INTO ${quotedTable} (${quotedAttributes})${outputFragment} VALUES ${tupleStr};`);
    }
    const commands = [];
    let offset = 0;
    const batch = Math.floor(250 / (allAttributes.length + 1)) + 1;
    while (offset &lt; Math.max(tuples.length, 1)) {
      const tupleStr = tuples.slice(offset, Math.min(tuples.length, offset + batch));
      let generatedQuery = allQueries.map(v =&gt; typeof v === &apos;string&apos; ? v : v(tupleStr)).join(&apos;;&apos;);
      if (needIdentityInsertWrapper) {
        generatedQuery = `SET IDENTITY_INSERT ${quotedTable} ON; ${generatedQuery}; SET IDENTITY_INSERT ${quotedTable} OFF;`;
      }
      commands.push(generatedQuery);
      offset += batch;
    }
    return commands.join(&apos;;&apos;);
  }

  updateQuery(tableName, attrValueHash, where, options, attributes) {
    const sql = super.updateQuery(tableName, attrValueHash, where, options, attributes);
    if (options.limit) {
      const updateArgs = `UPDATE TOP(${this.escape(options.limit)})`;
      sql.query = sql.query.replace(&apos;UPDATE&apos;, updateArgs);
    }
    return sql;
  }

  upsertQuery(tableName, insertValues, updateValues, where, model) {
    const targetTableAlias = this.quoteTable(`${tableName}_target`);
    const sourceTableAlias = this.quoteTable(`${tableName}_source`);
    const primaryKeysAttrs = [];
    const identityAttrs = [];
    const uniqueAttrs = [];
    const tableNameQuoted = this.quoteTable(tableName);
    let needIdentityInsertWrapper = false;

    //Obtain primaryKeys, uniquekeys and identity attrs from rawAttributes as model is not passed
    for (const key in model.rawAttributes) {
      if (model.rawAttributes[key].primaryKey) {
        primaryKeysAttrs.push(model.rawAttributes[key].field || key);
      }
      if (model.rawAttributes[key].unique) {
        uniqueAttrs.push(model.rawAttributes[key].field || key);
      }
      if (model.rawAttributes[key].autoIncrement) {
        identityAttrs.push(model.rawAttributes[key].field || key);
      }
    }

    //Add unique indexes defined by indexes option to uniqueAttrs
    for (const index of model._indexes) {
      if (index.unique &amp;&amp; index.fields) {
        for (const field of index.fields) {
          const fieldName = typeof field === &apos;string&apos; ? field : field.name || field.attribute;
          if (!uniqueAttrs.includes(fieldName) &amp;&amp; model.rawAttributes[fieldName]) {
            uniqueAttrs.push(fieldName);
          }
        }
      }
    }

    const updateKeys = Object.keys(updateValues);
    const insertKeys = Object.keys(insertValues);
    const insertKeysQuoted = insertKeys.map(key =&gt; this.quoteIdentifier(key)).join(&apos;, &apos;);
    const insertValuesEscaped = insertKeys.map(key =&gt; this.escape(insertValues[key])).join(&apos;, &apos;);
    const sourceTableQuery = `VALUES(${insertValuesEscaped})`; //Virtual Table
    let joinCondition;

    //IDENTITY_INSERT Condition
    identityAttrs.forEach(key =&gt; {
      if (updateValues[key] &amp;&amp; updateValues[key] !== null) {
        needIdentityInsertWrapper = true;
        /*
         * IDENTITY_INSERT Column Cannot be updated, only inserted
         * http://stackoverflow.com/a/30176254/2254360
         */
      }
    });

    //Filter NULL Clauses
    const clauses = where[Op.or].filter(clause =&gt; {
      let valid = true;
      /*
       * Exclude NULL Composite PK/UK. Partial Composite clauses should also be excluded as it doesn&apos;t guarantee a single row
       */
      for (const key in clause) {
        if (!clause[key]) {
          valid = false;
          break;
        }
      }
      return valid;
    });

    /*
     * Generate ON condition using PK(s).
     * If not, generate using UK(s). Else throw error
     */
    const getJoinSnippet = array =&gt; {
      return array.map(key =&gt; {
        key = this.quoteIdentifier(key);
        return `${targetTableAlias}.${key} = ${sourceTableAlias}.${key}`;
      });
    };

    if (clauses.length === 0) {
      throw new Error(&apos;Primary Key or Unique key should be passed to upsert query&apos;);
    } else {
      // Search for primary key attribute in clauses -- Model can have two separate unique keys
      for (const key in clauses) {
        const keys = Object.keys(clauses[key]);
        if (primaryKeysAttrs.includes(keys[0])) {
          joinCondition = getJoinSnippet(primaryKeysAttrs).join(&apos; AND &apos;);
          break;
        }
      }
      if (!joinCondition) {
        joinCondition = getJoinSnippet(uniqueAttrs).join(&apos; AND &apos;);
      }
    }

    // Remove the IDENTITY_INSERT Column from update
    const updateSnippet = updateKeys.filter(key =&gt; !identityAttrs.includes(key))
      .map(key =&gt; {
        const value = this.escape(updateValues[key]);
        key = this.quoteIdentifier(key);
        return `${targetTableAlias}.${key} = ${value}`;
      }).join(&apos;, &apos;);

    const insertSnippet = `(${insertKeysQuoted}) VALUES(${insertValuesEscaped})`;
    let query = `MERGE INTO ${tableNameQuoted} WITH(HOLDLOCK) AS ${targetTableAlias} USING (${sourceTableQuery}) AS ${sourceTableAlias}(${insertKeysQuoted}) ON ${joinCondition}`;
    query += ` WHEN MATCHED THEN UPDATE SET ${updateSnippet} WHEN NOT MATCHED THEN INSERT ${insertSnippet} OUTPUT $action, INSERTED.*;`;
    if (needIdentityInsertWrapper) {
      query = `SET IDENTITY_INSERT ${tableNameQuoted} ON; ${query} SET IDENTITY_INSERT ${tableNameQuoted} OFF;`;
    }
    return query;
  }

  truncateTableQuery(tableName) {
    return `TRUNCATE TABLE ${this.quoteTable(tableName)}`;
  }

  deleteQuery(tableName, where, options = {}, model) {
    const table = this.quoteTable(tableName);

    let whereClause = this.getWhereConditions(where, null, model, options);
    let limit = &apos;&apos;;

    if (options.limit) {
      limit = ` TOP(${this.escape(options.limit)})`;
    }

    if (whereClause) {
      whereClause = ` WHERE ${whereClause}`;
    }

    return `DELETE${limit} FROM ${table}${whereClause}; SELECT @@ROWCOUNT AS AFFECTEDROWS;`;
  }

  showIndexesQuery(tableName) {
    return `EXEC sys.sp_helpindex @objname = N&apos;${this.quoteTable(tableName)}&apos;;`;
  }

  showConstraintsQuery(tableName) {
    return `EXEC sp_helpconstraint @objname = ${this.escape(this.quoteTable(tableName))};`;
  }

  removeIndexQuery(tableName, indexNameOrAttributes) {
    let indexName = indexNameOrAttributes;

    if (typeof indexName !== &apos;string&apos;) {
      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join(&apos;_&apos;)}`);
    }

    return `DROP INDEX ${this.quoteIdentifiers(indexName)} ON ${this.quoteIdentifiers(tableName)}`;
  }

  attributeToSQL(attribute) {
    if (!_.isPlainObject(attribute)) {
      attribute = {
        type: attribute
      };
    }

    // handle self referential constraints
    if (attribute.references) {

      if (attribute.Model &amp;&amp; attribute.Model.tableName === attribute.references.model) {
        this.sequelize.log(&apos;MSSQL does not support self referencial constraints, &apos;
          + &apos;we will remove it but we recommend restructuring your query&apos;);
        attribute.onDelete = &apos;&apos;;
        attribute.onUpdate = &apos;&apos;;
      }
    }

    let template;

    if (attribute.type instanceof DataTypes.ENUM) {
      if (attribute.type.values &amp;&amp; !attribute.values) attribute.values = attribute.type.values;

      // enums are a special case
      template = attribute.type.toSql();
      template += ` CHECK (${this.quoteIdentifier(attribute.field)} IN(${attribute.values.map(value =&gt; {
        return this.escape(value);
      }).join(&apos;, &apos;) }))`;
      return template;
    }
    template = attribute.type.toString();

    if (attribute.allowNull === false) {
      template += &apos; NOT NULL&apos;;
    } else if (!attribute.primaryKey &amp;&amp; !Utils.defaultValueSchemable(attribute.defaultValue)) {
      template += &apos; NULL&apos;;
    }

    if (attribute.autoIncrement) {
      template += &apos; IDENTITY(1,1)&apos;;
    }

    // Blobs/texts cannot have a defaultValue
    if (attribute.type !== &apos;TEXT&apos; &amp;&amp; attribute.type._binary !== true &amp;&amp;
        Utils.defaultValueSchemable(attribute.defaultValue)) {
      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;
    }

    if (attribute.unique === true) {
      template += &apos; UNIQUE&apos;;
    }

    if (attribute.primaryKey) {
      template += &apos; PRIMARY KEY&apos;;
    }

    if (attribute.references) {
      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;

      if (attribute.references.key) {
        template += ` (${this.quoteIdentifier(attribute.references.key)})`;
      } else {
        template += ` (${this.quoteIdentifier(&apos;id&apos;)})`;
      }

      if (attribute.onDelete) {
        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;
      }

      if (attribute.onUpdate) {
        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;
      }
    }

    if (attribute.comment &amp;&amp; typeof attribute.comment === &apos;string&apos;) {
      template += ` COMMENT ${attribute.comment}`;
    }

    return template;
  }

  attributesToSQL(attributes, options) {
    const result = {},
      existingConstraints = [];
    let key,
      attribute;

    for (key in attributes) {
      attribute = attributes[key];

      if (attribute.references) {

        if (existingConstraints.includes(attribute.references.model.toString())) {
          // no cascading constraints to a table more than once
          attribute.onDelete = &apos;&apos;;
          attribute.onUpdate = &apos;&apos;;
        } else {
          existingConstraints.push(attribute.references.model.toString());

          // NOTE: this really just disables cascading updates for all
          //       definitions. Can be made more robust to support the
          //       few cases where MSSQL actually supports them
          attribute.onUpdate = &apos;&apos;;
        }

      }

      if (key &amp;&amp; !attribute.field) attribute.field = key;
      result[attribute.field || key] = this.attributeToSQL(attribute, options);
    }

    return result;
  }

  createTrigger() {
    throwMethodUndefined(&apos;createTrigger&apos;);
  }

  dropTrigger() {
    throwMethodUndefined(&apos;dropTrigger&apos;);
  }

  renameTrigger() {
    throwMethodUndefined(&apos;renameTrigger&apos;);
  }

  createFunction() {
    throwMethodUndefined(&apos;createFunction&apos;);
  }

  dropFunction() {
    throwMethodUndefined(&apos;dropFunction&apos;);
  }

  renameFunction() {
    throwMethodUndefined(&apos;renameFunction&apos;);
  }

  /**
   * Generate common SQL prefix for ForeignKeysQuery.
   *
   * @param {string} catalogName
   * @returns {string}
   */
  _getForeignKeysQueryPrefix(catalogName) {
    return `${&apos;SELECT &apos; +
        &apos;constraint_name = OBJ.NAME, &apos; +
        &apos;constraintName = OBJ.NAME, &apos;}${
      catalogName ? `constraintCatalog = &apos;${catalogName}&apos;, ` : &apos;&apos;
    }constraintSchema = SCHEMA_NAME(OBJ.SCHEMA_ID), ` +
        &apos;tableName = TB.NAME, &apos; +
        `tableSchema = SCHEMA_NAME(TB.SCHEMA_ID), ${
          catalogName ? `tableCatalog = &apos;${catalogName}&apos;, ` : &apos;&apos;
        }columnName = COL.NAME, ` +
        `referencedTableSchema = SCHEMA_NAME(RTB.SCHEMA_ID), ${
          catalogName ? `referencedCatalog = &apos;${catalogName}&apos;, ` : &apos;&apos;
        }referencedTableName = RTB.NAME, ` +
        &apos;referencedColumnName = RCOL.NAME &apos; +
      &apos;FROM sys.foreign_key_columns FKC &apos; +
        &apos;INNER JOIN sys.objects OBJ ON OBJ.OBJECT_ID = FKC.CONSTRAINT_OBJECT_ID &apos; +
        &apos;INNER JOIN sys.tables TB ON TB.OBJECT_ID = FKC.PARENT_OBJECT_ID &apos; +
        &apos;INNER JOIN sys.columns COL ON COL.COLUMN_ID = PARENT_COLUMN_ID AND COL.OBJECT_ID = TB.OBJECT_ID &apos; +
        &apos;INNER JOIN sys.tables RTB ON RTB.OBJECT_ID = FKC.REFERENCED_OBJECT_ID &apos; +
        &apos;INNER JOIN sys.columns RCOL ON RCOL.COLUMN_ID = REFERENCED_COLUMN_ID AND RCOL.OBJECT_ID = RTB.OBJECT_ID&apos;;
  }

  /**
   * Generates an SQL query that returns all foreign keys details of a table.
   *
   * @param {string|Object} table
   * @param {string} catalogName database name
   * @returns {string}
   */
  getForeignKeysQuery(table, catalogName) {
    const tableName = table.tableName || table;
    let sql = `${this._getForeignKeysQueryPrefix(catalogName)
    } WHERE TB.NAME =${wrapSingleQuote(tableName)}`;

    if (table.schema) {
      sql += ` AND SCHEMA_NAME(TB.SCHEMA_ID) =${wrapSingleQuote(table.schema)}`;
    }
    return sql;
  }

  getForeignKeyQuery(table, attributeName) {
    const tableName = table.tableName || table;
    let sql = `${this._getForeignKeysQueryPrefix()
    } WHERE TB.NAME =${wrapSingleQuote(tableName)
    } AND COL.NAME =${wrapSingleQuote(attributeName)}`;

    if (table.schema) {
      sql += ` AND SCHEMA_NAME(TB.SCHEMA_ID) =${wrapSingleQuote(table.schema)}`;
    }

    return sql;
  }

  getPrimaryKeyConstraintQuery(table, attributeName) {
    const tableName = wrapSingleQuote(table.tableName || table);
    return [
      &apos;SELECT K.TABLE_NAME AS tableName,&apos;,
      &apos;K.COLUMN_NAME AS columnName,&apos;,
      &apos;K.CONSTRAINT_NAME AS constraintName&apos;,
      &apos;FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS AS C&apos;,
      &apos;JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS K&apos;,
      &apos;ON C.TABLE_NAME = K.TABLE_NAME&apos;,
      &apos;AND C.CONSTRAINT_CATALOG = K.CONSTRAINT_CATALOG&apos;,
      &apos;AND C.CONSTRAINT_SCHEMA = K.CONSTRAINT_SCHEMA&apos;,
      &apos;AND C.CONSTRAINT_NAME = K.CONSTRAINT_NAME&apos;,
      &apos;WHERE C.CONSTRAINT_TYPE = \&apos;PRIMARY KEY\&apos;&apos;,
      `AND K.COLUMN_NAME = ${wrapSingleQuote(attributeName)}`,
      `AND K.TABLE_NAME = ${tableName};`
    ].join(&apos; &apos;);
  }

  dropForeignKeyQuery(tableName, foreignKey) {
    return `ALTER TABLE ${this.quoteTable(tableName)} DROP ${this.quoteIdentifier(foreignKey)}`;
  }

  getDefaultConstraintQuery(tableName, attributeName) {
    const quotedTable = this.quoteTable(tableName);
    return &apos;SELECT name FROM sys.default_constraints &apos; +
      `WHERE PARENT_OBJECT_ID = OBJECT_ID(&apos;${quotedTable}&apos;, &apos;U&apos;) ` +
      `AND PARENT_COLUMN_ID = (SELECT column_id FROM sys.columns WHERE NAME = (&apos;${attributeName}&apos;) ` +
      `AND object_id = OBJECT_ID(&apos;${quotedTable}&apos;, &apos;U&apos;));`;
  }

  dropConstraintQuery(tableName, constraintName) {
    return `ALTER TABLE ${this.quoteTable(tableName)} DROP CONSTRAINT ${this.quoteIdentifier(constraintName)};`;
  }

  setIsolationLevelQuery() {

  }

  generateTransactionId() {
    return randomBytes(10).toString(&apos;hex&apos;);
  }

  startTransactionQuery(transaction) {
    if (transaction.parent) {
      return `SAVE TRANSACTION ${this.quoteIdentifier(transaction.name)};`;
    }

    return &apos;BEGIN TRANSACTION;&apos;;
  }

  commitTransactionQuery(transaction) {
    if (transaction.parent) {
      return;
    }

    return &apos;COMMIT TRANSACTION;&apos;;
  }

  rollbackTransactionQuery(transaction) {
    if (transaction.parent) {
      return `ROLLBACK TRANSACTION ${this.quoteIdentifier(transaction.name)};`;
    }

    return &apos;ROLLBACK TRANSACTION;&apos;;
  }

  selectFromTableFragment(options, model, attributes, tables, mainTableAs, where) {
    let topFragment = &apos;&apos;;
    let mainFragment = `SELECT ${attributes.join(&apos;, &apos;)} FROM ${tables}`;

    // Handle SQL Server 2008 with TOP instead of LIMIT
    if (semver.valid(this.sequelize.options.databaseVersion) &amp;&amp; semver.lt(this.sequelize.options.databaseVersion, &apos;11.0.0&apos;)) {
      if (options.limit) {
        topFragment = `TOP ${options.limit} `;
      }
      if (options.offset) {
        const offset = options.offset || 0,
          isSubQuery = options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation;
        let orders = { mainQueryOrder: [] };
        if (options.order) {
          orders = this.getQueryOrders(options, model, isSubQuery);
        }

        if (!orders.mainQueryOrder.length) {
          orders.mainQueryOrder.push(this.quoteIdentifier(model.primaryKeyField));
        }

        const tmpTable = mainTableAs ? mainTableAs : &apos;OffsetTable&apos;;
        const whereFragment = where ? ` WHERE ${where}` : &apos;&apos;;

        /*
         * For earlier versions of SQL server, we need to nest several queries
         * in order to emulate the OFFSET behavior.
         *
         * 1. The outermost query selects all items from the inner query block.
         *    This is due to a limitation in SQL server with the use of computed
         *    columns (e.g. SELECT ROW_NUMBER()...AS x) in WHERE clauses.
         * 2. The next query handles the LIMIT and OFFSET behavior by getting
         *    the TOP N rows of the query where the row number is &gt; OFFSET
         * 3. The innermost query is the actual set we want information from
         */
        const fragment = `SELECT TOP 100 PERCENT ${attributes.join(&apos;, &apos;)} FROM ` +
                        `(SELECT ${topFragment}*` +
                          ` FROM (SELECT ROW_NUMBER() OVER (ORDER BY ${orders.mainQueryOrder.join(&apos;, &apos;)}) as row_num, * ` +
                            ` FROM ${tables} AS ${tmpTable}${whereFragment})` +
                          ` AS ${tmpTable} WHERE row_num &gt; ${offset})` +
                        ` AS ${tmpTable}`;
        return fragment;
      }
      mainFragment = `SELECT ${topFragment}${attributes.join(&apos;, &apos;)} FROM ${tables}`;
    }

    if (mainTableAs) {
      mainFragment += ` AS ${mainTableAs}`;
    }

    if (options.tableHint &amp;&amp; TableHints[options.tableHint]) {
      mainFragment += ` WITH (${TableHints[options.tableHint]})`;
    }

    return mainFragment;
  }

  addLimitAndOffset(options, model) {
    // Skip handling of limit and offset as postfixes for older SQL Server versions
    if (semver.valid(this.sequelize.options.databaseVersion) &amp;&amp; semver.lt(this.sequelize.options.databaseVersion, &apos;11.0.0&apos;)) {
      return &apos;&apos;;
    }

    const offset = options.offset || 0;
    const isSubQuery = options.subQuery === undefined
      ? options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation
      : options.subQuery;

    let fragment = &apos;&apos;;
    let orders = {};

    if (options.order) {
      orders = this.getQueryOrders(options, model, isSubQuery);
    }

    if (options.limit || options.offset) {
      if (!options.order || options.include &amp;&amp; !orders.subQueryOrder.length) {
        fragment += options.order &amp;&amp; !isSubQuery ? &apos;, &apos; : &apos; ORDER BY &apos;;
        fragment += `${this.quoteTable(options.tableAs || model.name)}.${this.quoteIdentifier(model.primaryKeyField)}`;
      }

      if (options.offset || options.limit) {
        fragment += ` OFFSET ${this.escape(offset)} ROWS`;
      }

      if (options.limit) {
        fragment += ` FETCH NEXT ${this.escape(options.limit)} ROWS ONLY`;
      }
    }

    return fragment;
  }

  booleanValue(value) {
    return value ? 1 : 0;
  }
}

// private methods
function wrapSingleQuote(identifier) {
  return Utils.addTicks(Utils.removeTicks(identifier, &quot;&apos;&quot;), &quot;&apos;&quot;);
}

module.exports = MSSQLQueryGenerator;
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>


</body></html>