<!DOCTYPE html><html><head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../">
  <title data-ice="title">lib/dialects/postgres/query-generator.js | Sequelize</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<link rel="stylesheet" href="./inject/css/0-style.css"><link rel="stylesheet" href="./inject/css/0-theme.css"><meta name="description" content="An easy-to-use multi SQL dialect ORM for Node.js"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="Sequelize"><meta property="twitter:description" content="An easy-to-use multi SQL dialect ORM for Node.js"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./" style="display: flex; align-items: center;"><img src="./image/brand_logo.png" style="width:34px;"></a>
  
  <a href="identifiers.html" class="api-reference-link">API Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style href="https://github.com/sequelize/sequelize"><img width="30px" src="./image/github.png" style="width: 30px;"></a>
      <a href="http://sequelize-slack.herokuapp.com/">
        <img src="manual/asset/slack.svg" style="width: 60px; margin-left: -15px;">
      </a>
    </header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  


































<li data-ice="doc" style="margin-top: 15px;"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/model.js~Model.html">Model</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/query-interface.js~QueryInterface.html">QueryInterface</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/sequelize.js~Sequelize.html">Sequelize</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/transaction.js~Transaction.html">Transaction</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-DataTypes">DataTypes</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Deferrable">Deferrable</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-IndexHints">IndexHints</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Op">Op</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-QueryTypes">QueryTypes</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-TableHints">TableHints</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#associations">associations</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/associations/base.js~Association.html">Association</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/associations/belongs-to-many.js~BelongsToMany.html">BelongsToMany</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/associations/belongs-to.js~BelongsTo.html">BelongsTo</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/associations/has-many.js~HasMany.html">HasMany</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/associations/has-one.js~HasOne.html">HasOne</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#dialects-sqlite">dialects/sqlite</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-describeTable">describeTable</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#errors">errors</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/errors/association-error.js~AssociationError.html">AssociationError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/errors/base-error.js~BaseError.html">BaseError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/errors/bulk-record-error.js~BulkRecordError.html">BulkRecordError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/errors/connection-error.js~ConnectionError.html">ConnectionError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/errors/database-error.js~DatabaseError.html">DatabaseError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/errors/eager-loading-error.js~EagerLoadingError.html">EagerLoadingError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/errors/empty-result-error.js~EmptyResultError.html">EmptyResultError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/errors/instance-error.js~InstanceError.html">InstanceError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/errors/optimistic-lock-error.js~OptimisticLockError.html">OptimisticLockError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/errors/query-error.js~QueryError.html">QueryError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/errors/sequelize-scope-error.js~SequelizeScopeError.html">SequelizeScopeError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/errors/validation-error.js~ValidationError.html">ValidationError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/errors/validation-error.js~ValidationErrorItem.html">ValidationErrorItem</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#errors-connection">errors/connection</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/errors/connection/access-denied-error.js~AccessDeniedError.html">AccessDeniedError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/errors/connection/connection-acquire-timeout-error.js~ConnectionAcquireTimeoutError.html">ConnectionAcquireTimeoutError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/errors/connection/connection-refused-error.js~ConnectionRefusedError.html">ConnectionRefusedError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/errors/connection/connection-timed-out-error.js~ConnectionTimedOutError.html">ConnectionTimedOutError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/errors/connection/host-not-found-error.js~HostNotFoundError.html">HostNotFoundError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/errors/connection/host-not-reachable-error.js~HostNotReachableError.html">HostNotReachableError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/errors/connection/invalid-connection-error.js~InvalidConnectionError.html">InvalidConnectionError</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#errors-database">errors/database</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/errors/database/exclusion-constraint-error.js~ExclusionConstraintError.html">ExclusionConstraintError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/errors/database/foreign-key-constraint-error.js~ForeignKeyConstraintError.html">ForeignKeyConstraintError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/errors/database/timeout-error.js~TimeoutError.html">TimeoutError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/errors/database/unknown-constraint-error.js~UnknownConstraintError.html">UnknownConstraintError</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#errors-validation">errors/validation</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/errors/validation/unique-constraint-error.js~UniqueConstraintError.html">UniqueConstraintError</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="variable/index.html#static-variable-DataTypes">datatypes</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~ARRAY.html">ARRAY</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~VIRTUAL.html">VIRTUAL</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~UUIDV4.html">UUIDV4</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~UUIDV1.html">UUIDV1</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~UUID.html">UUID</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~TINYINT.html">TINYINT</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~TIME.html">TIME</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~TEXT.html">TEXT</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~STRING.html">STRING</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~SMALLINT.html">SMALLINT</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~REAL.html">REAL</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~RANGE.html">RANGE</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~NUMBER.html">NUMBER</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~NOW.html">NOW</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~MEDIUMINT.html">MEDIUMINT</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~MACADDR.html">MACADDR</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~JSONTYPE.html">JSONTYPE</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~JSONB.html">JSONB</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~INTEGER.html">INTEGER</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~INET.html">INET</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~HSTORE.html">HSTORE</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~GEOMETRY.html">GEOMETRY</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~GEOGRAPHY.html">GEOGRAPHY</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~FLOAT.html">FLOAT</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~ENUM.html">ENUM</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~DOUBLE.html">DOUBLE</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~DECIMAL.html">DECIMAL</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~DATEONLY.html">DATEONLY</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~DATE.html">DATE</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~CITEXT.html">CITEXT</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~CIDR.html">CIDR</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~CHAR.html">CHAR</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~BOOLEAN.html">BOOLEAN</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~BLOB.html">BLOB</a></span></span></li><li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/data-types.js~BIGINT.html">BIGINT</a></span></span></li></ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">lib/dialects/postgres/query-generator.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&apos;use strict&apos;;

const Utils = require(&apos;../../utils&apos;);
const util = require(&apos;util&apos;);
const DataTypes = require(&apos;../../data-types&apos;);
const AbstractQueryGenerator = require(&apos;../abstract/query-generator&apos;);
const semver = require(&apos;semver&apos;);
const _ = require(&apos;lodash&apos;);

class PostgresQueryGenerator extends AbstractQueryGenerator {
  setSearchPath(searchPath) {
    return `SET search_path to ${searchPath};`;
  }

  createDatabaseQuery(databaseName, options) {
    options = Object.assign({
      encoding: null,
      collate: null
    }, options || {});

    const values = {
      database: this.quoteTable(databaseName),
      encoding: options.encoding ? ` ENCODING = ${this.escape(options.encoding)}` : &apos;&apos;,
      collation: options.collate ? ` LC_COLLATE = ${this.escape(options.collate)}` : &apos;&apos;,
      ctype: options.ctype ? ` LC_CTYPE = ${this.escape(options.ctype)}` : &apos;&apos;,
      template: options.template ? ` TEMPLATE = ${this.escape(options.template)}` : &apos;&apos;
    };

    return `CREATE DATABASE ${values.database}${values.encoding}${values.collation}${values.ctype}${values.template};`;
  }

  dropDatabaseQuery(databaseName) {
    return `DROP DATABASE IF EXISTS ${this.quoteTable(databaseName)};`;
  }

  createSchema(schema) {
    const databaseVersion = _.get(this, &apos;sequelize.options.databaseVersion&apos;, 0);

    if (databaseVersion &amp;&amp; semver.gte(databaseVersion, &apos;9.2.0&apos;)) {
      return `CREATE SCHEMA IF NOT EXISTS ${schema};`;
    }

    return `CREATE SCHEMA ${schema};`;
  }

  dropSchema(schema) {
    return `DROP SCHEMA IF EXISTS ${schema} CASCADE;`;
  }

  showSchemasQuery() {
    return &quot;SELECT schema_name FROM information_schema.schemata WHERE schema_name &lt;&gt; &apos;information_schema&apos; AND schema_name != &apos;public&apos; AND schema_name !~ E&apos;^pg_&apos;;&quot;;
  }

  versionQuery() {
    return &apos;SHOW SERVER_VERSION&apos;;
  }

  createTableQuery(tableName, attributes, options) {
    options = Object.assign({}, options || {});

    //Postgres 9.0 does not support CREATE TABLE IF NOT EXISTS, 9.1 and above do
    const databaseVersion = _.get(this, &apos;sequelize.options.databaseVersion&apos;, 0);
    const attrStr = [];
    let comments = &apos;&apos;;
    let columnComments = &apos;&apos;;

    const quotedTable = this.quoteTable(tableName);

    if (options.comment &amp;&amp; typeof options.comment === &apos;string&apos;) {
      comments += `; COMMENT ON TABLE ${quotedTable} IS ${this.escape(options.comment)}`;
    }

    for (const attr in attributes) {
      const quotedAttr = this.quoteIdentifier(attr);
      const i = attributes[attr].indexOf(&apos;COMMENT &apos;);
      if (i !== -1) {
        // Move comment to a separate query
        const escapedCommentText = this.escape(attributes[attr].substring(i + 8));
        columnComments += `; COMMENT ON COLUMN ${quotedTable}.${quotedAttr} IS ${escapedCommentText}`;
        attributes[attr] = attributes[attr].substring(0, i);
      }

      const dataType = this.dataTypeMapping(tableName, attr, attributes[attr]);
      attrStr.push(`${quotedAttr} ${dataType}`);
    }


    let attributesClause = attrStr.join(&apos;, &apos;);

    if (options.uniqueKeys) {
      _.each(options.uniqueKeys, columns =&gt; {
        if (columns.customIndex) {
          attributesClause += `, UNIQUE (${columns.fields.map(field =&gt; this.quoteIdentifier(field)).join(&apos;, &apos;)})`;
        }
      });
    }

    const pks = _.reduce(attributes, (acc, attribute, key) =&gt; {
      if (attribute.includes(&apos;PRIMARY KEY&apos;)) {
        acc.push(this.quoteIdentifier(key));
      }
      return acc;
    }, []).join(&apos;,&apos;);

    if (pks.length &gt; 0) {
      attributesClause += `, PRIMARY KEY (${pks})`;
    }

    return `CREATE TABLE ${databaseVersion === 0 || semver.gte(databaseVersion, &apos;9.1.0&apos;) ? &apos;IF NOT EXISTS &apos; : &apos;&apos;}${quotedTable} (${attributesClause})${comments}${columnComments};`;
  }

  dropTableQuery(tableName, options) {
    options = options || {};
    return `DROP TABLE IF EXISTS ${this.quoteTable(tableName)}${options.cascade ? &apos; CASCADE&apos; : &apos;&apos;};`;
  }

  showTablesQuery() {
    return &quot;SELECT table_name FROM information_schema.tables WHERE table_schema = &apos;public&apos; AND table_type LIKE &apos;%TABLE&apos; AND table_name != &apos;spatial_ref_sys&apos;;&quot;;
  }

  describeTableQuery(tableName, schema) {
    if (!schema) schema = &apos;public&apos;;

    return &apos;SELECT &apos; +
      &apos;pk.constraint_type as &quot;Constraint&quot;,&apos; +
      &apos;c.column_name as &quot;Field&quot;, &apos; +
      &apos;c.column_default as &quot;Default&quot;,&apos; +
      &apos;c.is_nullable as &quot;Null&quot;, &apos; +
      &apos;(CASE WHEN c.udt_name = \&apos;hstore\&apos; THEN c.udt_name ELSE c.data_type END) || (CASE WHEN c.character_maximum_length IS NOT NULL THEN \&apos;(\&apos; || c.character_maximum_length || \&apos;)\&apos; ELSE \&apos;\&apos; END) as &quot;Type&quot;, &apos; +
      &apos;(SELECT array_agg(e.enumlabel) FROM pg_catalog.pg_type t JOIN pg_catalog.pg_enum e ON t.oid=e.enumtypid WHERE t.typname=c.udt_name) AS &quot;special&quot;, &apos; +
      &apos;(SELECT pgd.description FROM pg_catalog.pg_statio_all_tables AS st INNER JOIN pg_catalog.pg_description pgd on (pgd.objoid=st.relid) WHERE c.ordinal_position=pgd.objsubid AND c.table_name=st.relname) AS &quot;Comment&quot; &apos; +
      &apos;FROM information_schema.columns c &apos; +
      &apos;LEFT JOIN (SELECT tc.table_schema, tc.table_name, &apos; +
      &apos;cu.column_name, tc.constraint_type &apos; +
      &apos;FROM information_schema.TABLE_CONSTRAINTS tc &apos; +
      &apos;JOIN information_schema.KEY_COLUMN_USAGE  cu &apos; +
      &apos;ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name &apos; +
      &apos;and tc.constraint_name=cu.constraint_name &apos; +
      &apos;and tc.constraint_type=\&apos;PRIMARY KEY\&apos;) pk &apos; +
      &apos;ON pk.table_schema=c.table_schema &apos; +
      &apos;AND pk.table_name=c.table_name &apos; +
      &apos;AND pk.column_name=c.column_name &apos; +
      `WHERE c.table_name = ${this.escape(tableName)} AND c.table_schema = ${this.escape(schema)} `;
  }

  /**
   * Check whether the statmement is json function or simple path
   *
   * @param   {string}  stmt  The statement to validate
   * @returns {boolean}       true if the given statement is json function
   * @throws  {Error}         throw if the statement looks like json function but has invalid token
   */
  _checkValidJsonStatement(stmt) {
    if (typeof stmt !== &apos;string&apos;) {
      return false;
    }

    // https://www.postgresql.org/docs/current/static/functions-json.html
    const jsonFunctionRegex = /^\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\([^)]*\)/i;
    const jsonOperatorRegex = /^\s*(-&gt;&gt;?|#&gt;&gt;?|@&gt;|&lt;@|\?[|&amp;]?|\|{2}|#-)/i;
    const tokenCaptureRegex = /^\s*((?:([`&quot;&apos;])(?:(?!\2).|\2{2})*\2)|[\w\d\s]+|[().,;+-])/i;

    let currentIndex = 0;
    let openingBrackets = 0;
    let closingBrackets = 0;
    let hasJsonFunction = false;
    let hasInvalidToken = false;

    while (currentIndex &lt; stmt.length) {
      const string = stmt.substr(currentIndex);
      const functionMatches = jsonFunctionRegex.exec(string);
      if (functionMatches) {
        currentIndex += functionMatches[0].indexOf(&apos;(&apos;);
        hasJsonFunction = true;
        continue;
      }

      const operatorMatches = jsonOperatorRegex.exec(string);
      if (operatorMatches) {
        currentIndex += operatorMatches[0].length;
        hasJsonFunction = true;
        continue;
      }

      const tokenMatches = tokenCaptureRegex.exec(string);
      if (tokenMatches) {
        const capturedToken = tokenMatches[1];
        if (capturedToken === &apos;(&apos;) {
          openingBrackets++;
        } else if (capturedToken === &apos;)&apos;) {
          closingBrackets++;
        } else if (capturedToken === &apos;;&apos;) {
          hasInvalidToken = true;
          break;
        }
        currentIndex += tokenMatches[0].length;
        continue;
      }

      break;
    }

    // Check invalid json statement
    hasInvalidToken |= openingBrackets !== closingBrackets;
    if (hasJsonFunction &amp;&amp; hasInvalidToken) {
      throw new Error(`Invalid json statement: ${stmt}`);
    }

    // return true if the statement has valid json function
    return hasJsonFunction;
  }

  handleSequelizeMethod(smth, tableName, factory, options, prepend) {
    if (smth instanceof Utils.Json) {
      // Parse nested object
      if (smth.conditions) {
        const conditions = this.parseConditionObject(smth.conditions).map(condition =&gt;
          `${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = &apos;${condition.value}&apos;`
        );

        return conditions.join(&apos; AND &apos;);
      }
      if (smth.path) {
        let str;

        // Allow specifying conditions using the postgres json syntax
        if (this._checkValidJsonStatement(smth.path)) {
          str = smth.path;
        } else {
          // Also support json property accessors
          const paths = _.toPath(smth.path);
          const column = paths.shift();
          str = this.jsonPathExtractionQuery(column, paths);
        }

        if (smth.value) {
          str += util.format(&apos; = %s&apos;, this.escape(smth.value));
        }

        return str;
      }
    }
    return super.handleSequelizeMethod.call(this, smth, tableName, factory, options, prepend);
  }

  addColumnQuery(table, key, dataType) {

    const dbDataType = this.attributeToSQL(dataType, { context: &apos;addColumn&apos;, table, key });
    const definition = this.dataTypeMapping(table, key, dbDataType);
    const quotedKey = this.quoteIdentifier(key);
    const quotedTable = this.quoteTable(this.extractTableDetails(table));

    let query = `ALTER TABLE ${quotedTable} ADD COLUMN ${quotedKey} ${definition};`;

    if (dataType.type &amp;&amp; dataType.type instanceof DataTypes.ENUM || dataType instanceof DataTypes.ENUM) {
      query = this.pgEnum(table, key, dataType) + query;
    }

    return query;
  }

  removeColumnQuery(tableName, attributeName) {
    const quotedTableName = this.quoteTable(this.extractTableDetails(tableName));
    const quotedAttributeName = this.quoteIdentifier(attributeName);
    return `ALTER TABLE ${quotedTableName} DROP COLUMN ${quotedAttributeName};`;
  }

  changeColumnQuery(tableName, attributes) {
    const query = subQuery =&gt; `ALTER TABLE ${this.quoteTable(tableName)} ALTER COLUMN ${subQuery};`;
    const sql = [];
    for (const attributeName in attributes) {
      let definition = this.dataTypeMapping(tableName, attributeName, attributes[attributeName]);
      let attrSql = &apos;&apos;;

      if (definition.includes(&apos;NOT NULL&apos;)) {
        attrSql += query(`${this.quoteIdentifier(attributeName)} SET NOT NULL`);

        definition = definition.replace(&apos;NOT NULL&apos;, &apos;&apos;).trim();
      } else if (!definition.includes(&apos;REFERENCES&apos;)) {
        attrSql += query(`${this.quoteIdentifier(attributeName)} DROP NOT NULL`);
      }

      if (definition.includes(&apos;DEFAULT&apos;)) {
        attrSql += query(`${this.quoteIdentifier(attributeName)} SET DEFAULT ${definition.match(/DEFAULT ([^;]+)/)[1]}`);

        definition = definition.replace(/(DEFAULT[^;]+)/, &apos;&apos;).trim();
      } else if (!definition.includes(&apos;REFERENCES&apos;)) {
        attrSql += query(`${this.quoteIdentifier(attributeName)} DROP DEFAULT`);
      }

      if (attributes[attributeName].startsWith(&apos;ENUM(&apos;)) {
        attrSql += this.pgEnum(tableName, attributeName, attributes[attributeName]);
        definition = definition.replace(/^ENUM\(.+\)/, this.pgEnumName(tableName, attributeName, { schema: false }));
        definition += ` USING (${this.quoteIdentifier(attributeName)}::${this.pgEnumName(tableName, attributeName)})`;
      }

      if (definition.match(/UNIQUE;*$/)) {
        definition = definition.replace(/UNIQUE;*$/, &apos;&apos;);
        attrSql += query(`ADD UNIQUE (${this.quoteIdentifier(attributeName)})`).replace(&apos;ALTER COLUMN&apos;, &apos;&apos;);
      }

      if (definition.includes(&apos;REFERENCES&apos;)) {
        definition = definition.replace(/.+?(?=REFERENCES)/, &apos;&apos;);
        attrSql += query(`ADD FOREIGN KEY (${this.quoteIdentifier(attributeName)}) ${definition}`).replace(&apos;ALTER COLUMN&apos;, &apos;&apos;);
      } else {
        attrSql += query(`${this.quoteIdentifier(attributeName)} TYPE ${definition}`);
      }

      sql.push(attrSql);
    }

    return sql.join(&apos;&apos;);
  }

  renameColumnQuery(tableName, attrBefore, attributes) {

    const attrString = [];

    for (const attributeName in attributes) {
      attrString.push(`${this.quoteIdentifier(attrBefore)} TO ${this.quoteIdentifier(attributeName)}`);
    }

    return `ALTER TABLE ${this.quoteTable(tableName)} RENAME COLUMN ${attrString.join(&apos;, &apos;)};`;
  }

  fn(fnName, tableName, parameters, body, returns, language) {
    fnName = fnName || &apos;testfunc&apos;;
    language = language || &apos;plpgsql&apos;;
    returns = returns ? `RETURNS ${returns}` : &apos;&apos;;
    parameters = parameters || &apos;&apos;;

    return `CREATE OR REPLACE FUNCTION pg_temp.${fnName}(${parameters}) ${returns} AS $func$ BEGIN ${body} END; $func$ LANGUAGE ${language}; SELECT * FROM pg_temp.${fnName}();`;
  }

  exceptionFn(fnName, tableName, parameters, main, then, when, returns, language) {
    when = when || &apos;unique_violation&apos;;

    const body = `${main} EXCEPTION WHEN ${when} THEN ${then};`;

    return this.fn(fnName, tableName, parameters, body, returns, language);
  }

  upsertQuery(tableName, insertValues, updateValues, where, model, options) {
    const primaryField = this.quoteIdentifier(model.primaryKeyField);

    const upsertOptions = _.defaults({ bindParam: false }, options);
    const insert = this.insertQuery(tableName, insertValues, model.rawAttributes, upsertOptions);
    const update = this.updateQuery(tableName, updateValues, where, upsertOptions, model.rawAttributes);

    if (options.returning) {
      const returningRegex = /RETURNING \*(?![\s\S]*RETURNING \*)/;

      insert.query = insert.query.replace(returningRegex, `RETURNING ${primaryField} INTO primary_key`);
      update.query = update.query.replace(returningRegex, `RETURNING ${primaryField} INTO primary_key`);
    }

    return this.exceptionFn(
      &apos;sequelize_upsert&apos;,
      tableName,
      &apos;OUT created boolean, OUT primary_key text&apos;,
      `${insert.query} created := true;`,
      `${update.query}; created := false`
    );
  }

  truncateTableQuery(tableName, options = {}) {
    return [
      `TRUNCATE ${this.quoteTable(tableName)}`,
      options.restartIdentity ? &apos; RESTART IDENTITY&apos; : &apos;&apos;,
      options.cascade ? &apos; CASCADE&apos; : &apos;&apos;
    ].join(&apos;&apos;);
  }

  deleteQuery(tableName, where, options = {}, model) {
    const table = this.quoteTable(tableName);
    let whereClause = this.getWhereConditions(where, null, model, options);
    const limit = options.limit ? ` LIMIT ${this.escape(options.limit)}` : &apos;&apos;;
    let primaryKeys = &apos;&apos;;
    let primaryKeysSelection = &apos;&apos;;

    if (whereClause) {
      whereClause = ` WHERE ${whereClause}`;
    }

    if (options.limit) {
      if (!model) {
        throw new Error(&apos;Cannot LIMIT delete without a model.&apos;);
      }

      const pks = _.values(model.primaryKeys).map(pk =&gt; this.quoteIdentifier(pk.field)).join(&apos;,&apos;);

      primaryKeys = model.primaryKeyAttributes.length &gt; 1 ? `(${pks})` : pks;
      primaryKeysSelection = pks;

      return `DELETE FROM ${table} WHERE ${primaryKeys} IN (SELECT ${primaryKeysSelection} FROM ${table}${whereClause}${limit})`;
    }
    return `DELETE FROM ${table}${whereClause}`;
  }

  showIndexesQuery(tableName) {
    let schemaJoin = &apos;&apos;;
    let schemaWhere = &apos;&apos;;
    if (typeof tableName !== &apos;string&apos;) {
      schemaJoin = &apos;, pg_namespace s&apos;;
      schemaWhere = ` AND s.oid = t.relnamespace AND s.nspname = &apos;${tableName.schema}&apos;`;
      tableName = tableName.tableName;
    }

    // This is ARCANE!
    return &apos;SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, &apos; +
      &apos;array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) &apos; +
      `AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a${schemaJoin} ` +
      &apos;WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND &apos; +
      `t.relkind = &apos;r&apos; and t.relname = &apos;${tableName}&apos;${schemaWhere} ` +
      &apos;GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;&apos;;
  }

  showConstraintsQuery(tableName) {
    //Postgres converts camelCased alias to lowercase unless quoted
    return [
      &apos;SELECT constraint_catalog AS &quot;constraintCatalog&quot;,&apos;,
      &apos;constraint_schema AS &quot;constraintSchema&quot;,&apos;,
      &apos;constraint_name AS &quot;constraintName&quot;,&apos;,
      &apos;table_catalog AS &quot;tableCatalog&quot;,&apos;,
      &apos;table_schema AS &quot;tableSchema&quot;,&apos;,
      &apos;table_name AS &quot;tableName&quot;,&apos;,
      &apos;constraint_type AS &quot;constraintType&quot;,&apos;,
      &apos;is_deferrable AS &quot;isDeferrable&quot;,&apos;,
      &apos;initially_deferred AS &quot;initiallyDeferred&quot;&apos;,
      &apos;from INFORMATION_SCHEMA.table_constraints&apos;,
      `WHERE table_name=&apos;${tableName}&apos;;`
    ].join(&apos; &apos;);
  }

  removeIndexQuery(tableName, indexNameOrAttributes) {
    let indexName = indexNameOrAttributes;

    if (typeof indexName !== &apos;string&apos;) {
      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join(&apos;_&apos;)}`);
    }

    return `DROP INDEX IF EXISTS ${this.quoteIdentifiers(indexName)}`;
  }

  addLimitAndOffset(options) {
    let fragment = &apos;&apos;;
    /* eslint-disable */
    if (options.limit != null) {
      fragment += &apos; LIMIT &apos; + this.escape(options.limit);
    }
    if (options.offset != null) {
      fragment += &apos; OFFSET &apos; + this.escape(options.offset);
    }
    /* eslint-enable */

    return fragment;
  }

  attributeToSQL(attribute, options) {
    if (!_.isPlainObject(attribute)) {
      attribute = {
        type: attribute
      };
    }

    let type;
    if (
      attribute.type instanceof DataTypes.ENUM ||
      attribute.type instanceof DataTypes.ARRAY &amp;&amp; attribute.type.type instanceof DataTypes.ENUM
    ) {
      const enumType = attribute.type.type || attribute.type;
      let values = attribute.values;

      if (enumType.values &amp;&amp; !attribute.values) {
        values = enumType.values;
      }

      if (Array.isArray(values) &amp;&amp; values.length &gt; 0) {
        type = `ENUM(${values.map(value =&gt; this.escape(value)).join(&apos;, &apos;)})`;

        if (attribute.type instanceof DataTypes.ARRAY) {
          type += &apos;[]&apos;;
        }

      } else {
        throw new Error(&quot;Values for ENUM haven&apos;t been defined.&quot;);
      }
    }

    if (!type) {
      type = attribute.type;
    }

    let sql = type.toString();

    if (Object.prototype.hasOwnProperty.call(attribute, &apos;allowNull&apos;) &amp;&amp; !attribute.allowNull) {
      sql += &apos; NOT NULL&apos;;
    }

    if (attribute.autoIncrement) {
      if (attribute.autoIncrementIdentity) {
        sql += &apos; GENERATED BY DEFAULT AS IDENTITY&apos;;
      } else {
        sql += &apos; SERIAL&apos;;
      }
    }

    if (Utils.defaultValueSchemable(attribute.defaultValue)) {
      sql += ` DEFAULT ${this.escape(attribute.defaultValue, attribute)}`;
    }

    if (attribute.unique === true) {
      sql += &apos; UNIQUE&apos;;
    }

    if (attribute.primaryKey) {
      sql += &apos; PRIMARY KEY&apos;;
    }

    if (attribute.references) {
      let referencesTable = this.quoteTable(attribute.references.model);
      let schema;

      if (options.schema) {
        schema = options.schema;
      } else if (
        (!attribute.references.model || typeof attribute.references.model == &apos;string&apos;)
        &amp;&amp; options.table
        &amp;&amp; options.table.schema
      ) {
        schema = options.table.schema;
      }

      if (schema) {
        referencesTable = this.quoteTable(this.addSchema({
          tableName: referencesTable,
          _schema: schema
        }));
      }

      let referencesKey;

      if (attribute.references.key) {
        referencesKey = this.quoteIdentifiers(attribute.references.key);
      } else {
        referencesKey = this.quoteIdentifier(&apos;id&apos;);
      }

      sql += ` REFERENCES ${referencesTable} (${referencesKey})`;

      if (attribute.onDelete) {
        sql += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;
      }

      if (attribute.onUpdate) {
        sql += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;
      }

      if (attribute.references.deferrable) {
        sql += ` ${attribute.references.deferrable.toString(this)}`;
      }
    }

    if (attribute.comment &amp;&amp; typeof attribute.comment === &apos;string&apos;) {
      if (options &amp;&amp; (options.context === &apos;addColumn&apos; || options.context === &apos;changeColumn&apos;)) {
        const quotedAttr = this.quoteIdentifier(options.key);
        const escapedCommentText = this.escape(attribute.comment);
        sql += `; COMMENT ON COLUMN ${this.quoteTable(options.table)}.${quotedAttr} IS ${escapedCommentText}`;
      } else {
        // for createTable event which does it&apos;s own parsing
        // TODO: centralize creation of comment statements here
        sql += ` COMMENT ${attribute.comment}`;
      }
    }

    return sql;
  }

  deferConstraintsQuery(options) {
    return options.deferrable.toString(this);
  }

  setConstraintQuery(columns, type) {
    let columnFragment = &apos;ALL&apos;;

    if (columns) {
      columnFragment = columns.map(column =&gt; this.quoteIdentifier(column)).join(&apos;, &apos;);
    }

    return `SET CONSTRAINTS ${columnFragment} ${type}`;
  }

  setDeferredQuery(columns) {
    return this.setConstraintQuery(columns, &apos;DEFERRED&apos;);
  }

  setImmediateQuery(columns) {
    return this.setConstraintQuery(columns, &apos;IMMEDIATE&apos;);
  }

  attributesToSQL(attributes, options) {
    const result = {};

    for (const key in attributes) {
      const attribute = attributes[key];
      result[attribute.field || key] = this.attributeToSQL(attribute, Object.assign({ key }, options || {}));
    }

    return result;
  }

  createTrigger(tableName, triggerName, eventType, fireOnSpec, functionName, functionParams, optionsArray) {
    const decodedEventType = this.decodeTriggerEventType(eventType);
    const eventSpec = this.expandTriggerEventSpec(fireOnSpec);
    const expandedOptions = this.expandOptions(optionsArray);
    const paramList = this.expandFunctionParamList(functionParams);

    return `CREATE ${this.triggerEventTypeIsConstraint(eventType)}TRIGGER ${this.quoteIdentifier(triggerName)} ${decodedEventType} ${
      eventSpec} ON ${this.quoteTable(tableName)}${expandedOptions ? ` ${expandedOptions}` : &apos;&apos;} EXECUTE PROCEDURE ${functionName}(${paramList});`;
  }

  dropTrigger(tableName, triggerName) {
    return `DROP TRIGGER ${this.quoteIdentifier(triggerName)} ON ${this.quoteTable(tableName)} RESTRICT;`;
  }

  renameTrigger(tableName, oldTriggerName, newTriggerName) {
    return `ALTER TRIGGER ${this.quoteIdentifier(oldTriggerName)} ON ${this.quoteTable(tableName)} RENAME TO ${this.quoteIdentifier(newTriggerName)};`;
  }

  createFunction(functionName, params, returnType, language, body, optionsArray, options) {
    if (!functionName || !returnType || !language || !body) throw new Error(&apos;createFunction missing some parameters. Did you pass functionName, returnType, language and body?&apos;);

    const paramList = this.expandFunctionParamList(params);
    const variableList = options &amp;&amp; options.variables ? this.expandFunctionVariableList(options.variables) : &apos;&apos;;
    const expandedOptionsArray = this.expandOptions(optionsArray);

    const statement = options &amp;&amp; options.force ? &apos;CREATE OR REPLACE FUNCTION&apos; : &apos;CREATE FUNCTION&apos;;

    return `${statement} ${functionName}(${paramList}) RETURNS ${returnType} AS $func$ ${variableList} BEGIN ${body} END; $func$ language &apos;${language}&apos;${expandedOptionsArray};`;
  }

  dropFunction(functionName, params) {
    if (!functionName) throw new Error(&apos;requires functionName&apos;);
    // RESTRICT is (currently, as of 9.2) default but we&apos;ll be explicit
    const paramList = this.expandFunctionParamList(params);
    return `DROP FUNCTION ${functionName}(${paramList}) RESTRICT;`;
  }

  renameFunction(oldFunctionName, params, newFunctionName) {
    const paramList = this.expandFunctionParamList(params);
    return `ALTER FUNCTION ${oldFunctionName}(${paramList}) RENAME TO ${newFunctionName};`;
  }

  databaseConnectionUri(config) {
    let uri = `${config.protocol}://${config.user}:${config.password}@${config.host}`;
    if (config.port) {
      uri += `:${config.port}`;
    }
    uri += `/${config.database}`;
    if (config.ssl) {
      uri += `?ssl=${config.ssl}`;
    }
    return uri;
  }

  pgEscapeAndQuote(val) {
    return this.quoteIdentifier(Utils.removeTicks(this.escape(val), &quot;&apos;&quot;));
  }

  expandFunctionParamList(params) {
    if (params === undefined || !Array.isArray(params)) {
      throw new Error(&apos;expandFunctionParamList: function parameters array required, including an empty one for no arguments&apos;);
    }

    const paramList = [];
    params.forEach(curParam =&gt; {
      const paramDef = [];
      if (curParam.type) {
        if (curParam.direction) { paramDef.push(curParam.direction); }
        if (curParam.name) { paramDef.push(curParam.name); }
        paramDef.push(curParam.type);
      } else {
        throw new Error(&apos;function or trigger used with a parameter without any type&apos;);
      }

      const joined = paramDef.join(&apos; &apos;);
      if (joined) paramList.push(joined);

    });

    return paramList.join(&apos;, &apos;);
  }

  expandFunctionVariableList(variables) {
    if (!Array.isArray(variables)) {
      throw new Error(&apos;expandFunctionVariableList: function variables must be an array&apos;);
    }
    const variableDefinitions = [];
    variables.forEach(variable =&gt; {
      if (!variable.name || !variable.type) {
        throw new Error(&apos;function variable must have a name and type&apos;);
      }
      let variableDefinition = `DECLARE ${variable.name} ${variable.type}`;
      if (variable.default) {
        variableDefinition += ` := ${variable.default}`;
      }
      variableDefinition += &apos;;&apos;;
      variableDefinitions.push(variableDefinition);
    });
    return variableDefinitions.join(&apos; &apos;);
  }

  expandOptions(options) {
    return options === undefined || _.isEmpty(options) ?
      &apos;&apos; : options.join(&apos; &apos;);
  }

  decodeTriggerEventType(eventSpecifier) {
    const EVENT_DECODER = {
      &apos;after&apos;: &apos;AFTER&apos;,
      &apos;before&apos;: &apos;BEFORE&apos;,
      &apos;instead_of&apos;: &apos;INSTEAD OF&apos;,
      &apos;after_constraint&apos;: &apos;AFTER&apos;
    };

    if (!EVENT_DECODER[eventSpecifier]) {
      throw new Error(`Invalid trigger event specified: ${eventSpecifier}`);
    }

    return EVENT_DECODER[eventSpecifier];
  }

  triggerEventTypeIsConstraint(eventSpecifier) {
    return eventSpecifier === &apos;after_constraint&apos; ? &apos;CONSTRAINT &apos; : &apos;&apos;;
  }

  expandTriggerEventSpec(fireOnSpec) {
    if (_.isEmpty(fireOnSpec)) {
      throw new Error(&apos;no table change events specified to trigger on&apos;);
    }

    return _.map(fireOnSpec, (fireValue, fireKey) =&gt; {
      const EVENT_MAP = {
        &apos;insert&apos;: &apos;INSERT&apos;,
        &apos;update&apos;: &apos;UPDATE&apos;,
        &apos;delete&apos;: &apos;DELETE&apos;,
        &apos;truncate&apos;: &apos;TRUNCATE&apos;
      };

      if (!EVENT_MAP[fireValue]) {
        throw new Error(`parseTriggerEventSpec: undefined trigger event ${fireKey}`);
      }

      let eventSpec = EVENT_MAP[fireValue];
      if (eventSpec === &apos;UPDATE&apos;) {
        if (Array.isArray(fireValue) &amp;&amp; fireValue.length &gt; 0) {
          eventSpec += ` OF ${fireValue.join(&apos;, &apos;)}`;
        }
      }

      return eventSpec;
    }).join(&apos; OR &apos;);
  }

  pgEnumName(tableName, attr, options) {
    options = options || {};

    const tableDetails = this.extractTableDetails(tableName, options);
    let enumName = Utils.addTicks(Utils.generateEnumName(tableDetails.tableName, attr), &apos;&quot;&apos;);

    // pgListEnums requires the enum name only, without the schema
    if (options.schema !== false &amp;&amp; tableDetails.schema) {
      enumName = this.quoteIdentifier(tableDetails.schema) + tableDetails.delimiter + enumName;
    }

    return enumName;
  }

  pgListEnums(tableName, attrName, options) {
    let enumName = &apos;&apos;;
    const tableDetails = this.extractTableDetails(tableName, options);

    if (tableDetails.tableName &amp;&amp; attrName) {
      enumName = ` AND t.typname=${this.pgEnumName(tableDetails.tableName, attrName, { schema: false }).replace(/&quot;/g, &quot;&apos;&quot;)}`;
    }

    return &apos;SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t &apos; +
      &apos;JOIN pg_enum e ON t.oid = e.enumtypid &apos; +
      &apos;JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace &apos; +
      `WHERE n.nspname = &apos;${tableDetails.schema}&apos;${enumName} GROUP BY 1`;
  }

  pgEnum(tableName, attr, dataType, options) {
    const enumName = this.pgEnumName(tableName, attr, options);
    let values;

    if (dataType.values) {
      values = `ENUM(${dataType.values.map(value =&gt; this.escape(value)).join(&apos;, &apos;)})`;
    } else {
      values = dataType.toString().match(/^ENUM\(.+\)/)[0];
    }

    let sql = `CREATE TYPE ${enumName} AS ${values};`;
    if (!!options &amp;&amp; options.force === true) {
      sql = this.pgEnumDrop(tableName, attr) + sql;
    }
    return sql;
  }

  pgEnumAdd(tableName, attr, value, options) {
    const enumName = this.pgEnumName(tableName, attr);
    let sql = `ALTER TYPE ${enumName} ADD VALUE `;

    if (semver.gte(this.sequelize.options.databaseVersion, &apos;9.3.0&apos;)) {
      sql += &apos;IF NOT EXISTS &apos;;
    }
    sql += this.escape(value);

    if (options.before) {
      sql += ` BEFORE ${this.escape(options.before)}`;
    } else if (options.after) {
      sql += ` AFTER ${this.escape(options.after)}`;
    }

    return sql;
  }

  pgEnumDrop(tableName, attr, enumName) {
    enumName = enumName || this.pgEnumName(tableName, attr);
    return `DROP TYPE IF EXISTS ${enumName}; `;
  }

  fromArray(text) {
    text = text.replace(/^{/, &apos;&apos;).replace(/}$/, &apos;&apos;);
    let matches = text.match(/(&quot;(?:\\.|[^&quot;\\\\])*&quot;|[^,]*)(?:\s*,\s*|\s*$)/ig);

    if (matches.length &lt; 1) {
      return [];
    }

    matches = matches.map(m =&gt; m.replace(/&quot;,$/, &apos;&apos;).replace(/,$/, &apos;&apos;).replace(/(^&quot;|&quot;$)/g, &apos;&apos;));

    return matches.slice(0, -1);
  }

  padInt(i) {
    return i &lt; 10 ? `0${i.toString()}` : i.toString();
  }

  dataTypeMapping(tableName, attr, dataType) {
    if (dataType.includes(&apos;PRIMARY KEY&apos;)) {
      dataType = dataType.replace(&apos;PRIMARY KEY&apos;, &apos;&apos;);
    }

    if (dataType.includes(&apos;SERIAL&apos;)) {
      if (dataType.includes(&apos;BIGINT&apos;)) {
        dataType = dataType.replace(&apos;SERIAL&apos;, &apos;BIGSERIAL&apos;);
        dataType = dataType.replace(&apos;BIGINT&apos;, &apos;&apos;);
      } else if (dataType.includes(&apos;SMALLINT&apos;)) {
        dataType = dataType.replace(&apos;SERIAL&apos;, &apos;SMALLSERIAL&apos;);
        dataType = dataType.replace(&apos;SMALLINT&apos;, &apos;&apos;);
      } else {
        dataType = dataType.replace(&apos;INTEGER&apos;, &apos;&apos;);
      }
      dataType = dataType.replace(&apos;NOT NULL&apos;, &apos;&apos;);
    }

    if (dataType.startsWith(&apos;ENUM(&apos;)) {
      dataType = dataType.replace(/^ENUM\(.+\)/, this.pgEnumName(tableName, attr));
    }

    return dataType;
  }

  /**
   * Generates an SQL query that returns all foreign keys of a table.
   *
   * @param  {string} tableName  The name of the table.
   * @returns {string}            The generated sql query.
   * @private
   */
  getForeignKeysQuery(tableName) {
    return &apos;SELECT conname as constraint_name, pg_catalog.pg_get_constraintdef(r.oid, true) as condef FROM pg_catalog.pg_constraint r &apos; +
      `WHERE r.conrelid = (SELECT oid FROM pg_class WHERE relname = &apos;${tableName}&apos; LIMIT 1) AND r.contype = &apos;f&apos; ORDER BY 1;`;
  }

  /**
   * Generate common SQL prefix for getForeignKeyReferencesQuery.
   *
   * @returns {string}
   */
  _getForeignKeyReferencesQueryPrefix() {
    return &apos;SELECT &apos; +
      &apos;DISTINCT tc.constraint_name as constraint_name, &apos; +
      &apos;tc.constraint_schema as constraint_schema, &apos; +
      &apos;tc.constraint_catalog as constraint_catalog, &apos; +
      &apos;tc.table_name as table_name,&apos; +
      &apos;tc.table_schema as table_schema,&apos; +
      &apos;tc.table_catalog as table_catalog,&apos; +
      &apos;kcu.column_name as column_name,&apos; +
      &apos;ccu.table_schema  AS referenced_table_schema,&apos; +
      &apos;ccu.table_catalog  AS referenced_table_catalog,&apos; +
      &apos;ccu.table_name  AS referenced_table_name,&apos; +
      &apos;ccu.column_name AS referenced_column_name &apos; +
      &apos;FROM information_schema.table_constraints AS tc &apos; +
      &apos;JOIN information_schema.key_column_usage AS kcu &apos; +
      &apos;ON tc.constraint_name = kcu.constraint_name &apos; +
      &apos;JOIN information_schema.constraint_column_usage AS ccu &apos; +
      &apos;ON ccu.constraint_name = tc.constraint_name &apos;;
  }

  /**
   * Generates an SQL query that returns all foreign keys details of a table.
   *
   * As for getForeignKeysQuery is not compatible with getForeignKeyReferencesQuery, so add a new function.
   *
   * @param {string} tableName
   * @param {string} catalogName
   * @param {string} schemaName
   */
  getForeignKeyReferencesQuery(tableName, catalogName, schemaName) {
    return `${this._getForeignKeyReferencesQueryPrefix()
    }WHERE constraint_type = &apos;FOREIGN KEY&apos; AND tc.table_name = &apos;${tableName}&apos;${
      catalogName ? ` AND tc.table_catalog = &apos;${catalogName}&apos;` : &apos;&apos;
    }${schemaName ? ` AND tc.table_schema = &apos;${schemaName}&apos;` : &apos;&apos;}`;
  }

  getForeignKeyReferenceQuery(table, columnName) {
    const tableName = table.tableName || table;
    const schema = table.schema;
    return `${this._getForeignKeyReferencesQueryPrefix()
    }WHERE constraint_type = &apos;FOREIGN KEY&apos; AND tc.table_name=&apos;${tableName}&apos; AND  kcu.column_name = &apos;${columnName}&apos;${
      schema ? ` AND tc.table_schema = &apos;${schema}&apos;` : &apos;&apos;}`;
  }

  /**
   * Generates an SQL query that removes a foreign key from a table.
   *
   * @param  {string} tableName  The name of the table.
   * @param  {string} foreignKey The name of the foreign key constraint.
   * @returns {string}            The generated sql query.
   * @private
   */
  dropForeignKeyQuery(tableName, foreignKey) {
    return `ALTER TABLE ${this.quoteTable(tableName)} DROP CONSTRAINT ${this.quoteIdentifier(foreignKey)};`;
  }
}

module.exports = PostgresQueryGenerator;
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>


</body></html>